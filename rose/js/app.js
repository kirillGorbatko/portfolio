(() => {
  "use strict";
  function t(t) {
    this.type = t;
  }
  (t.prototype.init = function () {
    const t = this;
    (this.оbjects = []),
      (this.daClassname = "_dynamic_adapt_"),
      (this.nodes = document.querySelectorAll("[data-da]"));
    for (let t = 0; t < this.nodes.length; t++) {
      const e = this.nodes[t],
        i = e.dataset.da.trim().split(","),
        n = {};
      (n.element = e),
        (n.parent = e.parentNode),
        (n.destination = document.querySelector(i[0].trim())),
        (n.breakpoint = i[1] ? i[1].trim() : "767"),
        (n.place = i[2] ? i[2].trim() : "last"),
        (n.index = this.indexInParent(n.parent, n.element)),
        this.оbjects.push(n);
    }
    this.arraySort(this.оbjects),
      (this.mediaQueries = Array.prototype.map.call(
        this.оbjects,
        function (t) {
          return (
            "(" + this.type + "-width: " + t.breakpoint + "px)," + t.breakpoint
          );
        },
        this
      )),
      (this.mediaQueries = Array.prototype.filter.call(
        this.mediaQueries,
        function (t, e, i) {
          return Array.prototype.indexOf.call(i, t) === e;
        }
      ));
    for (let e = 0; e < this.mediaQueries.length; e++) {
      const i = this.mediaQueries[e],
        n = String.prototype.split.call(i, ","),
        r = window.matchMedia(n[0]),
        s = n[1],
        a = Array.prototype.filter.call(this.оbjects, function (t) {
          return t.breakpoint === s;
        });
      r.addListener(function () {
        t.mediaHandler(r, a);
      }),
        this.mediaHandler(r, a);
    }
  }),
    (t.prototype.mediaHandler = function (t, e) {
      if (t.matches)
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          (i.index = this.indexInParent(i.parent, i.element)),
            this.moveTo(i.place, i.element, i.destination);
        }
      else
        for (let t = e.length - 1; t >= 0; t--) {
          const i = e[t];
          i.element.classList.contains(this.daClassname) &&
            this.moveBack(i.parent, i.element, i.index);
        }
    }),
    (t.prototype.moveTo = function (t, e, i) {
      e.classList.add(this.daClassname),
        "last" === t || t >= i.children.length
          ? i.insertAdjacentElement("beforeend", e)
          : "first" !== t
          ? i.children[t].insertAdjacentElement("beforebegin", e)
          : i.insertAdjacentElement("afterbegin", e);
    }),
    (t.prototype.moveBack = function (t, e, i) {
      e.classList.remove(this.daClassname),
        void 0 !== t.children[i]
          ? t.children[i].insertAdjacentElement("beforebegin", e)
          : t.insertAdjacentElement("beforeend", e);
    }),
    (t.prototype.indexInParent = function (t, e) {
      const i = Array.prototype.slice.call(t.children);
      return Array.prototype.indexOf.call(i, e);
    }),
    (t.prototype.arraySort = function (t) {
      "min" === this.type
        ? Array.prototype.sort.call(t, function (t, e) {
            return t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                ? -1
                : "last" === t.place || "first" === e.place
                ? 1
                : t.place - e.place
              : t.breakpoint - e.breakpoint;
          })
        : Array.prototype.sort.call(t, function (t, e) {
            return t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                ? 1
                : "last" === t.place || "first" === e.place
                ? -1
                : e.place - t.place
              : e.breakpoint - t.breakpoint;
          });
    });
  var e, i;
  new t("max").init(),
    (e = void 0),
    (i = function (t) {
      const e = "137",
        i = 100,
        n = 300,
        r = 301,
        s = 302,
        a = 303,
        o = 304,
        l = 306,
        h = 307,
        c = 1e3,
        u = 1001,
        d = 1002,
        p = 1003,
        m = 1004,
        f = 1005,
        g = 1006,
        y = 1007,
        x = 1008,
        v = 1009,
        _ = 1012,
        b = 1014,
        M = 1015,
        w = 1016,
        S = 1020,
        T = 1023,
        E = 1026,
        A = 1027,
        R = 33776,
        L = 33777,
        C = 33778,
        P = 33779,
        I = 35840,
        z = 35841,
        D = 35842,
        N = 35843,
        O = 37492,
        B = 37496,
        F = 37808,
        H = 37809,
        U = 37810,
        k = 37811,
        G = 37812,
        V = 37813,
        W = 37814,
        j = 37815,
        q = 37816,
        X = 37817,
        Y = 37818,
        J = 37819,
        Z = 37820,
        K = 37821,
        Q = 36492,
        $ = 2300,
        tt = 2301,
        et = 2302,
        it = 2400,
        nt = 2401,
        rt = 2402,
        st = 2501,
        at = 3e3,
        ot = 3001,
        lt = 7680,
        ht = 35044,
        ct = 35048,
        ut = "300 es",
        dt = 1035;
      class pt {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {});
          const i = this._listeners;
          void 0 === i[t] && (i[t] = []),
            -1 === i[t].indexOf(e) && i[t].push(e);
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1;
          const i = this._listeners;
          return void 0 !== i[t] && -1 !== i[t].indexOf(e);
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return;
          const i = this._listeners[t];
          if (void 0 !== i) {
            const t = i.indexOf(e);
            -1 !== t && i.splice(t, 1);
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return;
          const e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            const i = e.slice(0);
            for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
            t.target = null;
          }
        }
      }
      const mt = [];
      for (let t = 0; t < 256; t++)
        mt[t] = (t < 16 ? "0" : "") + t.toString(16);
      let ft = 1234567;
      const gt = Math.PI / 180,
        yt = 180 / Math.PI;
      function xt() {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0;
        return (
          mt[255 & t] +
          mt[(t >> 8) & 255] +
          mt[(t >> 16) & 255] +
          mt[(t >> 24) & 255] +
          "-" +
          mt[255 & e] +
          mt[(e >> 8) & 255] +
          "-" +
          mt[((e >> 16) & 15) | 64] +
          mt[(e >> 24) & 255] +
          "-" +
          mt[(63 & i) | 128] +
          mt[(i >> 8) & 255] +
          "-" +
          mt[(i >> 16) & 255] +
          mt[(i >> 24) & 255] +
          mt[255 & n] +
          mt[(n >> 8) & 255] +
          mt[(n >> 16) & 255] +
          mt[(n >> 24) & 255]
        ).toUpperCase();
      }
      function vt(t, e, i) {
        return Math.max(e, Math.min(i, t));
      }
      function _t(t, e) {
        return ((t % e) + e) % e;
      }
      function bt(t, e, i) {
        return (1 - i) * t + i * e;
      }
      function Mt(t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      }
      function wt(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      }
      function St(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
      var Tt = Object.freeze({
        __proto__: null,
        DEG2RAD: gt,
        RAD2DEG: yt,
        generateUUID: xt,
        clamp: vt,
        euclideanModulo: _t,
        mapLinear: function (t, e, i, n, r) {
          return n + ((t - e) * (r - n)) / (i - e);
        },
        inverseLerp: function (t, e, i) {
          return t !== e ? (i - t) / (e - t) : 0;
        },
        lerp: bt,
        damp: function (t, e, i, n) {
          return bt(t, e, 1 - Math.exp(-i * n));
        },
        pingpong: function (t, e = 1) {
          return e - Math.abs(_t(t, 2 * e) - e);
        },
        smoothstep: function (t, e, i) {
          return t <= e
            ? 0
            : t >= i
            ? 1
            : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
        },
        smootherstep: function (t, e, i) {
          return t <= e
            ? 0
            : t >= i
            ? 1
            : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t);
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random());
        },
        seededRandom: function (t) {
          return (
            void 0 !== t && (ft = t % 2147483647),
            (ft = (16807 * ft) % 2147483647),
            (ft - 1) / 2147483646
          );
        },
        degToRad: function (t) {
          return t * gt;
        },
        radToDeg: function (t) {
          return t * yt;
        },
        isPowerOfTwo: Mt,
        ceilPowerOfTwo: wt,
        floorPowerOfTwo: St,
        setQuaternionFromProperEuler: function (t, e, i, n, r) {
          const s = Math.cos,
            a = Math.sin,
            o = s(i / 2),
            l = a(i / 2),
            h = s((e + n) / 2),
            c = a((e + n) / 2),
            u = s((e - n) / 2),
            d = a((e - n) / 2),
            p = s((n - e) / 2),
            m = a((n - e) / 2);
          switch (r) {
            case "XYX":
              t.set(o * c, l * u, l * d, o * h);
              break;
            case "YZY":
              t.set(l * d, o * c, l * u, o * h);
              break;
            case "ZXZ":
              t.set(l * u, l * d, o * c, o * h);
              break;
            case "XZX":
              t.set(o * c, l * m, l * p, o * h);
              break;
            case "YXY":
              t.set(l * p, o * c, l * m, o * h);
              break;
            case "ZYZ":
              t.set(l * m, l * p, o * c, o * h);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
      });
      class Et {
        constructor(t = 0, e = 0) {
          (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x,
            i = this.y,
            n = t.elements;
          return (
            (this.x = n[0] * e + n[3] * i + n[6]),
            (this.y = n[1] * e + n[4] * i + n[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(t, Math.min(e, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            i = this.y - t.y;
          return e * e + i * i;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e, i) {
          return (
            void 0 !== i &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        }
        rotateAround(t, e) {
          const i = Math.cos(e),
            n = Math.sin(e),
            r = this.x - t.x,
            s = this.y - t.y;
          return (
            (this.x = r * i - s * n + t.x), (this.y = r * n + s * i + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      Et.prototype.isVector2 = !0;
      class At {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, i, n, r, s, a, o, l) {
          const h = this.elements;
          return (
            (h[0] = t),
            (h[1] = n),
            (h[2] = a),
            (h[3] = e),
            (h[4] = r),
            (h[5] = o),
            (h[6] = i),
            (h[7] = s),
            (h[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements,
            i = t.elements;
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            this
          );
        }
        extractBasis(t, e, i) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements,
            n = e.elements,
            r = this.elements,
            s = i[0],
            a = i[3],
            o = i[6],
            l = i[1],
            h = i[4],
            c = i[7],
            u = i[2],
            d = i[5],
            p = i[8],
            m = n[0],
            f = n[3],
            g = n[6],
            y = n[1],
            x = n[4],
            v = n[7],
            _ = n[2],
            b = n[5],
            M = n[8];
          return (
            (r[0] = s * m + a * y + o * _),
            (r[3] = s * f + a * x + o * b),
            (r[6] = s * g + a * v + o * M),
            (r[1] = l * m + h * y + c * _),
            (r[4] = l * f + h * x + c * b),
            (r[7] = l * g + h * v + c * M),
            (r[2] = u * m + d * y + p * _),
            (r[5] = u * f + d * x + p * b),
            (r[8] = u * g + d * v + p * M),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            r = t[3],
            s = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            h = t[8];
          return (
            e * s * h -
            e * a * l -
            i * r * h +
            i * a * o +
            n * r * l -
            n * s * o
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            r = t[3],
            s = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            h = t[8],
            c = h * s - a * l,
            u = a * o - h * r,
            d = l * r - s * o,
            p = e * c + i * u + n * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m = 1 / p;
          return (
            (t[0] = c * m),
            (t[1] = (n * l - h * i) * m),
            (t[2] = (a * i - n * s) * m),
            (t[3] = u * m),
            (t[4] = (h * e - n * o) * m),
            (t[5] = (n * r - a * e) * m),
            (t[6] = d * m),
            (t[7] = (i * o - l * e) * m),
            (t[8] = (s * e - i * r) * m),
            this
          );
        }
        transpose() {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, i, n, r, s, a) {
          const o = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              i * o,
              i * l,
              -i * (o * s + l * a) + s + t,
              -n * l,
              n * o,
              -n * (-l * s + o * a) + a + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          const i = this.elements;
          return (
            (i[0] *= t),
            (i[3] *= t),
            (i[6] *= t),
            (i[1] *= e),
            (i[4] *= e),
            (i[7] *= e),
            this
          );
        }
        rotate(t) {
          const e = Math.cos(t),
            i = Math.sin(t),
            n = this.elements,
            r = n[0],
            s = n[3],
            a = n[6],
            o = n[1],
            l = n[4],
            h = n[7];
          return (
            (n[0] = e * r + i * o),
            (n[3] = e * s + i * l),
            (n[6] = e * a + i * h),
            (n[1] = -i * r + e * o),
            (n[4] = -i * s + e * l),
            (n[7] = -i * a + e * h),
            this
          );
        }
        translate(t, e) {
          const i = this.elements;
          return (
            (i[0] += t * i[2]),
            (i[3] += t * i[5]),
            (i[6] += t * i[8]),
            (i[1] += e * i[2]),
            (i[4] += e * i[5]),
            (i[7] += e * i[8]),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            i = t.elements;
          for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function Rt(t) {
        for (let e = t.length - 1; e >= 0; --e) if (t[e] > 65535) return !0;
        return !1;
      }
      At.prototype.isMatrix3 = !0;
      const Lt = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function Ct(t, e) {
        return new Lt[t](e);
      }
      function Pt(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t);
      }
      const It = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        zt = { h: 0, s: 0, l: 0 },
        Dt = { h: 0, s: 0, l: 0 };
      function Nt(t, e, i) {
        return (
          i < 0 && (i += 1),
          i > 1 && (i -= 1),
          i < 1 / 6
            ? t + 6 * (e - t) * i
            : i < 0.5
            ? e
            : i < 2 / 3
            ? t + 6 * (e - t) * (2 / 3 - i)
            : t
        );
      }
      function Ot(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
      }
      function Bt(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
      }
      class Ft {
        constructor(t, e, i) {
          return void 0 === e && void 0 === i
            ? this.set(t)
            : this.setRGB(t, e, i);
        }
        set(t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : "number" == typeof t
              ? this.setHex(t)
              : "string" == typeof t && this.setStyle(t),
            this
          );
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          );
        }
        setRGB(t, e, i) {
          return (this.r = t), (this.g = e), (this.b = i), this;
        }
        setHSL(t, e, i) {
          if (((t = _t(t, 1)), (e = vt(e, 0, 1)), (i = vt(i, 0, 1)), 0 === e))
            this.r = this.g = this.b = i;
          else {
            const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
              r = 2 * i - n;
            (this.r = Nt(r, n, t + 1 / 3)),
              (this.g = Nt(r, n, t)),
              (this.b = Nt(r, n, t - 1 / 3));
          }
          return this;
        }
        setStyle(t) {
          function e(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          let i;
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
            let t;
            const n = i[1],
              r = i[2];
            switch (n) {
              case "rgb":
              case "rgba":
                if (
                  (t =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                    e(t[4]),
                    this
                  );
                if (
                  (t =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                    e(t[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (t =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                ) {
                  const i = parseFloat(t[1]) / 360,
                    n = parseInt(t[2], 10) / 100,
                    r = parseInt(t[3], 10) / 100;
                  return e(t[4]), this.setHSL(i, n, r);
                }
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const t = i[1],
              e = t.length;
            if (3 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                this
              );
            if (6 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                this
              );
          }
          return t && t.length > 0 ? this.setColorName(t) : this;
        }
        setColorName(t) {
          const e = It[t.toLowerCase()];
          return (
            void 0 !== e
              ? this.setHex(e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = Ot(t.r)), (this.g = Ot(t.g)), (this.b = Ot(t.b)), this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = Bt(t.r)), (this.g = Bt(t.g)), (this.b = Bt(t.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t) {
          const e = this.r,
            i = this.g,
            n = this.b,
            r = Math.max(e, i, n),
            s = Math.min(e, i, n);
          let a, o;
          const l = (s + r) / 2;
          if (s === r) (a = 0), (o = 0);
          else {
            const t = r - s;
            switch (((o = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
              case e:
                a = (i - n) / t + (i < n ? 6 : 0);
                break;
              case i:
                a = (n - e) / t + 2;
                break;
              case n:
                a = (e - i) / t + 4;
            }
            a /= 6;
          }
          return (t.h = a), (t.s = o), (t.l = l), t;
        }
        getStyle() {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        }
        offsetHSL(t, e, i) {
          return (
            this.getHSL(zt),
            (zt.h += t),
            (zt.s += e),
            (zt.l += i),
            this.setHSL(zt.h, zt.s, zt.l),
            this
          );
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, i) {
          return (
            (this.r = t.r + (e.r - t.r) * i),
            (this.g = t.g + (e.g - t.g) * i),
            (this.b = t.b + (e.b - t.b) * i),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(zt), t.getHSL(Dt);
          const i = bt(zt.h, Dt.h, e),
            n = bt(zt.s, Dt.s, e),
            r = bt(zt.l, Dt.l, e);
          return this.setHSL(i, n, r), this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            !0 === t.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      let Ht;
      (Ft.NAMES = It),
        (Ft.prototype.isColor = !0),
        (Ft.prototype.r = 1),
        (Ft.prototype.g = 1),
        (Ft.prototype.b = 1);
      class Ut {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          let e;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === Ht && (Ht = Pt("canvas")),
              (Ht.width = t.width),
              (Ht.height = t.height);
            const i = Ht.getContext("2d");
            t instanceof ImageData
              ? i.putImageData(t, 0, 0)
              : i.drawImage(t, 0, 0, t.width, t.height),
              (e = Ht);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const e = Pt("canvas");
            (e.width = t.width), (e.height = t.height);
            const i = e.getContext("2d");
            i.drawImage(t, 0, 0, t.width, t.height);
            const n = i.getImageData(0, 0, t.width, t.height),
              r = n.data;
            for (let t = 0; t < r.length; t++) r[t] = 255 * Ot(r[t] / 255);
            return i.putImageData(n, 0, 0), e;
          }
          if (t.data) {
            const e = t.data.slice(0);
            for (let t = 0; t < e.length; t++)
              e instanceof Uint8Array || e instanceof Uint8ClampedArray
                ? (e[t] = Math.floor(255 * Ot(e[t] / 255)))
                : (e[t] = Ot(e[t]));
            return { data: e, width: t.width, height: t.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            t
          );
        }
      }
      let kt = 0;
      class Gt extends pt {
        constructor(
          t = Gt.DEFAULT_IMAGE,
          e = Gt.DEFAULT_MAPPING,
          i = 1001,
          n = 1001,
          r = 1006,
          s = 1008,
          a = 1023,
          o = 1009,
          l = 1,
          h = 3e3
        ) {
          super(),
            Object.defineProperty(this, "id", { value: kt++ }),
            (this.uuid = xt()),
            (this.name = ""),
            (this.image = t),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.wrapS = i),
            (this.wrapT = n),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = l),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new Et(0, 0)),
            (this.repeat = new Et(1, 1)),
            (this.center = new Et(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new At()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = h),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            const n = this.image;
            if (
              (void 0 === n.uuid && (n.uuid = xt()),
              !e && void 0 === t.images[n.uuid])
            ) {
              let e;
              if (Array.isArray(n)) {
                e = [];
                for (let t = 0, i = n.length; t < i; t++)
                  n[t].isDataTexture
                    ? e.push(Vt(n[t].image))
                    : e.push(Vt(n[t]));
              } else e = Vt(n);
              t.images[n.uuid] = { uuid: n.uuid, url: e };
            }
            i.image = n.uuid;
          }
          return (
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            e || (t.textures[this.uuid] = i),
            i
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t) {
          if (this.mapping !== n) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case c:
                t.x = t.x - Math.floor(t.x);
                break;
              case u:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case c:
                t.y = t.y - Math.floor(t.y);
                break;
              case u:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      function Vt(t) {
        return ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ? Ut.getDataURL(t)
          : t.data
          ? {
              data: Array.prototype.slice.call(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      (Gt.DEFAULT_IMAGE = void 0),
        (Gt.DEFAULT_MAPPING = n),
        (Gt.prototype.isTexture = !0);
      class Wt {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          (this.x = t), (this.y = e), (this.z = i), (this.w = n);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, i, n) {
          return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            r = this.w,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r),
            (this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r),
            (this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r),
            (this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, i, n, r;
          const s = 0.01,
            a = 0.1,
            o = t.elements,
            l = o[0],
            h = o[4],
            c = o[8],
            u = o[1],
            d = o[5],
            p = o[9],
            m = o[2],
            f = o[6],
            g = o[10];
          if (
            Math.abs(h - u) < s &&
            Math.abs(c - m) < s &&
            Math.abs(p - f) < s
          ) {
            if (
              Math.abs(h + u) < a &&
              Math.abs(c + m) < a &&
              Math.abs(p + f) < a &&
              Math.abs(l + d + g - 3) < a
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (l + 1) / 2,
              o = (d + 1) / 2,
              y = (g + 1) / 2,
              x = (h + u) / 4,
              v = (c + m) / 4,
              _ = (p + f) / 4;
            return (
              t > o && t > y
                ? t < s
                  ? ((i = 0), (n = 0.707106781), (r = 0.707106781))
                  : ((i = Math.sqrt(t)), (n = x / i), (r = v / i))
                : o > y
                ? o < s
                  ? ((i = 0.707106781), (n = 0), (r = 0.707106781))
                  : ((n = Math.sqrt(o)), (i = x / n), (r = _ / n))
                : y < s
                ? ((i = 0.707106781), (n = 0.707106781), (r = 0))
                : ((r = Math.sqrt(y)), (i = v / r), (n = _ / r)),
              this.set(i, n, r, e),
              this
            );
          }
          let y = Math.sqrt(
            (f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h)
          );
          return (
            Math.abs(y) < 0.001 && (y = 1),
            (this.x = (f - p) / y),
            (this.y = (c - m) / y),
            (this.z = (u - h) / y),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(t, Math.min(e, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            (this.z = t.z + (e.z - t.z) * i),
            (this.w = t.w + (e.w - t.w) * i),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e, i) {
          return (
            void 0 !== i &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      Wt.prototype.isVector4 = !0;
      class jt extends pt {
        constructor(t, e, i = {}) {
          super(),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new Wt(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new Wt(0, 0, t, e)),
            (this.texture = new Gt(
              void 0,
              i.mapping,
              i.wrapS,
              i.wrapT,
              i.magFilter,
              i.minFilter,
              i.format,
              i.type,
              i.anisotropy,
              i.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: t, height: e, depth: 1 }),
            (this.texture.generateMipmaps =
              void 0 !== i.generateMipmaps && i.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== i.internalFormat ? i.internalFormat : null),
            (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : g),
            (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
            (this.stencilBuffer =
              void 0 !== i.stencilBuffer && i.stencilBuffer),
            (this.depthTexture =
              void 0 !== i.depthTexture ? i.depthTexture : null);
        }
        setTexture(t) {
          (t.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = t);
        }
        setSize(t, e, i = 1) {
          (this.width === t && this.height === e && this.depth === i) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = i),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = i),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.image = Object.assign({}, t.texture.image)),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      jt.prototype.isWebGLRenderTarget = !0;
      class qt extends jt {
        constructor(t, e, i) {
          super(t, e);
          const n = this.texture;
          this.texture = [];
          for (let t = 0; t < i; t++) this.texture[t] = n.clone();
        }
        setSize(t, e, i = 1) {
          if (this.width !== t || this.height !== e || this.depth !== i) {
            (this.width = t), (this.height = e), (this.depth = i);
            for (let n = 0, r = this.texture.length; n < r; n++)
              (this.texture[n].image.width = t),
                (this.texture[n].image.height = e),
                (this.texture[n].image.depth = i);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
          );
        }
        copy(t) {
          this.dispose(),
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            (this.texture.length = 0);
          for (let e = 0, i = t.texture.length; e < i; e++)
            this.texture[e] = t.texture[e].clone();
          return this;
        }
      }
      qt.prototype.isWebGLMultipleRenderTargets = !0;
      class Xt extends jt {
        constructor(t, e, i = {}) {
          super(t, e, i),
            (this.samples = 4),
            (this.ignoreDepthForMultisampleCopy =
              void 0 === i.ignoreDepth || i.ignoreDepth),
            (this.useRenderToTexture =
              void 0 !== i.useRenderToTexture && i.useRenderToTexture),
            (this.useRenderbuffer = !1 === this.useRenderToTexture);
        }
        copy(t) {
          return (
            super.copy.call(this, t),
            (this.samples = t.samples),
            (this.useRenderToTexture = t.useRenderToTexture),
            (this.useRenderbuffer = t.useRenderbuffer),
            this
          );
        }
      }
      Xt.prototype.isWebGLMultisampleRenderTarget = !0;
      class Yt {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          (this._x = t), (this._y = e), (this._z = i), (this._w = n);
        }
        static slerp(t, e, i, n) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            i.slerpQuaternions(t, e, n)
          );
        }
        static slerpFlat(t, e, i, n, r, s, a) {
          let o = i[n + 0],
            l = i[n + 1],
            h = i[n + 2],
            c = i[n + 3];
          const u = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            m = r[s + 3];
          if (0 === a)
            return (
              (t[e + 0] = o),
              (t[e + 1] = l),
              (t[e + 2] = h),
              void (t[e + 3] = c)
            );
          if (1 === a)
            return (
              (t[e + 0] = u),
              (t[e + 1] = d),
              (t[e + 2] = p),
              void (t[e + 3] = m)
            );
          if (c !== m || o !== u || l !== d || h !== p) {
            let t = 1 - a;
            const e = o * u + l * d + h * p + c * m,
              i = e >= 0 ? 1 : -1,
              n = 1 - e * e;
            if (n > Number.EPSILON) {
              const r = Math.sqrt(n),
                s = Math.atan2(r, e * i);
              (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
            }
            const r = a * i;
            if (
              ((o = o * t + u * r),
              (l = l * t + d * r),
              (h = h * t + p * r),
              (c = c * t + m * r),
              t === 1 - a)
            ) {
              const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
              (o *= t), (l *= t), (h *= t), (c *= t);
            }
          }
          (t[e] = o), (t[e + 1] = l), (t[e + 2] = h), (t[e + 3] = c);
        }
        static multiplyQuaternionsFlat(t, e, i, n, r, s) {
          const a = i[n],
            o = i[n + 1],
            l = i[n + 2],
            h = i[n + 3],
            c = r[s],
            u = r[s + 1],
            d = r[s + 2],
            p = r[s + 3];
          return (
            (t[e] = a * p + h * c + o * d - l * u),
            (t[e + 1] = o * p + h * u + l * c - a * d),
            (t[e + 2] = l * p + h * d + a * u - o * c),
            (t[e + 3] = h * p - a * c - o * u - l * d),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, i, n) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._w = n),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const i = t._x,
            n = t._y,
            r = t._z,
            s = t._order,
            a = Math.cos,
            o = Math.sin,
            l = a(i / 2),
            h = a(n / 2),
            c = a(r / 2),
            u = o(i / 2),
            d = o(n / 2),
            p = o(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = u * h * c + l * d * p),
                (this._y = l * d * c - u * h * p),
                (this._z = l * h * p + u * d * c),
                (this._w = l * h * c - u * d * p);
              break;
            case "YXZ":
              (this._x = u * h * c + l * d * p),
                (this._y = l * d * c - u * h * p),
                (this._z = l * h * p - u * d * c),
                (this._w = l * h * c + u * d * p);
              break;
            case "ZXY":
              (this._x = u * h * c - l * d * p),
                (this._y = l * d * c + u * h * p),
                (this._z = l * h * p + u * d * c),
                (this._w = l * h * c - u * d * p);
              break;
            case "ZYX":
              (this._x = u * h * c - l * d * p),
                (this._y = l * d * c + u * h * p),
                (this._z = l * h * p - u * d * c),
                (this._w = l * h * c + u * d * p);
              break;
            case "YZX":
              (this._x = u * h * c + l * d * p),
                (this._y = l * d * c + u * h * p),
                (this._z = l * h * p - u * d * c),
                (this._w = l * h * c - u * d * p);
              break;
            case "XZY":
              (this._x = u * h * c - l * d * p),
                (this._y = l * d * c - u * h * p),
                (this._z = l * h * p + u * d * c),
                (this._w = l * h * c + u * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return !1 !== e && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const i = e / 2,
            n = Math.sin(i);
          return (
            (this._x = t.x * n),
            (this._y = t.y * n),
            (this._z = t.z * n),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            i = e[0],
            n = e[4],
            r = e[8],
            s = e[1],
            a = e[5],
            o = e[9],
            l = e[2],
            h = e[6],
            c = e[10],
            u = i + a + c;
          if (u > 0) {
            const t = 0.5 / Math.sqrt(u + 1);
            (this._w = 0.25 / t),
              (this._x = (h - o) * t),
              (this._y = (r - l) * t),
              (this._z = (s - n) * t);
          } else if (i > a && i > c) {
            const t = 2 * Math.sqrt(1 + i - a - c);
            (this._w = (h - o) / t),
              (this._x = 0.25 * t),
              (this._y = (n + s) / t),
              (this._z = (r + l) / t);
          } else if (a > c) {
            const t = 2 * Math.sqrt(1 + a - i - c);
            (this._w = (r - l) / t),
              (this._x = (n + s) / t),
              (this._y = 0.25 * t),
              (this._z = (o + h) / t);
          } else {
            const t = 2 * Math.sqrt(1 + c - i - a);
            (this._w = (s - n) / t),
              (this._x = (r + l) / t),
              (this._y = (o + h) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let i = t.dot(e) + 1;
          return (
            i < Number.EPSILON
              ? ((i = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = i))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = i)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = i)),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(vt(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const i = this.angleTo(t);
          if (0 === i) return this;
          const n = Math.min(1, e / i);
          return this.slerp(t, n), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const i = t._x,
            n = t._y,
            r = t._z,
            s = t._w,
            a = e._x,
            o = e._y,
            l = e._z,
            h = e._w;
          return (
            (this._x = i * h + s * a + n * l - r * o),
            (this._y = n * h + s * o + r * a - i * l),
            (this._z = r * h + s * l + i * o - n * a),
            (this._w = s * h - i * a - n * o - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          const i = this._x,
            n = this._y,
            r = this._z,
            s = this._w;
          let a = s * t._w + i * t._x + n * t._y + r * t._z;
          if (
            (a < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (a = -a))
              : this.copy(t),
            a >= 1)
          )
            return (
              (this._w = s), (this._x = i), (this._y = n), (this._z = r), this
            );
          const o = 1 - a * a;
          if (o <= Number.EPSILON) {
            const t = 1 - e;
            return (
              (this._w = t * s + e * this._w),
              (this._x = t * i + e * this._x),
              (this._y = t * n + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const l = Math.sqrt(o),
            h = Math.atan2(l, a),
            c = Math.sin((1 - e) * h) / l,
            u = Math.sin(e * h) / l;
          return (
            (this._w = s * c + this._w * u),
            (this._x = i * c + this._x * u),
            (this._y = n * c + this._y * u),
            (this._z = r * c + this._z * u),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, i) {
          return this.copy(t).slerp(e, i);
        }
        random() {
          const t = Math.random(),
            e = Math.sqrt(1 - t),
            i = Math.sqrt(t),
            n = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            e * Math.cos(n),
            i * Math.sin(r),
            i * Math.cos(r),
            e * Math.sin(n)
          );
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      Yt.prototype.isQuaternion = !0;
      class Jt {
        constructor(t = 0, e = 0, i = 0) {
          (this.x = t), (this.y = e), (this.z = i);
        }
        set(t, e, i) {
          return (
            void 0 === i && (i = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = i),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(t, e))
            : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return (
            (t && t.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Kt.setFromEuler(t))
          );
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Kt.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * i + r[6] * n),
            (this.y = r[1] * e + r[4] * i + r[7] * n),
            (this.z = r[2] * e + r[5] * i + r[8] * n),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            r = t.elements,
            s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
          return (
            (this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s),
            (this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s),
            (this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s),
            this
          );
        }
        applyQuaternion(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            r = t.x,
            s = t.y,
            a = t.z,
            o = t.w,
            l = o * e + s * n - a * i,
            h = o * i + a * e - r * n,
            c = o * n + r * i - s * e,
            u = -r * e - s * i - a * n;
          return (
            (this.x = l * o + u * -r + h * -a - c * -s),
            (this.y = h * o + u * -s + c * -r - l * -a),
            (this.z = c * o + u * -a + l * -s - h * -r),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[4] * i + r[8] * n),
            (this.y = r[1] * e + r[5] * i + r[9] * n),
            (this.z = r[2] * e + r[6] * i + r[10] * n),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          );
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(t, Math.min(e, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            (this.z = t.z + (e.z - t.z) * i),
            this
          );
        }
        cross(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(t, e))
            : this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const i = t.x,
            n = t.y,
            r = t.z,
            s = e.x,
            a = e.y,
            o = e.z;
          return (
            (this.x = n * o - r * a),
            (this.y = r * s - i * o),
            (this.z = i * a - n * s),
            this
          );
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (0 === e) return this.set(0, 0, 0);
          const i = t.dot(this) / e;
          return this.copy(t).multiplyScalar(i);
        }
        projectOnPlane(t) {
          return Zt.copy(this).projectOnVector(t), this.sub(Zt);
        }
        reflect(t) {
          return this.sub(Zt.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          const i = this.dot(t) / e;
          return Math.acos(vt(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            i = this.y - t.y,
            n = this.z - t.z;
          return e * e + i * i + n * n;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, i) {
          const n = Math.sin(e) * t;
          return (
            (this.x = n * Math.sin(i)),
            (this.y = Math.cos(e) * t),
            (this.z = n * Math.cos(i)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, i) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = i),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            i = this.setFromMatrixColumn(t, 1).length(),
            n = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = i), (this.z = n), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e);
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e, i) {
          return (
            void 0 !== i &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const t = 2 * (Math.random() - 0.5),
            e = Math.random() * Math.PI * 2,
            i = Math.sqrt(1 - t ** 2);
          return (
            (this.x = i * Math.cos(e)),
            (this.y = i * Math.sin(e)),
            (this.z = t),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      Jt.prototype.isVector3 = !0;
      const Zt = new Jt(),
        Kt = new Yt();
      class Qt {
        constructor(
          t = new Jt(1 / 0, 1 / 0, 1 / 0),
          e = new Jt(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let o = 0, l = t.length; o < l; o += 3) {
            const l = t[o],
              h = t[o + 1],
              c = t[o + 2];
            l < e && (e = l),
              h < i && (i = h),
              c < n && (n = c),
              l > r && (r = l),
              h > s && (s = h),
              c > a && (a = c);
          }
          return this.min.set(e, i, n), this.max.set(r, s, a), this;
        }
        setFromBufferAttribute(t) {
          let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let o = 0, l = t.count; o < l; o++) {
            const l = t.getX(o),
              h = t.getY(o),
              c = t.getZ(o);
            l < e && (e = l),
              h < i && (i = h),
              c < n && (n = c),
              l > r && (r = l),
              h > s && (s = h),
              c > a && (a = c);
          }
          return this.min.set(e, i, n), this.max.set(r, s, a), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const i = te.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        setFromObject(t, e = !1) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
          t.updateWorldMatrix(!1, !1);
          const i = t.geometry;
          if (void 0 !== i)
            if (e && null != i.attributes && void 0 !== i.attributes.position) {
              const e = i.attributes.position;
              for (let i = 0, n = e.count; i < n; i++)
                te.fromBufferAttribute(e, i).applyMatrix4(t.matrixWorld),
                  this.expandByPoint(te);
            } else
              null === i.boundingBox && i.computeBoundingBox(),
                ee.copy(i.boundingBox),
                ee.applyMatrix4(t.matrixWorld),
                this.union(ee);
          const n = t.children;
          for (let t = 0, i = n.length; t < i; t++)
            this.expandByObject(n[t], e);
          return this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, te),
            te.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, i;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (i += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (i += t.normal.z * this.min.z)),
            e <= -t.constant && i >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(le),
            he.subVectors(this.max, le),
            ie.subVectors(t.a, le),
            ne.subVectors(t.b, le),
            re.subVectors(t.c, le),
            se.subVectors(ne, ie),
            ae.subVectors(re, ne),
            oe.subVectors(ie, re);
          let e = [
            0,
            -se.z,
            se.y,
            0,
            -ae.z,
            ae.y,
            0,
            -oe.z,
            oe.y,
            se.z,
            0,
            -se.x,
            ae.z,
            0,
            -ae.x,
            oe.z,
            0,
            -oe.x,
            -se.y,
            se.x,
            0,
            -ae.y,
            ae.x,
            0,
            -oe.y,
            oe.x,
            0,
          ];
          return (
            !!de(e, ie, ne, re, he) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!de(e, ie, ne, re, he) &&
              (ce.crossVectors(se, ae),
              (e = [ce.x, ce.y, ce.z]),
              de(e, ie, ne, re, he)))
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return te.copy(t).clamp(this.min, this.max).sub(t).length();
        }
        getBoundingSphere(t) {
          return (
            this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(te).length()),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              ($t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              $t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              $t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              $t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              $t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              $t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              $t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              $t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints($t)),
            this
          );
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      Qt.prototype.isBox3 = !0;
      const $t = [
          new Jt(),
          new Jt(),
          new Jt(),
          new Jt(),
          new Jt(),
          new Jt(),
          new Jt(),
          new Jt(),
        ],
        te = new Jt(),
        ee = new Qt(),
        ie = new Jt(),
        ne = new Jt(),
        re = new Jt(),
        se = new Jt(),
        ae = new Jt(),
        oe = new Jt(),
        le = new Jt(),
        he = new Jt(),
        ce = new Jt(),
        ue = new Jt();
      function de(t, e, i, n, r) {
        for (let s = 0, a = t.length - 3; s <= a; s += 3) {
          ue.fromArray(t, s);
          const a =
              r.x * Math.abs(ue.x) +
              r.y * Math.abs(ue.y) +
              r.z * Math.abs(ue.z),
            o = e.dot(ue),
            l = i.dot(ue),
            h = n.dot(ue);
          if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1;
        }
        return !0;
      }
      const pe = new Qt(),
        me = new Jt(),
        fe = new Jt(),
        ge = new Jt();
      class ye {
        constructor(t = new Jt(), e = -1) {
          (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          const i = this.center;
          void 0 !== e ? i.copy(e) : pe.setFromPoints(t).getCenter(i);
          let n = 0;
          for (let e = 0, r = t.length; e < r; e++)
            n = Math.max(n, i.distanceToSquared(t[e]));
          return (this.radius = Math.sqrt(n)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const i = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            i > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t);
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          ge.subVectors(t, this.center);
          const e = ge.lengthSq();
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              i = 0.5 * (t - this.radius);
            this.center.add(ge.multiplyScalar(i / t)), (this.radius += i);
          }
          return this;
        }
        union(t) {
          return (
            !0 === this.center.equals(t.center)
              ? fe.set(0, 0, 1).multiplyScalar(t.radius)
              : fe
                  .subVectors(t.center, this.center)
                  .normalize()
                  .multiplyScalar(t.radius),
            this.expandByPoint(me.copy(t.center).add(fe)),
            this.expandByPoint(me.copy(t.center).sub(fe)),
            this
          );
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const xe = new Jt(),
        ve = new Jt(),
        _e = new Jt(),
        be = new Jt(),
        Me = new Jt(),
        we = new Jt(),
        Se = new Jt();
      class Te {
        constructor(t = new Jt(), e = new Jt(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, xe)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const i = e.dot(this.direction);
          return i < 0
            ? e.copy(this.origin)
            : e.copy(this.direction).multiplyScalar(i).add(this.origin);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = xe.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (xe.copy(this.direction).multiplyScalar(e).add(this.origin),
              xe.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, i, n) {
          ve.copy(t).add(e).multiplyScalar(0.5),
            _e.copy(e).sub(t).normalize(),
            be.copy(this.origin).sub(ve);
          const r = 0.5 * t.distanceTo(e),
            s = -this.direction.dot(_e),
            a = be.dot(this.direction),
            o = -be.dot(_e),
            l = be.lengthSq(),
            h = Math.abs(1 - s * s);
          let c, u, d, p;
          if (h > 0)
            if (((c = s * o - a), (u = s * a - o), (p = r * h), c >= 0))
              if (u >= -p)
                if (u <= p) {
                  const t = 1 / h;
                  (c *= t),
                    (u *= t),
                    (d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l);
                } else
                  (u = r),
                    (c = Math.max(0, -(s * u + a))),
                    (d = -c * c + u * (u + 2 * o) + l);
              else
                (u = -r),
                  (c = Math.max(0, -(s * u + a))),
                  (d = -c * c + u * (u + 2 * o) + l);
            else
              u <= -p
                ? ((c = Math.max(0, -(-s * r + a))),
                  (u = c > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                  (d = -c * c + u * (u + 2 * o) + l))
                : u <= p
                ? ((c = 0),
                  (u = Math.min(Math.max(-r, -o), r)),
                  (d = u * (u + 2 * o) + l))
                : ((c = Math.max(0, -(s * r + a))),
                  (u = c > 0 ? r : Math.min(Math.max(-r, -o), r)),
                  (d = -c * c + u * (u + 2 * o) + l));
          else
            (u = s > 0 ? -r : r),
              (c = Math.max(0, -(s * u + a))),
              (d = -c * c + u * (u + 2 * o) + l);
          return (
            i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
            n && n.copy(_e).multiplyScalar(u).add(ve),
            d
          );
        }
        intersectSphere(t, e) {
          xe.subVectors(t.center, this.origin);
          const i = xe.dot(this.direction),
            n = xe.dot(xe) - i * i,
            r = t.radius * t.radius;
          if (n > r) return null;
          const s = Math.sqrt(r - n),
            a = i - s,
            o = i + s;
          return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          const i = -(this.origin.dot(t.normal) + t.constant) / e;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, e) {
          const i = this.distanceToPlane(t);
          return null === i ? null : this.at(i, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return 0 === e || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let i, n, r, s, a, o;
          const l = 1 / this.direction.x,
            h = 1 / this.direction.y,
            c = 1 / this.direction.z,
            u = this.origin;
          return (
            l >= 0
              ? ((i = (t.min.x - u.x) * l), (n = (t.max.x - u.x) * l))
              : ((i = (t.max.x - u.x) * l), (n = (t.min.x - u.x) * l)),
            h >= 0
              ? ((r = (t.min.y - u.y) * h), (s = (t.max.y - u.y) * h))
              : ((r = (t.max.y - u.y) * h), (s = (t.min.y - u.y) * h)),
            i > s || r > n
              ? null
              : ((r > i || i != i) && (i = r),
                (s < n || n != n) && (n = s),
                c >= 0
                  ? ((a = (t.min.z - u.z) * c), (o = (t.max.z - u.z) * c))
                  : ((a = (t.max.z - u.z) * c), (o = (t.min.z - u.z) * c)),
                i > o || a > n
                  ? null
                  : ((a > i || i != i) && (i = a),
                    (o < n || n != n) && (n = o),
                    n < 0 ? null : this.at(i >= 0 ? i : n, e)))
          );
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, xe);
        }
        intersectTriangle(t, e, i, n, r) {
          Me.subVectors(e, t), we.subVectors(i, t), Se.crossVectors(Me, we);
          let s,
            a = this.direction.dot(Se);
          if (a > 0) {
            if (n) return null;
            s = 1;
          } else {
            if (!(a < 0)) return null;
            (s = -1), (a = -a);
          }
          be.subVectors(this.origin, t);
          const o = s * this.direction.dot(we.crossVectors(be, we));
          if (o < 0) return null;
          const l = s * this.direction.dot(Me.cross(be));
          if (l < 0) return null;
          if (o + l > a) return null;
          const h = -s * be.dot(Se);
          return h < 0 ? null : this.at(h / a, r);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ee {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
          const g = this.elements;
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = i),
            (g[12] = n),
            (g[1] = r),
            (g[5] = s),
            (g[9] = a),
            (g[13] = o),
            (g[2] = l),
            (g[6] = h),
            (g[10] = c),
            (g[14] = u),
            (g[3] = d),
            (g[7] = p),
            (g[11] = m),
            (g[15] = f),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Ee().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements,
            i = t.elements;
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            (e[9] = i[9]),
            (e[10] = i[10]),
            (e[11] = i[11]),
            (e[12] = i[12]),
            (e[13] = i[13]),
            (e[14] = i[14]),
            (e[15] = i[15]),
            this
          );
        }
        copyPosition(t) {
          const e = this.elements,
            i = t.elements;
          return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, i) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, i) {
          return (
            this.set(
              t.x,
              e.x,
              i.x,
              0,
              t.y,
              e.y,
              i.y,
              0,
              t.z,
              e.z,
              i.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          const e = this.elements,
            i = t.elements,
            n = 1 / Ae.setFromMatrixColumn(t, 0).length(),
            r = 1 / Ae.setFromMatrixColumn(t, 1).length(),
            s = 1 / Ae.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = i[0] * n),
            (e[1] = i[1] * n),
            (e[2] = i[2] * n),
            (e[3] = 0),
            (e[4] = i[4] * r),
            (e[5] = i[5] * r),
            (e[6] = i[6] * r),
            (e[7] = 0),
            (e[8] = i[8] * s),
            (e[9] = i[9] * s),
            (e[10] = i[10] * s),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          (t && t.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const e = this.elements,
            i = t.x,
            n = t.y,
            r = t.z,
            s = Math.cos(i),
            a = Math.sin(i),
            o = Math.cos(n),
            l = Math.sin(n),
            h = Math.cos(r),
            c = Math.sin(r);
          if ("XYZ" === t.order) {
            const t = s * h,
              i = s * c,
              n = a * h,
              r = a * c;
            (e[0] = o * h),
              (e[4] = -o * c),
              (e[8] = l),
              (e[1] = i + n * l),
              (e[5] = t - r * l),
              (e[9] = -a * o),
              (e[2] = r - t * l),
              (e[6] = n + i * l),
              (e[10] = s * o);
          } else if ("YXZ" === t.order) {
            const t = o * h,
              i = o * c,
              n = l * h,
              r = l * c;
            (e[0] = t + r * a),
              (e[4] = n * a - i),
              (e[8] = s * l),
              (e[1] = s * c),
              (e[5] = s * h),
              (e[9] = -a),
              (e[2] = i * a - n),
              (e[6] = r + t * a),
              (e[10] = s * o);
          } else if ("ZXY" === t.order) {
            const t = o * h,
              i = o * c,
              n = l * h,
              r = l * c;
            (e[0] = t - r * a),
              (e[4] = -s * c),
              (e[8] = n + i * a),
              (e[1] = i + n * a),
              (e[5] = s * h),
              (e[9] = r - t * a),
              (e[2] = -s * l),
              (e[6] = a),
              (e[10] = s * o);
          } else if ("ZYX" === t.order) {
            const t = s * h,
              i = s * c,
              n = a * h,
              r = a * c;
            (e[0] = o * h),
              (e[4] = n * l - i),
              (e[8] = t * l + r),
              (e[1] = o * c),
              (e[5] = r * l + t),
              (e[9] = i * l - n),
              (e[2] = -l),
              (e[6] = a * o),
              (e[10] = s * o);
          } else if ("YZX" === t.order) {
            const t = s * o,
              i = s * l,
              n = a * o,
              r = a * l;
            (e[0] = o * h),
              (e[4] = r - t * c),
              (e[8] = n * c + i),
              (e[1] = c),
              (e[5] = s * h),
              (e[9] = -a * h),
              (e[2] = -l * h),
              (e[6] = i * c + n),
              (e[10] = t - r * c);
          } else if ("XZY" === t.order) {
            const t = s * o,
              i = s * l,
              n = a * o,
              r = a * l;
            (e[0] = o * h),
              (e[4] = -c),
              (e[8] = l * h),
              (e[1] = t * c + r),
              (e[5] = s * h),
              (e[9] = i * c - n),
              (e[2] = n * c - i),
              (e[6] = a * h),
              (e[10] = r * c + t);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(Le, t, Ce);
        }
        lookAt(t, e, i) {
          const n = this.elements;
          return (
            ze.subVectors(t, e),
            0 === ze.lengthSq() && (ze.z = 1),
            ze.normalize(),
            Pe.crossVectors(i, ze),
            0 === Pe.lengthSq() &&
              (1 === Math.abs(i.z) ? (ze.x += 1e-4) : (ze.z += 1e-4),
              ze.normalize(),
              Pe.crossVectors(i, ze)),
            Pe.normalize(),
            Ie.crossVectors(ze, Pe),
            (n[0] = Pe.x),
            (n[4] = Ie.x),
            (n[8] = ze.x),
            (n[1] = Pe.y),
            (n[5] = Ie.y),
            (n[9] = ze.y),
            (n[2] = Pe.z),
            (n[6] = Ie.z),
            (n[10] = ze.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(t, e))
            : this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements,
            n = e.elements,
            r = this.elements,
            s = i[0],
            a = i[4],
            o = i[8],
            l = i[12],
            h = i[1],
            c = i[5],
            u = i[9],
            d = i[13],
            p = i[2],
            m = i[6],
            f = i[10],
            g = i[14],
            y = i[3],
            x = i[7],
            v = i[11],
            _ = i[15],
            b = n[0],
            M = n[4],
            w = n[8],
            S = n[12],
            T = n[1],
            E = n[5],
            A = n[9],
            R = n[13],
            L = n[2],
            C = n[6],
            P = n[10],
            I = n[14],
            z = n[3],
            D = n[7],
            N = n[11],
            O = n[15];
          return (
            (r[0] = s * b + a * T + o * L + l * z),
            (r[4] = s * M + a * E + o * C + l * D),
            (r[8] = s * w + a * A + o * P + l * N),
            (r[12] = s * S + a * R + o * I + l * O),
            (r[1] = h * b + c * T + u * L + d * z),
            (r[5] = h * M + c * E + u * C + d * D),
            (r[9] = h * w + c * A + u * P + d * N),
            (r[13] = h * S + c * R + u * I + d * O),
            (r[2] = p * b + m * T + f * L + g * z),
            (r[6] = p * M + m * E + f * C + g * D),
            (r[10] = p * w + m * A + f * P + g * N),
            (r[14] = p * S + m * R + f * I + g * O),
            (r[3] = y * b + x * T + v * L + _ * z),
            (r[7] = y * M + x * E + v * C + _ * D),
            (r[11] = y * w + x * A + v * P + _ * N),
            (r[15] = y * S + x * R + v * I + _ * O),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            i = t[4],
            n = t[8],
            r = t[12],
            s = t[1],
            a = t[5],
            o = t[9],
            l = t[13],
            h = t[2],
            c = t[6],
            u = t[10],
            d = t[14];
          return (
            t[3] *
              (+r * o * c -
                n * l * c -
                r * a * u +
                i * l * u +
                n * a * d -
                i * o * d) +
            t[7] *
              (+e * o * d -
                e * l * u +
                r * s * u -
                n * s * d +
                n * l * h -
                r * o * h) +
            t[11] *
              (+e * l * c -
                e * a * d -
                r * s * c +
                i * s * d +
                r * a * h -
                i * l * h) +
            t[15] *
              (-n * a * h -
                e * o * c +
                e * a * u +
                n * s * c -
                i * s * u +
                i * o * h)
          );
        }
        transpose() {
          const t = this.elements;
          let e;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        }
        setPosition(t, e, i) {
          const n = this.elements;
          return (
            t.isVector3
              ? ((n[12] = t.x), (n[13] = t.y), (n[14] = t.z))
              : ((n[12] = t), (n[13] = e), (n[14] = i)),
            this
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            r = t[3],
            s = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            h = t[8],
            c = t[9],
            u = t[10],
            d = t[11],
            p = t[12],
            m = t[13],
            f = t[14],
            g = t[15],
            y =
              c * f * l -
              m * u * l +
              m * o * d -
              a * f * d -
              c * o * g +
              a * u * g,
            x =
              p * u * l -
              h * f * l -
              p * o * d +
              s * f * d +
              h * o * g -
              s * u * g,
            v =
              h * m * l -
              p * c * l +
              p * a * d -
              s * m * d -
              h * a * g +
              s * c * g,
            _ =
              p * c * o -
              h * m * o -
              p * a * u +
              s * m * u +
              h * a * f -
              s * c * f,
            b = e * y + i * x + n * v + r * _;
          if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const M = 1 / b;
          return (
            (t[0] = y * M),
            (t[1] =
              (m * u * r -
                c * f * r -
                m * n * d +
                i * f * d +
                c * n * g -
                i * u * g) *
              M),
            (t[2] =
              (a * f * r -
                m * o * r +
                m * n * l -
                i * f * l -
                a * n * g +
                i * o * g) *
              M),
            (t[3] =
              (c * o * r -
                a * u * r -
                c * n * l +
                i * u * l +
                a * n * d -
                i * o * d) *
              M),
            (t[4] = x * M),
            (t[5] =
              (h * f * r -
                p * u * r +
                p * n * d -
                e * f * d -
                h * n * g +
                e * u * g) *
              M),
            (t[6] =
              (p * o * r -
                s * f * r -
                p * n * l +
                e * f * l +
                s * n * g -
                e * o * g) *
              M),
            (t[7] =
              (s * u * r -
                h * o * r +
                h * n * l -
                e * u * l -
                s * n * d +
                e * o * d) *
              M),
            (t[8] = v * M),
            (t[9] =
              (p * c * r -
                h * m * r -
                p * i * d +
                e * m * d +
                h * i * g -
                e * c * g) *
              M),
            (t[10] =
              (s * m * r -
                p * a * r +
                p * i * l -
                e * m * l -
                s * i * g +
                e * a * g) *
              M),
            (t[11] =
              (h * a * r -
                s * c * r -
                h * i * l +
                e * c * l +
                s * i * d -
                e * a * d) *
              M),
            (t[12] = _ * M),
            (t[13] =
              (h * m * n -
                p * c * n +
                p * i * u -
                e * m * u -
                h * i * f +
                e * c * f) *
              M),
            (t[14] =
              (p * a * n -
                s * m * n -
                p * i * o +
                e * m * o +
                s * i * f -
                e * a * f) *
              M),
            (t[15] =
              (s * c * n -
                h * a * n +
                h * i * o -
                e * c * o -
                s * i * u +
                e * a * u) *
              M),
            this
          );
        }
        scale(t) {
          const e = this.elements,
            i = t.x,
            n = t.y,
            r = t.z;
          return (
            (e[0] *= i),
            (e[4] *= n),
            (e[8] *= r),
            (e[1] *= i),
            (e[5] *= n),
            (e[9] *= r),
            (e[2] *= i),
            (e[6] *= n),
            (e[10] *= r),
            (e[3] *= i),
            (e[7] *= n),
            (e[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, i, n));
        }
        makeTranslation(t, e, i) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          const i = Math.cos(e),
            n = Math.sin(e),
            r = 1 - i,
            s = t.x,
            a = t.y,
            o = t.z,
            l = r * s,
            h = r * a;
          return (
            this.set(
              l * s + i,
              l * a - n * o,
              l * o + n * a,
              0,
              l * a + n * o,
              h * a + i,
              h * o - n * s,
              0,
              l * o - n * a,
              h * o + n * s,
              r * o * o + i,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, i) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, i, n, r, s) {
          return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, i) {
          const n = this.elements,
            r = e._x,
            s = e._y,
            a = e._z,
            o = e._w,
            l = r + r,
            h = s + s,
            c = a + a,
            u = r * l,
            d = r * h,
            p = r * c,
            m = s * h,
            f = s * c,
            g = a * c,
            y = o * l,
            x = o * h,
            v = o * c,
            _ = i.x,
            b = i.y,
            M = i.z;
          return (
            (n[0] = (1 - (m + g)) * _),
            (n[1] = (d + v) * _),
            (n[2] = (p - x) * _),
            (n[3] = 0),
            (n[4] = (d - v) * b),
            (n[5] = (1 - (u + g)) * b),
            (n[6] = (f + y) * b),
            (n[7] = 0),
            (n[8] = (p + x) * M),
            (n[9] = (f - y) * M),
            (n[10] = (1 - (u + m)) * M),
            (n[11] = 0),
            (n[12] = t.x),
            (n[13] = t.y),
            (n[14] = t.z),
            (n[15] = 1),
            this
          );
        }
        decompose(t, e, i) {
          const n = this.elements;
          let r = Ae.set(n[0], n[1], n[2]).length();
          const s = Ae.set(n[4], n[5], n[6]).length(),
            a = Ae.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r),
            (t.x = n[12]),
            (t.y = n[13]),
            (t.z = n[14]),
            Re.copy(this);
          const o = 1 / r,
            l = 1 / s,
            h = 1 / a;
          return (
            (Re.elements[0] *= o),
            (Re.elements[1] *= o),
            (Re.elements[2] *= o),
            (Re.elements[4] *= l),
            (Re.elements[5] *= l),
            (Re.elements[6] *= l),
            (Re.elements[8] *= h),
            (Re.elements[9] *= h),
            (Re.elements[10] *= h),
            e.setFromRotationMatrix(Re),
            (i.x = r),
            (i.y = s),
            (i.z = a),
            this
          );
        }
        makePerspective(t, e, i, n, r, s) {
          void 0 === s &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            o = (2 * r) / (e - t),
            l = (2 * r) / (i - n),
            h = (e + t) / (e - t),
            c = (i + n) / (i - n),
            u = -(s + r) / (s - r),
            d = (-2 * s * r) / (s - r);
          return (
            (a[0] = o),
            (a[4] = 0),
            (a[8] = h),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = l),
            (a[9] = c),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = u),
            (a[14] = d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, i, n, r, s) {
          const a = this.elements,
            o = 1 / (e - t),
            l = 1 / (i - n),
            h = 1 / (s - r),
            c = (e + t) * o,
            u = (i + n) * l,
            d = (s + r) * h;
          return (
            (a[0] = 2 * o),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -c),
            (a[1] = 0),
            (a[5] = 2 * l),
            (a[9] = 0),
            (a[13] = -u),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * h),
            (a[14] = -d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            i = t.elements;
          for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            (t[e + 9] = i[9]),
            (t[e + 10] = i[10]),
            (t[e + 11] = i[11]),
            (t[e + 12] = i[12]),
            (t[e + 13] = i[13]),
            (t[e + 14] = i[14]),
            (t[e + 15] = i[15]),
            t
          );
        }
      }
      Ee.prototype.isMatrix4 = !0;
      const Ae = new Jt(),
        Re = new Ee(),
        Le = new Jt(0, 0, 0),
        Ce = new Jt(1, 1, 1),
        Pe = new Jt(),
        Ie = new Jt(),
        ze = new Jt(),
        De = new Ee(),
        Ne = new Yt();
      class Oe {
        constructor(t = 0, e = 0, i = 0, n = Oe.DefaultOrder) {
          (this._x = t), (this._y = e), (this._z = i), (this._order = n);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, i, n = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._order = n),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, i = !0) {
          const n = t.elements,
            r = n[0],
            s = n[4],
            a = n[8],
            o = n[1],
            l = n[5],
            h = n[9],
            c = n[2],
            u = n[6],
            d = n[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(vt(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(u, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-vt(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                  : ((this._y = Math.atan2(-c, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(vt(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._y = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-s, l)))
                  : ((this._y = 0), (this._z = Math.atan2(o, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-vt(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, l)));
              break;
            case "YZX":
              (this._z = Math.asin(vt(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-h, l)),
                    (this._y = Math.atan2(-c, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-vt(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-h, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !0 === i && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, i) {
          return (
            De.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(De, e, i)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return Ne.setFromEuler(this), this.setFromQuaternion(Ne, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        toVector3(t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new Jt(this._x, this._y, this._z);
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      (Oe.prototype.isEuler = !0),
        (Oe.DefaultOrder = "XYZ"),
        (Oe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      class Be {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = ((1 << t) | 0) >>> 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return 0 != (this.mask & t.mask);
        }
        isEnabled(t) {
          return 0 != (this.mask & ((1 << t) | 0));
        }
      }
      let Fe = 0;
      const He = new Jt(),
        Ue = new Yt(),
        ke = new Ee(),
        Ge = new Jt(),
        Ve = new Jt(),
        We = new Jt(),
        je = new Yt(),
        qe = new Jt(1, 0, 0),
        Xe = new Jt(0, 1, 0),
        Ye = new Jt(0, 0, 1),
        Je = { type: "added" },
        Ze = { type: "removed" };
      class Ke extends pt {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Fe++ }),
            (this.uuid = xt()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ke.DefaultUp.clone());
          const t = new Jt(),
            e = new Oe(),
            i = new Yt(),
            n = new Jt(1, 1, 1);
          e._onChange(function () {
            i.setFromEuler(e, !1);
          }),
            i._onChange(function () {
              e.setFromQuaternion(i, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: i },
              scale: { configurable: !0, enumerable: !0, value: n },
              modelViewMatrix: { value: new Ee() },
              normalMatrix: { value: new At() },
            }),
            (this.matrix = new Ee()),
            (this.matrixWorld = new Ee()),
            (this.matrixAutoUpdate = Ke.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Be()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return Ue.setFromAxisAngle(t, e), this.quaternion.multiply(Ue), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            Ue.setFromAxisAngle(t, e), this.quaternion.premultiply(Ue), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(qe, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(Xe, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(Ye, t);
        }
        translateOnAxis(t, e) {
          return (
            He.copy(t).applyQuaternion(this.quaternion),
            this.position.add(He.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(qe, t);
        }
        translateY(t) {
          return this.translateOnAxis(Xe, t);
        }
        translateZ(t) {
          return this.translateOnAxis(Ye, t);
        }
        localToWorld(t) {
          return t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return t.applyMatrix4(ke.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, i) {
          t.isVector3 ? Ge.copy(t) : Ge.set(t, e, i);
          const n = this.parent;
          this.updateWorldMatrix(!0, !1),
            Ve.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? ke.lookAt(Ve, Ge, this.up)
              : ke.lookAt(Ge, Ve, this.up),
            this.quaternion.setFromRotationMatrix(ke),
            n &&
              (ke.extractRotation(n.matrixWorld),
              Ue.setFromRotationMatrix(ke),
              this.quaternion.premultiply(Ue.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(Je))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(Ze)),
            this
          );
        }
        removeFromParent() {
          const t = this.parent;
          return null !== t && t.remove(this), this;
        }
        clear() {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            (e.parent = null), e.dispatchEvent(Ze);
          }
          return (this.children.length = 0), this;
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            ke.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              ke.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(ke),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let i = 0, n = this.children.length; i < n; i++) {
            const n = this.children[i].getObjectByProperty(t, e);
            if (void 0 !== n) return n;
          }
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ve, t, We),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ve, je, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
        }
        traverseVisible(t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const i = this.parent;
          if (
            (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, i = t.length; e < i; e++)
              t[e].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t,
            i = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (i.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const n = {};
          function r(e, i) {
            return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            (n.layers = this.layers.mask),
            (n.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((n.type = "InstancedMesh"),
              (n.count = this.count),
              (n.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (n.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (n.background = this.background.toJSON())
                : this.background.isTexture &&
                  (n.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (n.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const i = e.shapes;
              if (Array.isArray(i))
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e];
                  r(t.shapes, n);
                }
              else r(t.shapes, i);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((n.bindMode = this.bindMode),
              (n.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(t.skeletons, this.skeleton),
                (n.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = [];
              for (let i = 0, n = this.material.length; i < n; i++)
                e.push(r(t.materials, this.material[i]));
              n.material = e;
            } else n.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            n.children = [];
            for (let e = 0; e < this.children.length; e++)
              n.children.push(this.children[e].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
              const i = this.animations[e];
              n.animations.push(r(t.animations, i));
            }
          }
          if (e) {
            const e = s(t.geometries),
              n = s(t.materials),
              r = s(t.textures),
              a = s(t.images),
              o = s(t.shapes),
              l = s(t.skeletons),
              h = s(t.animations);
            e.length > 0 && (i.geometries = e),
              n.length > 0 && (i.materials = n),
              r.length > 0 && (i.textures = r),
              a.length > 0 && (i.images = a),
              o.length > 0 && (i.shapes = o),
              l.length > 0 && (i.skeletons = l),
              h.length > 0 && (i.animations = h);
          }
          return (i.object = n), i;
          function s(t) {
            const e = [];
            for (const i in t) {
              const n = t[i];
              delete n.metadata, e.push(n);
            }
            return e;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const i = t.children[e];
              this.add(i.clone());
            }
          return this;
        }
      }
      (Ke.DefaultUp = new Jt(0, 1, 0)),
        (Ke.DefaultMatrixAutoUpdate = !0),
        (Ke.prototype.isObject3D = !0);
      const Qe = new Jt(),
        $e = new Jt(),
        ti = new Jt(),
        ei = new Jt(),
        ii = new Jt(),
        ni = new Jt(),
        ri = new Jt(),
        si = new Jt(),
        ai = new Jt(),
        oi = new Jt();
      class li {
        constructor(t = new Jt(), e = new Jt(), i = new Jt()) {
          (this.a = t), (this.b = e), (this.c = i);
        }
        static getNormal(t, e, i, n) {
          n.subVectors(i, e), Qe.subVectors(t, e), n.cross(Qe);
          const r = n.lengthSq();
          return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }
        static getBarycoord(t, e, i, n, r) {
          Qe.subVectors(n, e), $e.subVectors(i, e), ti.subVectors(t, e);
          const s = Qe.dot(Qe),
            a = Qe.dot($e),
            o = Qe.dot(ti),
            l = $e.dot($e),
            h = $e.dot(ti),
            c = s * l - a * a;
          if (0 === c) return r.set(-2, -1, -1);
          const u = 1 / c,
            d = (l * o - a * h) * u,
            p = (s * h - a * o) * u;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(t, e, i, n) {
          return (
            this.getBarycoord(t, e, i, n, ei),
            ei.x >= 0 && ei.y >= 0 && ei.x + ei.y <= 1
          );
        }
        static getUV(t, e, i, n, r, s, a, o) {
          return (
            this.getBarycoord(t, e, i, n, ei),
            o.set(0, 0),
            o.addScaledVector(r, ei.x),
            o.addScaledVector(s, ei.y),
            o.addScaledVector(a, ei.z),
            o
          );
        }
        static isFrontFacing(t, e, i, n) {
          return (
            Qe.subVectors(i, e), $e.subVectors(t, e), Qe.cross($e).dot(n) < 0
          );
        }
        set(t, e, i) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
        }
        setFromPointsAndIndices(t, e, i, n) {
          return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
        }
        setFromAttributeAndIndices(t, e, i, n) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, i),
            this.c.fromBufferAttribute(t, n),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            Qe.subVectors(this.c, this.b),
            $e.subVectors(this.a, this.b),
            0.5 * Qe.cross($e).length()
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return li.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return li.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getUV(t, e, i, n, r) {
          return li.getUV(t, this.a, this.b, this.c, e, i, n, r);
        }
        containsPoint(t) {
          return li.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return li.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const i = this.a,
            n = this.b,
            r = this.c;
          let s, a;
          ii.subVectors(n, i), ni.subVectors(r, i), si.subVectors(t, i);
          const o = ii.dot(si),
            l = ni.dot(si);
          if (o <= 0 && l <= 0) return e.copy(i);
          ai.subVectors(t, n);
          const h = ii.dot(ai),
            c = ni.dot(ai);
          if (h >= 0 && c <= h) return e.copy(n);
          const u = o * c - h * l;
          if (u <= 0 && o >= 0 && h <= 0)
            return (s = o / (o - h)), e.copy(i).addScaledVector(ii, s);
          oi.subVectors(t, r);
          const d = ii.dot(oi),
            p = ni.dot(oi);
          if (p >= 0 && d <= p) return e.copy(r);
          const m = d * l - o * p;
          if (m <= 0 && l >= 0 && p <= 0)
            return (a = l / (l - p)), e.copy(i).addScaledVector(ni, a);
          const f = h * p - d * c;
          if (f <= 0 && c - h >= 0 && d - p >= 0)
            return (
              ri.subVectors(r, n),
              (a = (c - h) / (c - h + (d - p))),
              e.copy(n).addScaledVector(ri, a)
            );
          const g = 1 / (f + m + u);
          return (
            (s = m * g),
            (a = u * g),
            e.copy(i).addScaledVector(ii, s).addScaledVector(ni, a)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      let hi = 0;
      class ci extends pt {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: hi++ }),
            (this.uuid = xt()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = i),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = lt),
            (this.stencilZFail = lt),
            (this.stencilZPass = lt),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const i = t[e];
              if (void 0 === i) {
                console.warn(
                  "THREE.Material: '" + e + "' parameter is undefined."
                );
                continue;
              }
              if ("shading" === e) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === i);
                continue;
              }
              const n = this[e];
              void 0 !== n
                ? n && n.isColor
                  ? n.set(i)
                  : n && n.isVector3 && i && i.isVector3
                  ? n.copy(i)
                  : (this[e] = i)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material."
                  );
            }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          e && (t = { textures: {}, images: {} });
          const i = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function n(t) {
            const e = [];
            for (const i in t) {
              const n = t[i];
              delete n.metadata, e.push(n);
            }
            return e;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            void 0 !== this.sheen && (i.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (i.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (i.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (i.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (i.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (i.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (i.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (i.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (i.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((i.lightMap = this.lightMap.toJSON(t).uuid),
              (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((i.aoMap = this.aoMap.toJSON(t).uuid),
              (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
              (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(t).uuid),
              (i.normalMapType = this.normalMapType),
              (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (i.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (i.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((i.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (i.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (i.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (i.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (i.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (i.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (i.blending = this.blending),
            0 !== this.side && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            (i.depthFunc = this.depthFunc),
            (i.depthTest = this.depthTest),
            (i.depthWrite = this.depthWrite),
            (i.colorWrite = this.colorWrite),
            (i.stencilWrite = this.stencilWrite),
            (i.stencilWriteMask = this.stencilWriteMask),
            (i.stencilFunc = this.stencilFunc),
            (i.stencilRef = this.stencilRef),
            (i.stencilFuncMask = this.stencilFuncMask),
            (i.stencilFail = this.stencilFail),
            (i.stencilZFail = this.stencilZFail),
            (i.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (i.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage &&
              (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            e)
          ) {
            const e = n(t.textures),
              r = n(t.images);
            e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.fog = t.fog),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          const e = t.clippingPlanes;
          let i = null;
          if (null !== e) {
            const t = e.length;
            i = new Array(t);
            for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      ci.prototype.isMaterial = !0;
      class ui extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Ft(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      ui.prototype.isMeshBasicMaterial = !0;
      const di = new Jt(),
        pi = new Et();
      class mi {
        constructor(t, e, i) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === i),
            (this.usage = ht),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, i) {
          (t *= this.itemSize), (i *= e.itemSize);
          for (let n = 0, r = this.itemSize; n < r; n++)
            this.array[t + n] = e.array[i + n];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        copyColorsArray(t) {
          const e = this.array;
          let i = 0;
          for (let n = 0, r = t.length; n < r; n++) {
            let r = t[n];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                n
              ),
              (r = new Ft())),
              (e[i++] = r.r),
              (e[i++] = r.g),
              (e[i++] = r.b);
          }
          return this;
        }
        copyVector2sArray(t) {
          const e = this.array;
          let i = 0;
          for (let n = 0, r = t.length; n < r; n++) {
            let r = t[n];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                n
              ),
              (r = new Et())),
              (e[i++] = r.x),
              (e[i++] = r.y);
          }
          return this;
        }
        copyVector3sArray(t) {
          const e = this.array;
          let i = 0;
          for (let n = 0, r = t.length; n < r; n++) {
            let r = t[n];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                n
              ),
              (r = new Jt())),
              (e[i++] = r.x),
              (e[i++] = r.y),
              (e[i++] = r.z);
          }
          return this;
        }
        copyVector4sArray(t) {
          const e = this.array;
          let i = 0;
          for (let n = 0, r = t.length; n < r; n++) {
            let r = t[n];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                n
              ),
              (r = new Wt())),
              (e[i++] = r.x),
              (e[i++] = r.y),
              (e[i++] = r.z),
              (e[i++] = r.w);
          }
          return this;
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              pi.fromBufferAttribute(this, e),
                pi.applyMatrix3(t),
                this.setXY(e, pi.x, pi.y);
          else if (3 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              di.fromBufferAttribute(this, e),
                di.applyMatrix3(t),
                this.setXYZ(e, di.x, di.y, di.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (di.x = this.getX(e)),
              (di.y = this.getY(e)),
              (di.z = this.getZ(e)),
              di.applyMatrix4(t),
              this.setXYZ(e, di.x, di.y, di.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (di.x = this.getX(e)),
              (di.y = this.getY(e)),
              (di.z = this.getZ(e)),
              di.applyNormalMatrix(t),
              this.setXYZ(e, di.x, di.y, di.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (di.x = this.getX(e)),
              (di.y = this.getY(e)),
              (di.z = this.getZ(e)),
              di.transformDirection(t),
              this.setXYZ(e, di.x, di.y, di.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getX(t) {
          return this.array[t * this.itemSize];
        }
        setX(t, e) {
          return (this.array[t * this.itemSize] = e), this;
        }
        getY(t) {
          return this.array[t * this.itemSize + 1];
        }
        setY(t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        }
        getZ(t) {
          return this.array[t * this.itemSize + 2];
        }
        setZ(t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        }
        getW(t) {
          return this.array[t * this.itemSize + 3];
        }
        setW(t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        }
        setXY(t, e, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            this
          );
        }
        setXYZ(t, e, i, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = n),
            this
          );
        }
        setXYZW(t, e, i, n, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = n),
            (this.array[t + 3] = r),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (t.name = this.name),
            this.usage !== ht && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
            t
          );
        }
      }
      mi.prototype.isBufferAttribute = !0;
      class fi extends mi {
        constructor(t, e, i) {
          super(new Int8Array(t), e, i);
        }
      }
      class gi extends mi {
        constructor(t, e, i) {
          super(new Uint8Array(t), e, i);
        }
      }
      class yi extends mi {
        constructor(t, e, i) {
          super(new Uint8ClampedArray(t), e, i);
        }
      }
      class xi extends mi {
        constructor(t, e, i) {
          super(new Int16Array(t), e, i);
        }
      }
      class vi extends mi {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i);
        }
      }
      class _i extends mi {
        constructor(t, e, i) {
          super(new Int32Array(t), e, i);
        }
      }
      class bi extends mi {
        constructor(t, e, i) {
          super(new Uint32Array(t), e, i);
        }
      }
      class Mi extends mi {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i);
        }
      }
      Mi.prototype.isFloat16BufferAttribute = !0;
      class wi extends mi {
        constructor(t, e, i) {
          super(new Float32Array(t), e, i);
        }
      }
      class Si extends mi {
        constructor(t, e, i) {
          super(new Float64Array(t), e, i);
        }
      }
      let Ti = 0;
      const Ei = new Ee(),
        Ai = new Ke(),
        Ri = new Jt(),
        Li = new Qt(),
        Ci = new Qt(),
        Pi = new Jt();
      class Ii extends pt {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Ti++ }),
            (this.uuid = xt()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (Rt(t) ? bi : vi)(t, 1))
              : (this.index = t),
            this
          );
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t];
        }
        addGroup(t, e, i = 0) {
          this.groups.push({ start: t, count: e, materialIndex: i });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
          const i = this.attributes.normal;
          if (void 0 !== i) {
            const e = new At().getNormalMatrix(t);
            i.applyNormalMatrix(e), (i.needsUpdate = !0);
          }
          const n = this.attributes.tangent;
          return (
            void 0 !== n && (n.transformDirection(t), (n.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return Ei.makeRotationFromQuaternion(t), this.applyMatrix4(Ei), this;
        }
        rotateX(t) {
          return Ei.makeRotationX(t), this.applyMatrix4(Ei), this;
        }
        rotateY(t) {
          return Ei.makeRotationY(t), this.applyMatrix4(Ei), this;
        }
        rotateZ(t) {
          return Ei.makeRotationZ(t), this.applyMatrix4(Ei), this;
        }
        translate(t, e, i) {
          return Ei.makeTranslation(t, e, i), this.applyMatrix4(Ei), this;
        }
        scale(t, e, i) {
          return Ei.makeScale(t, e, i), this.applyMatrix4(Ei), this;
        }
        lookAt(t) {
          return (
            Ai.lookAt(t), Ai.updateMatrix(), this.applyMatrix4(Ai.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Ri).negate(),
            this.translate(Ri.x, Ri.y, Ri.z),
            this
          );
        }
        setFromPoints(t) {
          const e = [];
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            e.push(n.x, n.y, n.z || 0);
          }
          return this.setAttribute("position", new wi(e, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Qt());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new Jt(-1 / 0, -1 / 0, -1 / 0),
                new Jt(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                Li.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (Pi.addVectors(this.boundingBox.min, Li.min),
                      this.boundingBox.expandByPoint(Pi),
                      Pi.addVectors(this.boundingBox.max, Li.max),
                      this.boundingBox.expandByPoint(Pi))
                    : (this.boundingBox.expandByPoint(Li.min),
                      this.boundingBox.expandByPoint(Li.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new ye());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new Jt(), 1 / 0)
            );
          if (t) {
            const i = this.boundingSphere.center;
            if ((Li.setFromBufferAttribute(t), e))
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                Ci.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (Pi.addVectors(Li.min, Ci.min),
                      Li.expandByPoint(Pi),
                      Pi.addVectors(Li.max, Ci.max),
                      Li.expandByPoint(Pi))
                    : (Li.expandByPoint(Ci.min), Li.expandByPoint(Ci.max));
              }
            Li.getCenter(i);
            let n = 0;
            for (let e = 0, r = t.count; e < r; e++)
              Pi.fromBufferAttribute(t, e),
                (n = Math.max(n, i.distanceToSquared(Pi)));
            if (e)
              for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r],
                  a = this.morphTargetsRelative;
                for (let e = 0, r = s.count; e < r; e++)
                  Pi.fromBufferAttribute(s, e),
                    a && (Ri.fromBufferAttribute(t, e), Pi.add(Ri)),
                    (n = Math.max(n, i.distanceToSquared(Pi)));
              }
            (this.boundingSphere.radius = Math.sqrt(n)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const t = this.index,
            e = this.attributes;
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const i = t.array,
            n = e.position.array,
            r = e.normal.array,
            s = e.uv.array,
            a = n.length / 3;
          void 0 === e.tangent &&
            this.setAttribute("tangent", new mi(new Float32Array(4 * a), 4));
          const o = e.tangent.array,
            l = [],
            h = [];
          for (let t = 0; t < a; t++) (l[t] = new Jt()), (h[t] = new Jt());
          const c = new Jt(),
            u = new Jt(),
            d = new Jt(),
            p = new Et(),
            m = new Et(),
            f = new Et(),
            g = new Jt(),
            y = new Jt();
          function x(t, e, i) {
            c.fromArray(n, 3 * t),
              u.fromArray(n, 3 * e),
              d.fromArray(n, 3 * i),
              p.fromArray(s, 2 * t),
              m.fromArray(s, 2 * e),
              f.fromArray(s, 2 * i),
              u.sub(c),
              d.sub(c),
              m.sub(p),
              f.sub(p);
            const r = 1 / (m.x * f.y - f.x * m.y);
            isFinite(r) &&
              (g
                .copy(u)
                .multiplyScalar(f.y)
                .addScaledVector(d, -m.y)
                .multiplyScalar(r),
              y
                .copy(d)
                .multiplyScalar(m.x)
                .addScaledVector(u, -f.x)
                .multiplyScalar(r),
              l[t].add(g),
              l[e].add(g),
              l[i].add(g),
              h[t].add(y),
              h[e].add(y),
              h[i].add(y));
          }
          let v = this.groups;
          0 === v.length && (v = [{ start: 0, count: i.length }]);
          for (let t = 0, e = v.length; t < e; ++t) {
            const e = v[t],
              n = e.start;
            for (let t = n, r = n + e.count; t < r; t += 3)
              x(i[t + 0], i[t + 1], i[t + 2]);
          }
          const _ = new Jt(),
            b = new Jt(),
            M = new Jt(),
            w = new Jt();
          function S(t) {
            M.fromArray(r, 3 * t), w.copy(M);
            const e = l[t];
            _.copy(e),
              _.sub(M.multiplyScalar(M.dot(e))).normalize(),
              b.crossVectors(w, e);
            const i = b.dot(h[t]) < 0 ? -1 : 1;
            (o[4 * t] = _.x),
              (o[4 * t + 1] = _.y),
              (o[4 * t + 2] = _.z),
              (o[4 * t + 3] = i);
          }
          for (let t = 0, e = v.length; t < e; ++t) {
            const e = v[t],
              n = e.start;
            for (let t = n, r = n + e.count; t < r; t += 3)
              S(i[t + 0]), S(i[t + 1]), S(i[t + 2]);
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute("position");
          if (void 0 !== e) {
            let i = this.getAttribute("normal");
            if (void 0 === i)
              (i = new mi(new Float32Array(3 * e.count), 3)),
                this.setAttribute("normal", i);
            else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
            const n = new Jt(),
              r = new Jt(),
              s = new Jt(),
              a = new Jt(),
              o = new Jt(),
              l = new Jt(),
              h = new Jt(),
              c = new Jt();
            if (t)
              for (let u = 0, d = t.count; u < d; u += 3) {
                const d = t.getX(u + 0),
                  p = t.getX(u + 1),
                  m = t.getX(u + 2);
                n.fromBufferAttribute(e, d),
                  r.fromBufferAttribute(e, p),
                  s.fromBufferAttribute(e, m),
                  h.subVectors(s, r),
                  c.subVectors(n, r),
                  h.cross(c),
                  a.fromBufferAttribute(i, d),
                  o.fromBufferAttribute(i, p),
                  l.fromBufferAttribute(i, m),
                  a.add(h),
                  o.add(h),
                  l.add(h),
                  i.setXYZ(d, a.x, a.y, a.z),
                  i.setXYZ(p, o.x, o.y, o.z),
                  i.setXYZ(m, l.x, l.y, l.z);
              }
            else
              for (let t = 0, a = e.count; t < a; t += 3)
                n.fromBufferAttribute(e, t + 0),
                  r.fromBufferAttribute(e, t + 1),
                  s.fromBufferAttribute(e, t + 2),
                  h.subVectors(s, r),
                  c.subVectors(n, r),
                  h.cross(c),
                  i.setXYZ(t + 0, h.x, h.y, h.z),
                  i.setXYZ(t + 1, h.x, h.y, h.z),
                  i.setXYZ(t + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
          }
        }
        merge(t, e) {
          if (!t || !t.isBufferGeometry)
            return void console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              t
            );
          void 0 === e &&
            ((e = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const i = this.attributes;
          for (const n in i) {
            if (void 0 === t.attributes[n]) continue;
            const r = i[n].array,
              s = t.attributes[n],
              a = s.array,
              o = s.itemSize * e,
              l = Math.min(a.length, r.length - o);
            for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t];
          }
          return this;
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, i = t.count; e < i; e++)
            Pi.fromBufferAttribute(t, e),
              Pi.normalize(),
              t.setXYZ(e, Pi.x, Pi.y, Pi.z);
        }
        toNonIndexed() {
          function t(t, e) {
            const i = t.array,
              n = t.itemSize,
              r = t.normalized,
              s = new i.constructor(e.length * n);
            let a = 0,
              o = 0;
            for (let r = 0, l = e.length; r < l; r++) {
              a = t.isInterleavedBufferAttribute
                ? e[r] * t.data.stride + t.offset
                : e[r] * n;
              for (let t = 0; t < n; t++) s[o++] = i[a++];
            }
            return new mi(s, n, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const e = new Ii(),
            i = this.index.array,
            n = this.attributes;
          for (const r in n) {
            const s = t(n[r], i);
            e.setAttribute(r, s);
          }
          const r = this.morphAttributes;
          for (const n in r) {
            const s = [],
              a = r[n];
            for (let e = 0, n = a.length; e < n; e++) {
              const n = t(a[e], i);
              s.push(n);
            }
            e.morphAttributes[n] = s;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let t = 0, i = s.length; t < i; t++) {
            const i = s[t];
            e.addGroup(i.start, i.count, i.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters;
            for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
            return t;
          }
          t.data = { attributes: {} };
          const e = this.index;
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          const i = this.attributes;
          for (const e in i) {
            const n = i[e];
            t.data.attributes[e] = n.toJSON(t.data);
          }
          const n = {};
          let r = !1;
          for (const e in this.morphAttributes) {
            const i = this.morphAttributes[e],
              s = [];
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              s.push(n.toJSON(t.data));
            }
            s.length > 0 && ((n[e] = s), (r = !0));
          }
          r &&
            ((t.data.morphAttributes = n),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (t.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            t
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const e = {};
          this.name = t.name;
          const i = t.index;
          null !== i && this.setIndex(i.clone(e));
          const n = t.attributes;
          for (const t in n) {
            const i = n[t];
            this.setAttribute(t, i.clone(e));
          }
          const r = t.morphAttributes;
          for (const t in r) {
            const i = [],
              n = r[t];
            for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
            this.morphAttributes[t] = i;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const s = t.groups;
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t];
            this.addGroup(e.start, e.count, e.materialIndex);
          }
          const a = t.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const o = t.boundingSphere;
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            void 0 !== t.parameters &&
              (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ii.prototype.isBufferGeometry = !0;
      const zi = new Ee(),
        Di = new Te(),
        Ni = new ye(),
        Oi = new Jt(),
        Bi = new Jt(),
        Fi = new Jt(),
        Hi = new Jt(),
        Ui = new Jt(),
        ki = new Jt(),
        Gi = new Jt(),
        Vi = new Jt(),
        Wi = new Jt(),
        ji = new Et(),
        qi = new Et(),
        Xi = new Et(),
        Yi = new Jt(),
        Ji = new Jt();
      class Zi extends Ke {
        constructor(t = new Ii(), e = new ui()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e);
            if (i.length > 0) {
              const t = e[i[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[i] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.material,
            r = this.matrixWorld;
          if (void 0 === n) return;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            Ni.copy(i.boundingSphere),
            Ni.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(Ni))
          )
            return;
          if (
            (zi.copy(r).invert(),
            Di.copy(t.ray).applyMatrix4(zi),
            null !== i.boundingBox && !1 === Di.intersectsBox(i.boundingBox))
          )
            return;
          let s;
          if (i.isBufferGeometry) {
            const r = i.index,
              a = i.attributes.position,
              o = i.morphAttributes.position,
              l = i.morphTargetsRelative,
              h = i.attributes.uv,
              c = i.attributes.uv2,
              u = i.groups,
              d = i.drawRange;
            if (null !== r)
              if (Array.isArray(n))
                for (let i = 0, p = u.length; i < p; i++) {
                  const p = u[i],
                    m = n[p.materialIndex];
                  for (
                    let i = Math.max(p.start, d.start),
                      n = Math.min(
                        r.count,
                        Math.min(p.start + p.count, d.start + d.count)
                      );
                    i < n;
                    i += 3
                  ) {
                    const n = r.getX(i),
                      u = r.getX(i + 1),
                      d = r.getX(i + 2);
                    (s = Ki(this, m, t, Di, a, o, l, h, c, n, u, d)),
                      s &&
                        ((s.faceIndex = Math.floor(i / 3)),
                        (s.face.materialIndex = p.materialIndex),
                        e.push(s));
                  }
                }
              else
                for (
                  let i = Math.max(0, d.start),
                    u = Math.min(r.count, d.start + d.count);
                  i < u;
                  i += 3
                ) {
                  const u = r.getX(i),
                    d = r.getX(i + 1),
                    p = r.getX(i + 2);
                  (s = Ki(this, n, t, Di, a, o, l, h, c, u, d, p)),
                    s && ((s.faceIndex = Math.floor(i / 3)), e.push(s));
                }
            else if (void 0 !== a)
              if (Array.isArray(n))
                for (let i = 0, r = u.length; i < r; i++) {
                  const r = u[i],
                    p = n[r.materialIndex];
                  for (
                    let i = Math.max(r.start, d.start),
                      n = Math.min(
                        a.count,
                        Math.min(r.start + r.count, d.start + d.count)
                      );
                    i < n;
                    i += 3
                  )
                    (s = Ki(this, p, t, Di, a, o, l, h, c, i, i + 1, i + 2)),
                      s &&
                        ((s.faceIndex = Math.floor(i / 3)),
                        (s.face.materialIndex = r.materialIndex),
                        e.push(s));
                }
              else
                for (
                  let i = Math.max(0, d.start),
                    r = Math.min(a.count, d.start + d.count);
                  i < r;
                  i += 3
                )
                  (s = Ki(this, n, t, Di, a, o, l, h, c, i, i + 1, i + 2)),
                    s && ((s.faceIndex = Math.floor(i / 3)), e.push(s));
          } else
            i.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      function Ki(t, e, i, n, r, s, a, o, l, h, c, u) {
        Oi.fromBufferAttribute(r, h),
          Bi.fromBufferAttribute(r, c),
          Fi.fromBufferAttribute(r, u);
        const d = t.morphTargetInfluences;
        if (s && d) {
          Gi.set(0, 0, 0), Vi.set(0, 0, 0), Wi.set(0, 0, 0);
          for (let t = 0, e = s.length; t < e; t++) {
            const e = d[t],
              i = s[t];
            0 !== e &&
              (Hi.fromBufferAttribute(i, h),
              Ui.fromBufferAttribute(i, c),
              ki.fromBufferAttribute(i, u),
              a
                ? (Gi.addScaledVector(Hi, e),
                  Vi.addScaledVector(Ui, e),
                  Wi.addScaledVector(ki, e))
                : (Gi.addScaledVector(Hi.sub(Oi), e),
                  Vi.addScaledVector(Ui.sub(Bi), e),
                  Wi.addScaledVector(ki.sub(Fi), e)));
          }
          Oi.add(Gi), Bi.add(Vi), Fi.add(Wi);
        }
        t.isSkinnedMesh &&
          (t.boneTransform(h, Oi),
          t.boneTransform(c, Bi),
          t.boneTransform(u, Fi));
        const p = (function (t, e, i, n, r, s, a, o) {
          let l;
          if (
            ((l =
              1 === e.side
                ? n.intersectTriangle(a, s, r, !0, o)
                : n.intersectTriangle(r, s, a, 2 !== e.side, o)),
            null === l)
          )
            return null;
          Ji.copy(o), Ji.applyMatrix4(t.matrixWorld);
          const h = i.ray.origin.distanceTo(Ji);
          return h < i.near || h > i.far
            ? null
            : { distance: h, point: Ji.clone(), object: t };
        })(t, e, i, n, Oi, Bi, Fi, Yi);
        if (p) {
          o &&
            (ji.fromBufferAttribute(o, h),
            qi.fromBufferAttribute(o, c),
            Xi.fromBufferAttribute(o, u),
            (p.uv = li.getUV(Yi, Oi, Bi, Fi, ji, qi, Xi, new Et()))),
            l &&
              (ji.fromBufferAttribute(l, h),
              qi.fromBufferAttribute(l, c),
              Xi.fromBufferAttribute(l, u),
              (p.uv2 = li.getUV(Yi, Oi, Bi, Fi, ji, qi, Xi, new Et())));
          const t = { a: h, b: c, c: u, normal: new Jt(), materialIndex: 0 };
          li.getNormal(Oi, Bi, Fi, t.normal), (p.face = t);
        }
        return p;
      }
      Zi.prototype.isMesh = !0;
      class Qi extends Ii {
        constructor(t = 1, e = 1, i = 1, n = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: i,
              widthSegments: n,
              heightSegments: r,
              depthSegments: s,
            });
          const a = this;
          (n = Math.floor(n)), (r = Math.floor(r)), (s = Math.floor(s));
          const o = [],
            l = [],
            h = [],
            c = [];
          let u = 0,
            d = 0;
          function p(t, e, i, n, r, s, p, m, f, g, y) {
            const x = s / f,
              v = p / g,
              _ = s / 2,
              b = p / 2,
              M = m / 2,
              w = f + 1,
              S = g + 1;
            let T = 0,
              E = 0;
            const A = new Jt();
            for (let s = 0; s < S; s++) {
              const a = s * v - b;
              for (let o = 0; o < w; o++) {
                const u = o * x - _;
                (A[t] = u * n),
                  (A[e] = a * r),
                  (A[i] = M),
                  l.push(A.x, A.y, A.z),
                  (A[t] = 0),
                  (A[e] = 0),
                  (A[i] = m > 0 ? 1 : -1),
                  h.push(A.x, A.y, A.z),
                  c.push(o / f),
                  c.push(1 - s / g),
                  (T += 1);
              }
            }
            for (let t = 0; t < g; t++)
              for (let e = 0; e < f; e++) {
                const i = u + e + w * t,
                  n = u + e + w * (t + 1),
                  r = u + (e + 1) + w * (t + 1),
                  s = u + (e + 1) + w * t;
                o.push(i, n, s), o.push(n, r, s), (E += 6);
              }
            a.addGroup(d, E, y), (d += E), (u += T);
          }
          p("z", "y", "x", -1, -1, i, e, t, s, r, 0),
            p("z", "y", "x", 1, -1, i, e, -t, s, r, 1),
            p("x", "z", "y", 1, 1, t, i, e, n, s, 2),
            p("x", "z", "y", 1, -1, t, i, -e, n, s, 3),
            p("x", "y", "z", 1, -1, t, e, i, n, r, 4),
            p("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
            this.setIndex(o),
            this.setAttribute("position", new wi(l, 3)),
            this.setAttribute("normal", new wi(h, 3)),
            this.setAttribute("uv", new wi(c, 2));
        }
        static fromJSON(t) {
          return new Qi(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      }
      function $i(t) {
        const e = {};
        for (const i in t) {
          e[i] = {};
          for (const n in t[i]) {
            const r = t[i][n];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? (e[i][n] = r.clone())
              : Array.isArray(r)
              ? (e[i][n] = r.slice())
              : (e[i][n] = r);
          }
        }
        return e;
      }
      function tn(t) {
        const e = {};
        for (let i = 0; i < t.length; i++) {
          const n = $i(t[i]);
          for (const t in n) e[t] = n[t];
        }
        return e;
      }
      const en = { clone: $i, merge: tn };
      class nn extends ci {
        constructor(t) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(t));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = $i(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          (e.glslVersion = this.glslVersion), (e.uniforms = {});
          for (const i in this.uniforms) {
            const n = this.uniforms[i].value;
            n && n.isTexture
              ? (e.uniforms[i] = { type: "t", value: n.toJSON(t).uuid })
              : n && n.isColor
              ? (e.uniforms[i] = { type: "c", value: n.getHex() })
              : n && n.isVector2
              ? (e.uniforms[i] = { type: "v2", value: n.toArray() })
              : n && n.isVector3
              ? (e.uniforms[i] = { type: "v3", value: n.toArray() })
              : n && n.isVector4
              ? (e.uniforms[i] = { type: "v4", value: n.toArray() })
              : n && n.isMatrix3
              ? (e.uniforms[i] = { type: "m3", value: n.toArray() })
              : n && n.isMatrix4
              ? (e.uniforms[i] = { type: "m4", value: n.toArray() })
              : (e.uniforms[i] = { value: n });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader);
          const i = {};
          for (const t in this.extensions)
            !0 === this.extensions[t] && (i[t] = !0);
          return Object.keys(i).length > 0 && (e.extensions = i), e;
        }
      }
      nn.prototype.isShaderMaterial = !0;
      class rn extends Ke {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Ee()),
            (this.projectionMatrix = new Ee()),
            (this.projectionMatrixInverse = new Ee());
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      rn.prototype.isCamera = !0;
      class sn extends rn {
        constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = i),
            (this.far = n),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * yt * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(0.5 * gt * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return 2 * yt * Math.atan(Math.tan(0.5 * gt * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t, e, i, n, r, s) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = n),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = (t * Math.tan(0.5 * gt * this.fov)) / this.zoom,
            i = 2 * e,
            n = this.aspect * i,
            r = -0.5 * n;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = s.fullWidth,
              a = s.fullHeight;
            (r += (s.offsetX * n) / t),
              (e -= (s.offsetY * i) / a),
              (n *= s.width / t),
              (i *= s.height / a);
          }
          const a = this.filmOffset;
          0 !== a && (r += (t * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + n,
              e,
              e - i,
              t,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }
      sn.prototype.isPerspectiveCamera = !0;
      const an = 90;
      class on extends Ke {
        constructor(t, e, i) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            !0 !== i.isWebGLCubeRenderTarget)
          )
            return void console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
          this.renderTarget = i;
          const n = new sn(an, 1, t, e);
          (n.layers = this.layers),
            n.up.set(0, -1, 0),
            n.lookAt(new Jt(1, 0, 0)),
            this.add(n);
          const r = new sn(an, 1, t, e);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new Jt(-1, 0, 0)),
            this.add(r);
          const s = new sn(an, 1, t, e);
          (s.layers = this.layers),
            s.up.set(0, 0, 1),
            s.lookAt(new Jt(0, 1, 0)),
            this.add(s);
          const a = new sn(an, 1, t, e);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new Jt(0, -1, 0)),
            this.add(a);
          const o = new sn(an, 1, t, e);
          (o.layers = this.layers),
            o.up.set(0, -1, 0),
            o.lookAt(new Jt(0, 0, 1)),
            this.add(o);
          const l = new sn(an, 1, t, e);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new Jt(0, 0, -1)),
            this.add(l);
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld();
          const i = this.renderTarget,
            [n, r, s, a, o, l] = this.children,
            h = t.xr.enabled,
            c = t.getRenderTarget();
          t.xr.enabled = !1;
          const u = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            t.setRenderTarget(i, 0),
            t.render(e, n),
            t.setRenderTarget(i, 1),
            t.render(e, r),
            t.setRenderTarget(i, 2),
            t.render(e, s),
            t.setRenderTarget(i, 3),
            t.render(e, a),
            t.setRenderTarget(i, 4),
            t.render(e, o),
            (i.texture.generateMipmaps = u),
            t.setRenderTarget(i, 5),
            t.render(e, l),
            t.setRenderTarget(c),
            (t.xr.enabled = h),
            (i.texture.needsPMREMUpdate = !0);
        }
      }
      class ln extends Gt {
        constructor(t, e, i, n, s, a, o, l, h, c) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : r),
            i,
            n,
            s,
            a,
            o,
            l,
            h,
            c
          ),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      ln.prototype.isCubeTexture = !0;
      class hn extends jt {
        constructor(t, e, i) {
          Number.isInteger(e) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (e = i)),
            super(t, t, e),
            (e = e || {}),
            (this.texture = new ln(
              void 0,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : g);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.format = T),
            (this.texture.encoding = e.encoding),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          const i = { tEquirect: { value: null } },
            n =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            r =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            s = new Qi(5, 5, 5),
            a = new nn({
              name: "CubemapFromEquirect",
              uniforms: $i(i),
              vertexShader: n,
              fragmentShader: r,
              side: 1,
              blending: 0,
            });
          a.uniforms.tEquirect.value = e;
          const o = new Zi(s, a),
            l = e.minFilter;
          return (
            e.minFilter === x && (e.minFilter = g),
            new on(1, 10, this).update(t, o),
            (e.minFilter = l),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(t, e, i, n) {
          const r = t.getRenderTarget();
          for (let r = 0; r < 6; r++)
            t.setRenderTarget(this, r), t.clear(e, i, n);
          t.setRenderTarget(r);
        }
      }
      hn.prototype.isWebGLCubeRenderTarget = !0;
      const cn = new Jt(),
        un = new Jt(),
        dn = new At();
      class pn {
        constructor(t = new Jt(1, 0, 0), e = 0) {
          (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, i, n) {
          return this.normal.set(t, e, i), (this.constant = n), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, i) {
          const n = cn.subVectors(i, e).cross(un.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(t))
            .add(t);
        }
        intersectLine(t, e) {
          const i = t.delta(cn),
            n = this.normal.dot(i);
          if (0 === n)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / n;
          return r < 0 || r > 1
            ? null
            : e.copy(i).multiplyScalar(r).add(t.start);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            i = this.distanceToPoint(t.end);
          return (e < 0 && i > 0) || (i < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const i = e || dn.getNormalMatrix(t),
            n = this.coplanarPoint(cn).applyMatrix4(t),
            r = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -n.dot(r)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      pn.prototype.isPlane = !0;
      const mn = new ye(),
        fn = new Jt();
      class gn {
        constructor(
          t = new pn(),
          e = new pn(),
          i = new pn(),
          n = new pn(),
          r = new pn(),
          s = new pn()
        ) {
          this.planes = [t, e, i, n, r, s];
        }
        set(t, e, i, n, r, s) {
          const a = this.planes;
          return (
            a[0].copy(t),
            a[1].copy(e),
            a[2].copy(i),
            a[3].copy(n),
            a[4].copy(r),
            a[5].copy(s),
            this
          );
        }
        copy(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
          return this;
        }
        setFromProjectionMatrix(t) {
          const e = this.planes,
            i = t.elements,
            n = i[0],
            r = i[1],
            s = i[2],
            a = i[3],
            o = i[4],
            l = i[5],
            h = i[6],
            c = i[7],
            u = i[8],
            d = i[9],
            p = i[10],
            m = i[11],
            f = i[12],
            g = i[13],
            y = i[14],
            x = i[15];
          return (
            e[0].setComponents(a - n, c - o, m - u, x - f).normalize(),
            e[1].setComponents(a + n, c + o, m + u, x + f).normalize(),
            e[2].setComponents(a + r, c + l, m + d, x + g).normalize(),
            e[3].setComponents(a - r, c - l, m - d, x - g).normalize(),
            e[4].setComponents(a - s, c - h, m - p, x - y).normalize(),
            e[5].setComponents(a + s, c + h, m + p, x + y).normalize(),
            this
          );
        }
        intersectsObject(t) {
          const e = t.geometry;
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            mn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(mn)
          );
        }
        intersectsSprite(t) {
          return (
            mn.center.set(0, 0, 0),
            (mn.radius = 0.7071067811865476),
            mn.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(mn)
          );
        }
        intersectsSphere(t) {
          const e = this.planes,
            i = t.center,
            n = -t.radius;
          for (let t = 0; t < 6; t++)
            if (e[t].distanceToPoint(i) < n) return !1;
          return !0;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) {
            const n = e[i];
            if (
              ((fn.x = n.normal.x > 0 ? t.max.x : t.min.x),
              (fn.y = n.normal.y > 0 ? t.max.y : t.min.y),
              (fn.z = n.normal.z > 0 ? t.max.z : t.min.z),
              n.distanceToPoint(fn) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++)
            if (e[i].distanceToPoint(t) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function yn() {
        let t = null,
          e = !1,
          i = null,
          n = null;
        function r(e, s) {
          i(e, s), (n = t.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== i &&
              ((n = t.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            t.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (t) {
            i = t;
          },
          setContext: function (e) {
            t = e;
          },
        };
      }
      function xn(t, e) {
        const i = e.isWebGL2,
          n = new WeakMap();
        return {
          get: function (t) {
            return t.isInterleavedBufferAttribute && (t = t.data), n.get(t);
          },
          remove: function (e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            const i = n.get(e);
            i && (t.deleteBuffer(i.buffer), n.delete(e));
          },
          update: function (e, r) {
            if (e.isGLBufferAttribute) {
              const t = n.get(e);
              return void (
                (!t || t.version < e.version) &&
                n.set(e, {
                  buffer: e.buffer,
                  type: e.type,
                  bytesPerElement: e.elementSize,
                  version: e.version,
                })
              );
            }
            e.isInterleavedBufferAttribute && (e = e.data);
            const s = n.get(e);
            void 0 === s
              ? n.set(
                  e,
                  (function (e, n) {
                    const r = e.array,
                      s = e.usage,
                      a = t.createBuffer();
                    t.bindBuffer(n, a),
                      t.bufferData(n, r, s),
                      e.onUploadCallback();
                    let o = 5126;
                    return (
                      r instanceof Float32Array
                        ? (o = 5126)
                        : r instanceof Float64Array
                        ? console.warn(
                            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                          )
                        : r instanceof Uint16Array
                        ? e.isFloat16BufferAttribute
                          ? i
                            ? (o = 5131)
                            : console.warn(
                                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                              )
                          : (o = 5123)
                        : r instanceof Int16Array
                        ? (o = 5122)
                        : r instanceof Uint32Array
                        ? (o = 5125)
                        : r instanceof Int32Array
                        ? (o = 5124)
                        : r instanceof Int8Array
                        ? (o = 5120)
                        : (r instanceof Uint8Array ||
                            r instanceof Uint8ClampedArray) &&
                          (o = 5121),
                      {
                        buffer: a,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version,
                      }
                    );
                  })(e, r)
                )
              : s.version < e.version &&
                ((function (e, n, r) {
                  const s = n.array,
                    a = n.updateRange;
                  t.bindBuffer(r, e),
                    -1 === a.count
                      ? t.bufferSubData(r, 0, s)
                      : (i
                          ? t.bufferSubData(
                              r,
                              a.offset * s.BYTES_PER_ELEMENT,
                              s,
                              a.offset,
                              a.count
                            )
                          : t.bufferSubData(
                              r,
                              a.offset * s.BYTES_PER_ELEMENT,
                              s.subarray(a.offset, a.offset + a.count)
                            ),
                        (a.count = -1));
                })(s.buffer, e, r),
                (s.version = e.version));
          },
        };
      }
      class vn extends Ii {
        constructor(t = 1, e = 1, i = 1, n = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: i,
              heightSegments: n,
            });
          const r = t / 2,
            s = e / 2,
            a = Math.floor(i),
            o = Math.floor(n),
            l = a + 1,
            h = o + 1,
            c = t / a,
            u = e / o,
            d = [],
            p = [],
            m = [],
            f = [];
          for (let t = 0; t < h; t++) {
            const e = t * u - s;
            for (let i = 0; i < l; i++) {
              const n = i * c - r;
              p.push(n, -e, 0),
                m.push(0, 0, 1),
                f.push(i / a),
                f.push(1 - t / o);
            }
          }
          for (let t = 0; t < o; t++)
            for (let e = 0; e < a; e++) {
              const i = e + l * t,
                n = e + l * (t + 1),
                r = e + 1 + l * (t + 1),
                s = e + 1 + l * t;
              d.push(i, n, s), d.push(n, r, s);
            }
          this.setIndex(d),
            this.setAttribute("position", new wi(p, 3)),
            this.setAttribute("normal", new wi(m, 3)),
            this.setAttribute("uv", new wi(f, 2));
        }
        static fromJSON(t) {
          return new vn(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      const _n = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          output_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        },
        bn = {
          common: {
            diffuse: { value: new Ft(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new At() },
            uv2Transform: { value: new At() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Et(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ft(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ft(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new At() },
          },
          sprite: {
            diffuse: { value: new Ft(16777215) },
            opacity: { value: 1 },
            center: { value: new Et(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new At() },
          },
        },
        Mn = {
          basic: {
            uniforms: tn([
              bn.common,
              bn.specularmap,
              bn.envmap,
              bn.aomap,
              bn.lightmap,
              bn.fog,
            ]),
            vertexShader: _n.meshbasic_vert,
            fragmentShader: _n.meshbasic_frag,
          },
          lambert: {
            uniforms: tn([
              bn.common,
              bn.specularmap,
              bn.envmap,
              bn.aomap,
              bn.lightmap,
              bn.emissivemap,
              bn.fog,
              bn.lights,
              { emissive: { value: new Ft(0) } },
            ]),
            vertexShader: _n.meshlambert_vert,
            fragmentShader: _n.meshlambert_frag,
          },
          phong: {
            uniforms: tn([
              bn.common,
              bn.specularmap,
              bn.envmap,
              bn.aomap,
              bn.lightmap,
              bn.emissivemap,
              bn.bumpmap,
              bn.normalmap,
              bn.displacementmap,
              bn.fog,
              bn.lights,
              {
                emissive: { value: new Ft(0) },
                specular: { value: new Ft(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: _n.meshphong_vert,
            fragmentShader: _n.meshphong_frag,
          },
          standard: {
            uniforms: tn([
              bn.common,
              bn.envmap,
              bn.aomap,
              bn.lightmap,
              bn.emissivemap,
              bn.bumpmap,
              bn.normalmap,
              bn.displacementmap,
              bn.roughnessmap,
              bn.metalnessmap,
              bn.fog,
              bn.lights,
              {
                emissive: { value: new Ft(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: _n.meshphysical_vert,
            fragmentShader: _n.meshphysical_frag,
          },
          toon: {
            uniforms: tn([
              bn.common,
              bn.aomap,
              bn.lightmap,
              bn.emissivemap,
              bn.bumpmap,
              bn.normalmap,
              bn.displacementmap,
              bn.gradientmap,
              bn.fog,
              bn.lights,
              { emissive: { value: new Ft(0) } },
            ]),
            vertexShader: _n.meshtoon_vert,
            fragmentShader: _n.meshtoon_frag,
          },
          matcap: {
            uniforms: tn([
              bn.common,
              bn.bumpmap,
              bn.normalmap,
              bn.displacementmap,
              bn.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: _n.meshmatcap_vert,
            fragmentShader: _n.meshmatcap_frag,
          },
          points: {
            uniforms: tn([bn.points, bn.fog]),
            vertexShader: _n.points_vert,
            fragmentShader: _n.points_frag,
          },
          dashed: {
            uniforms: tn([
              bn.common,
              bn.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: _n.linedashed_vert,
            fragmentShader: _n.linedashed_frag,
          },
          depth: {
            uniforms: tn([bn.common, bn.displacementmap]),
            vertexShader: _n.depth_vert,
            fragmentShader: _n.depth_frag,
          },
          normal: {
            uniforms: tn([
              bn.common,
              bn.bumpmap,
              bn.normalmap,
              bn.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: _n.meshnormal_vert,
            fragmentShader: _n.meshnormal_frag,
          },
          sprite: {
            uniforms: tn([bn.sprite, bn.fog]),
            vertexShader: _n.sprite_vert,
            fragmentShader: _n.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new At() },
              t2D: { value: null },
            },
            vertexShader: _n.background_vert,
            fragmentShader: _n.background_frag,
          },
          cube: {
            uniforms: tn([bn.envmap, { opacity: { value: 1 } }]),
            vertexShader: _n.cube_vert,
            fragmentShader: _n.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: _n.equirect_vert,
            fragmentShader: _n.equirect_frag,
          },
          distanceRGBA: {
            uniforms: tn([
              bn.common,
              bn.displacementmap,
              {
                referencePosition: { value: new Jt() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: _n.distanceRGBA_vert,
            fragmentShader: _n.distanceRGBA_frag,
          },
          shadow: {
            uniforms: tn([
              bn.lights,
              bn.fog,
              { color: { value: new Ft(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: _n.shadow_vert,
            fragmentShader: _n.shadow_frag,
          },
        };
      function wn(t, e, i, n, r, s) {
        const a = new Ft(0);
        let o,
          h,
          c = !0 === r ? 0 : 1,
          u = null,
          d = 0,
          p = null;
        function m(t, e) {
          i.buffers.color.setClear(t.r, t.g, t.b, e, s);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (t, e = 1) {
            a.set(t), (c = e), m(a, c);
          },
          getClearAlpha: function () {
            return c;
          },
          setClearAlpha: function (t) {
            (c = t), m(a, c);
          },
          render: function (i, r) {
            let s = !1,
              f = !0 === r.isScene ? r.background : null;
            f && f.isTexture && (f = e.get(f));
            const g = t.xr,
              y = g.getSession && g.getSession();
            y && "additive" === y.environmentBlendMode && (f = null),
              null === f ? m(a, c) : f && f.isColor && (m(f, 1), (s = !0)),
              (t.autoClear || s) &&
                t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              f && (f.isCubeTexture || f.mapping === l)
                ? (void 0 === h &&
                    ((h = new Zi(
                      new Qi(1, 1, 1),
                      new nn({
                        name: "BackgroundCubeMaterial",
                        uniforms: $i(Mn.cube.uniforms),
                        vertexShader: Mn.cube.vertexShader,
                        fragmentShader: Mn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    h.geometry.deleteAttribute("normal"),
                    h.geometry.deleteAttribute("uv"),
                    (h.onBeforeRender = function (t, e, i) {
                      this.matrixWorld.copyPosition(i.matrixWorld);
                    }),
                    Object.defineProperty(h.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    n.update(h)),
                  (h.material.uniforms.envMap.value = f),
                  (h.material.uniforms.flipEnvMap.value =
                    f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
                  (u === f && d === f.version && p === t.toneMapping) ||
                    ((h.material.needsUpdate = !0),
                    (u = f),
                    (d = f.version),
                    (p = t.toneMapping)),
                  i.unshift(h, h.geometry, h.material, 0, 0, null))
                : f &&
                  f.isTexture &&
                  (void 0 === o &&
                    ((o = new Zi(
                      new vn(2, 2),
                      new nn({
                        name: "BackgroundMaterial",
                        uniforms: $i(Mn.background.uniforms),
                        vertexShader: Mn.background.vertexShader,
                        fragmentShader: Mn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    o.geometry.deleteAttribute("normal"),
                    Object.defineProperty(o.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    n.update(o)),
                  (o.material.uniforms.t2D.value = f),
                  !0 === f.matrixAutoUpdate && f.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(f.matrix),
                  (u === f && d === f.version && p === t.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                    (u = f),
                    (d = f.version),
                    (p = t.toneMapping)),
                  i.unshift(o, o.geometry, o.material, 0, 0, null));
          },
        };
      }
      function Sn(t, e, i, n) {
        const r = t.getParameter(34921),
          s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          a = n.isWebGL2 || null !== s,
          o = {},
          l = d(null);
        let h = l;
        function c(e) {
          return n.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
        }
        function u(e) {
          return n.isWebGL2
            ? t.deleteVertexArray(e)
            : s.deleteVertexArrayOES(e);
        }
        function d(t) {
          const e = [],
            i = [],
            n = [];
          for (let t = 0; t < r; t++) (e[t] = 0), (i[t] = 0), (n[t] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: i,
            attributeDivisors: n,
            object: t,
            attributes: {},
            index: null,
          };
        }
        function p() {
          const t = h.newAttributes;
          for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
        }
        function m(t) {
          f(t, 0);
        }
        function f(i, r) {
          const s = h.newAttributes,
            a = h.enabledAttributes,
            o = h.attributeDivisors;
          (s[i] = 1),
            0 === a[i] && (t.enableVertexAttribArray(i), (a[i] = 1)),
            o[i] !== r &&
              ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](i, r),
              (o[i] = r));
        }
        function g() {
          const e = h.newAttributes,
            i = h.enabledAttributes;
          for (let n = 0, r = i.length; n < r; n++)
            i[n] !== e[n] && (t.disableVertexAttribArray(n), (i[n] = 0));
        }
        function y(e, i, r, s, a, o) {
          !0 !== n.isWebGL2 || (5124 !== r && 5125 !== r)
            ? t.vertexAttribPointer(e, i, r, s, a, o)
            : t.vertexAttribIPointer(e, i, r, a, o);
        }
        function x() {
          v(), h !== l && ((h = l), c(h.object));
        }
        function v() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function (r, l, u, x, v) {
            let _ = !1;
            if (a) {
              const e = (function (e, i, r) {
                const a = !0 === r.wireframe;
                let l = o[e.id];
                void 0 === l && ((l = {}), (o[e.id] = l));
                let h = l[i.id];
                void 0 === h && ((h = {}), (l[i.id] = h));
                let c = h[a];
                return (
                  void 0 === c &&
                    ((c = d(
                      n.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                    (h[a] = c)),
                  c
                );
              })(x, u, l);
              h !== e && ((h = e), c(h.object)),
                (_ = (function (t, e) {
                  const i = h.attributes,
                    n = t.attributes;
                  let r = 0;
                  for (const t in n) {
                    const e = i[t],
                      s = n[t];
                    if (void 0 === e) return !0;
                    if (e.attribute !== s) return !0;
                    if (e.data !== s.data) return !0;
                    r++;
                  }
                  return h.attributesNum !== r || h.index !== e;
                })(x, v)),
                _ &&
                  (function (t, e) {
                    const i = {},
                      n = t.attributes;
                    let r = 0;
                    for (const t in n) {
                      const e = n[t],
                        s = {};
                      (s.attribute = e),
                        e.data && (s.data = e.data),
                        (i[t] = s),
                        r++;
                    }
                    (h.attributes = i), (h.attributesNum = r), (h.index = e);
                  })(x, v);
            } else {
              const t = !0 === l.wireframe;
              (h.geometry === x.id &&
                h.program === u.id &&
                h.wireframe === t) ||
                ((h.geometry = x.id),
                (h.program = u.id),
                (h.wireframe = t),
                (_ = !0));
            }
            !0 === r.isInstancedMesh && (_ = !0),
              null !== v && i.update(v, 34963),
              _ &&
                ((function (r, s, a, o) {
                  if (
                    !1 === n.isWebGL2 &&
                    (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  p();
                  const l = o.attributes,
                    h = a.getAttributes(),
                    c = s.defaultAttributeValues;
                  for (const e in h) {
                    const n = h[e];
                    if (n.location >= 0) {
                      let s = l[e];
                      if (
                        (void 0 === s &&
                          ("instanceMatrix" === e &&
                            r.instanceMatrix &&
                            (s = r.instanceMatrix),
                          "instanceColor" === e &&
                            r.instanceColor &&
                            (s = r.instanceColor)),
                        void 0 !== s)
                      ) {
                        const e = s.normalized,
                          a = s.itemSize,
                          l = i.get(s);
                        if (void 0 === l) continue;
                        const h = l.buffer,
                          c = l.type,
                          u = l.bytesPerElement;
                        if (s.isInterleavedBufferAttribute) {
                          const i = s.data,
                            l = i.stride,
                            d = s.offset;
                          if (i && i.isInstancedInterleavedBuffer) {
                            for (let t = 0; t < n.locationSize; t++)
                              f(n.location + t, i.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                i.meshPerAttribute * i.count);
                          } else
                            for (let t = 0; t < n.locationSize; t++)
                              m(n.location + t);
                          t.bindBuffer(34962, h);
                          for (let t = 0; t < n.locationSize; t++)
                            y(
                              n.location + t,
                              a / n.locationSize,
                              c,
                              e,
                              l * u,
                              (d + (a / n.locationSize) * t) * u
                            );
                        } else {
                          if (s.isInstancedBufferAttribute) {
                            for (let t = 0; t < n.locationSize; t++)
                              f(n.location + t, s.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                s.meshPerAttribute * s.count);
                          } else
                            for (let t = 0; t < n.locationSize; t++)
                              m(n.location + t);
                          t.bindBuffer(34962, h);
                          for (let t = 0; t < n.locationSize; t++)
                            y(
                              n.location + t,
                              a / n.locationSize,
                              c,
                              e,
                              a * u,
                              (a / n.locationSize) * t * u
                            );
                        }
                      } else if (void 0 !== c) {
                        const i = c[e];
                        if (void 0 !== i)
                          switch (i.length) {
                            case 2:
                              t.vertexAttrib2fv(n.location, i);
                              break;
                            case 3:
                              t.vertexAttrib3fv(n.location, i);
                              break;
                            case 4:
                              t.vertexAttrib4fv(n.location, i);
                              break;
                            default:
                              t.vertexAttrib1fv(n.location, i);
                          }
                      }
                    }
                  }
                  g();
                })(r, l, u, x),
                null !== v && t.bindBuffer(34963, i.get(v).buffer));
          },
          reset: x,
          resetDefaultState: v,
          dispose: function () {
            x();
            for (const t in o) {
              const e = o[t];
              for (const t in e) {
                const i = e[t];
                for (const t in i) u(i[t].object), delete i[t];
                delete e[t];
              }
              delete o[t];
            }
          },
          releaseStatesOfGeometry: function (t) {
            if (void 0 === o[t.id]) return;
            const e = o[t.id];
            for (const t in e) {
              const i = e[t];
              for (const t in i) u(i[t].object), delete i[t];
              delete e[t];
            }
            delete o[t.id];
          },
          releaseStatesOfProgram: function (t) {
            for (const e in o) {
              const i = o[e];
              if (void 0 === i[t.id]) continue;
              const n = i[t.id];
              for (const t in n) u(n[t].object), delete n[t];
              delete i[t.id];
            }
          },
          initAttributes: p,
          enableAttribute: m,
          disableUnusedAttributes: g,
        };
      }
      function Tn(t, e, i, n) {
        const r = n.isWebGL2;
        let s;
        (this.setMode = function (t) {
          s = t;
        }),
          (this.render = function (e, n) {
            t.drawArrays(s, e, n), i.update(n, s, 1);
          }),
          (this.renderInstances = function (n, a, o) {
            if (0 === o) return;
            let l, h;
            if (r) (l = t), (h = "drawArraysInstanced");
            else if (
              ((l = e.get("ANGLE_instanced_arrays")),
              (h = "drawArraysInstancedANGLE"),
              null === l)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            l[h](s, n, a, o), i.update(a, s, o);
          });
      }
      function En(t, e, i) {
        let n;
        function r(e) {
          if ("highp" === e) {
            if (
              t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            e = "mediump";
          }
          return "mediump" === e &&
            t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const s =
          ("undefined" != typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext) ||
          ("undefined" != typeof WebGL2ComputeRenderingContext &&
            t instanceof WebGL2ComputeRenderingContext);
        let a = void 0 !== i.precision ? i.precision : "highp";
        const o = r(a);
        o !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            o,
            "instead."
          ),
          (a = o));
        const l = s || e.has("WEBGL_draw_buffers"),
          h = !0 === i.logarithmicDepthBuffer,
          c = t.getParameter(34930),
          u = t.getParameter(35660),
          d = t.getParameter(3379),
          p = t.getParameter(34076),
          m = t.getParameter(34921),
          f = t.getParameter(36347),
          g = t.getParameter(36348),
          y = t.getParameter(36349),
          x = u > 0,
          v = s || e.has("OES_texture_float");
        return {
          isWebGL2: s,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== n) return n;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
              const i = e.get("EXT_texture_filter_anisotropic");
              n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else n = 0;
            return n;
          },
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: h,
          maxTextures: c,
          maxVertexTextures: u,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: m,
          maxVertexUniforms: f,
          maxVaryings: g,
          maxFragmentUniforms: y,
          vertexTextures: x,
          floatFragmentTextures: v,
          floatVertexTextures: x && v,
          maxSamples: s ? t.getParameter(36183) : 0,
        };
      }
      function An(t) {
        const e = this;
        let i = null,
          n = 0,
          r = !1,
          s = !1;
        const a = new pn(),
          o = new At(),
          l = { value: null, needsUpdate: !1 };
        function h() {
          l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function c(t, i, n, r) {
          const s = null !== t ? t.length : 0;
          let h = null;
          if (0 !== s) {
            if (((h = l.value), !0 !== r || null === h)) {
              const e = n + 4 * s,
                r = i.matrixWorldInverse;
              o.getNormalMatrix(r),
                (null === h || h.length < e) && (h = new Float32Array(e));
              for (let e = 0, i = n; e !== s; ++e, i += 4)
                a.copy(t[e]).applyMatrix4(r, o),
                  a.normal.toArray(h, i),
                  (h[i + 3] = a.constant);
            }
            (l.value = h), (l.needsUpdate = !0);
          }
          return (e.numPlanes = s), (e.numIntersection = 0), h;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e, s) {
            const a = 0 !== t.length || e || 0 !== n || r;
            return (r = e), (i = c(t, s, 0)), (n = t.length), a;
          }),
          (this.beginShadows = function () {
            (s = !0), c(null);
          }),
          (this.endShadows = function () {
            (s = !1), h();
          }),
          (this.setState = function (e, a, o) {
            const u = e.clippingPlanes,
              d = e.clipIntersection,
              p = e.clipShadows,
              m = t.get(e);
            if (!r || null === u || 0 === u.length || (s && !p))
              s ? c(null) : h();
            else {
              const t = s ? 0 : n,
                e = 4 * t;
              let r = m.clippingState || null;
              (l.value = r), (r = c(u, a, e, o));
              for (let t = 0; t !== e; ++t) r[t] = i[t];
              (m.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += t);
            }
          });
      }
      function Rn(t) {
        let e = new WeakMap();
        function i(t, e) {
          return e === a ? (t.mapping = r) : e === o && (t.mapping = s), t;
        }
        function n(t) {
          const i = t.target;
          i.removeEventListener("dispose", n);
          const r = e.get(i);
          void 0 !== r && (e.delete(i), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const s = r.mapping;
              if (s === a || s === o) {
                if (e.has(r)) return i(e.get(r).texture, r.mapping);
                {
                  const s = r.image;
                  if (s && s.height > 0) {
                    const a = new hn(s.height / 2);
                    return (
                      a.fromEquirectangularTexture(t, r),
                      e.set(r, a),
                      r.addEventListener("dispose", n),
                      i(a.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      Mn.physical = {
        uniforms: tn([
          Mn.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Et(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new Ft(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Et() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ft(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new Ft(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: _n.meshphysical_vert,
        fragmentShader: _n.meshphysical_frag,
      };
      class Ln extends rn {
        constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, s = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = i),
            (this.bottom = n),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, i, n, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = n),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            n = (this.top + this.bottom) / 2;
          let r = i - t,
            s = i + t,
            a = n + e,
            o = n - e;
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += t * this.view.offsetX),
              (s = r + t * this.view.width),
              (a -= e * this.view.offsetY),
              (o = a - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            a,
            o,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      }
      Ln.prototype.isOrthographicCamera = !0;
      class Cn extends nn {
        constructor(t) {
          super(t), (this.type = "RawShaderMaterial");
        }
      }
      Cn.prototype.isRawShaderMaterial = !0;
      const Pn = Math.pow(2, 8),
        In = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        zn = 5 + In.length,
        Dn = new Ln(),
        {
          _lodPlanes: Nn,
          _sizeLods: On,
          _sigmas: Bn,
        } = (function () {
          const t = [],
            e = [],
            i = [];
          let n = 8;
          for (let r = 0; r < zn; r++) {
            const s = Math.pow(2, n);
            e.push(s);
            let a = 1 / s;
            r > 4 ? (a = In[r - 8 + 4 - 1]) : 0 === r && (a = 0), i.push(a);
            const o = 1 / (s - 1),
              l = -o / 2,
              h = 1 + o / 2,
              c = [l, l, h, l, h, h, l, l, h, h, l, h],
              u = 6,
              d = 6,
              p = 3,
              m = 2,
              f = 1,
              g = new Float32Array(p * d * u),
              y = new Float32Array(m * d * u),
              x = new Float32Array(f * d * u);
            for (let t = 0; t < u; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                i = t > 2 ? 0 : -1,
                n = [
                  e,
                  i,
                  0,
                  e + 2 / 3,
                  i,
                  0,
                  e + 2 / 3,
                  i + 1,
                  0,
                  e,
                  i,
                  0,
                  e + 2 / 3,
                  i + 1,
                  0,
                  e,
                  i + 1,
                  0,
                ];
              g.set(n, p * d * t), y.set(c, m * d * t);
              const r = [t, t, t, t, t, t];
              x.set(r, f * d * t);
            }
            const v = new Ii();
            v.setAttribute("position", new mi(g, p)),
              v.setAttribute("uv", new mi(y, m)),
              v.setAttribute("faceIndex", new mi(x, f)),
              t.push(v),
              n > 4 && n--;
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: i };
        })(),
        Fn = new Ft();
      let Hn = null;
      const Un = (1 + Math.sqrt(5)) / 2,
        kn = 1 / Un,
        Gn = [
          new Jt(1, 1, 1),
          new Jt(-1, 1, 1),
          new Jt(1, 1, -1),
          new Jt(-1, 1, -1),
          new Jt(0, Un, kn),
          new Jt(0, Un, -kn),
          new Jt(kn, 0, Un),
          new Jt(-kn, 0, Un),
          new Jt(Un, kn, 0),
          new Jt(-Un, kn, 0),
        ];
      class Vn {
        constructor(t) {
          (this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = (function (t) {
              const e = new Float32Array(20),
                i = new Jt(0, 1, 0);
              return new Cn({
                name: "SphericalGaussianBlur",
                defines: { n: 20 },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: e },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: i },
                },
                vertexShader:
                  "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              });
            })()),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, i = 0.1, n = 100) {
          Hn = this._renderer.getRenderTarget();
          const r = this._allocateTargets();
          return (
            this._sceneToCubeUV(t, i, n, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          null === this._cubemapShader &&
            ((this._cubemapShader = Xn()),
            this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          null === this._equirectShader &&
            ((this._equirectShader = qn()),
            this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose();
          for (let t = 0; t < Nn.length; t++) Nn[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(Hn),
            (t.scissorTest = !1),
            jn(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          Hn = this._renderer.getRenderTarget();
          const i = e || this._allocateTargets(t);
          return (
            this._textureToCubeUV(t, i),
            this._applyPMREM(i),
            this._cleanup(i),
            i
          );
        }
        _allocateTargets(t) {
          const e = {
              magFilter: g,
              minFilter: g,
              generateMipmaps: !1,
              type: w,
              format: T,
              encoding: at,
              depthBuffer: !1,
            },
            i = Wn(e);
          return (
            (i.depthBuffer = !t),
            null === this._pingPongRenderTarget &&
              (this._pingPongRenderTarget = Wn(e)),
            i
          );
        }
        _compileMaterial(t) {
          const e = new Zi(Nn[0], t);
          this._renderer.compile(e, Dn);
        }
        _sceneToCubeUV(t, e, i, n) {
          const r = new sn(90, 1, e, i),
            s = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            o = this._renderer,
            l = o.autoClear,
            h = o.toneMapping;
          o.getClearColor(Fn), (o.toneMapping = 0), (o.autoClear = !1);
          const c = new ui({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1,
            }),
            u = new Zi(new Qi(), c);
          let d = !1;
          const p = t.background;
          p
            ? p.isColor && (c.color.copy(p), (t.background = null), (d = !0))
            : (c.color.copy(Fn), (d = !0));
          for (let e = 0; e < 6; e++) {
            const i = e % 3;
            0 === i
              ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
              : 1 === i
              ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
              : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])),
              jn(n, i * Pn, e > 2 ? Pn : 0, Pn, Pn),
              o.setRenderTarget(n),
              d && o.render(u, r),
              o.render(t, r);
          }
          u.geometry.dispose(),
            u.material.dispose(),
            (o.toneMapping = h),
            (o.autoClear = l),
            (t.background = p);
        }
        _textureToCubeUV(t, e) {
          const i = this._renderer,
            n = t.mapping === r || t.mapping === s;
          n
            ? (null === this._cubemapShader && (this._cubemapShader = Xn()),
              (this._cubemapShader.uniforms.flipEnvMap.value =
                !1 === t.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectShader && (this._equirectShader = qn());
          const a = n ? this._cubemapShader : this._equirectShader,
            o = new Zi(Nn[0], a),
            l = a.uniforms;
          (l.envMap.value = t),
            n || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
            jn(e, 0, 0, 3 * Pn, 2 * Pn),
            i.setRenderTarget(e),
            i.render(o, Dn);
        }
        _applyPMREM(t) {
          const e = this._renderer,
            i = e.autoClear;
          e.autoClear = !1;
          for (let e = 1; e < zn; e++) {
            const i = Math.sqrt(Bn[e] * Bn[e] - Bn[e - 1] * Bn[e - 1]),
              n = Gn[(e - 1) % Gn.length];
            this._blur(t, e - 1, e, i, n);
          }
          e.autoClear = i;
        }
        _blur(t, e, i, n, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(t, s, e, i, n, "latitudinal", r),
            this._halfBlur(s, t, i, i, n, "longitudinal", r);
        }
        _halfBlur(t, e, i, n, r, s, a) {
          const o = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== s &&
            "longitudinal" !== s &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const h = new Zi(Nn[n], l),
            c = l.uniforms,
            u = On[i] - 1,
            d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
            p = r / d,
            m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
          m > 20 &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
            );
          const f = [];
          let g = 0;
          for (let t = 0; t < 20; ++t) {
            const e = t / p,
              i = Math.exp((-e * e) / 2);
            f.push(i), 0 === t ? (g += i) : t < m && (g += 2 * i);
          }
          for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
          (c.envMap.value = t.texture),
            (c.samples.value = m),
            (c.weights.value = f),
            (c.latitudinal.value = "latitudinal" === s),
            a && (c.poleAxis.value = a),
            (c.dTheta.value = d),
            (c.mipInt.value = 8 - i);
          const y = On[n];
          jn(
            e,
            3 * Math.max(0, Pn - 2 * y),
            (0 === n ? 0 : 2 * Pn) + 2 * y * (n > 4 ? n - 8 + 4 : 0),
            3 * y,
            2 * y
          ),
            o.setRenderTarget(e),
            o.render(h, Dn);
        }
      }
      function Wn(t) {
        const e = new jt(3 * Pn, 3 * Pn, t);
        return (
          (e.texture.mapping = l),
          (e.texture.name = "PMREM.cubeUv"),
          (e.scissorTest = !0),
          e
        );
      }
      function jn(t, e, i, n, r) {
        t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r);
      }
      function qn() {
        const t = new Et(1, 1);
        return new Cn({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null }, texelSize: { value: t } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Xn() {
        return new Cn({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Yn(t) {
        let e = new WeakMap(),
          i = null;
        function n(t) {
          const i = t.target;
          i.removeEventListener("dispose", n);
          const r = e.get(i);
          void 0 !== r && (e.delete(i), r.dispose());
        }
        return {
          get: function (l) {
            if (l && l.isTexture) {
              const h = l.mapping,
                c = h === a || h === o,
                u = h === r || h === s;
              if (c || u) {
                if (l.isRenderTargetTexture && !0 === l.needsPMREMUpdate) {
                  l.needsPMREMUpdate = !1;
                  let n = e.get(l);
                  return (
                    null === i && (i = new Vn(t)),
                    (n = c ? i.fromEquirectangular(l, n) : i.fromCubemap(l, n)),
                    e.set(l, n),
                    n.texture
                  );
                }
                if (e.has(l)) return e.get(l).texture;
                {
                  const r = l.image;
                  if (
                    (c && r && r.height > 0) ||
                    (u &&
                      r &&
                      (function (t) {
                        let e = 0;
                        for (let i = 0; i < 6; i++) void 0 !== t[i] && e++;
                        return 6 === e;
                      })(r))
                  ) {
                    null === i && (i = new Vn(t));
                    const r = c ? i.fromEquirectangular(l) : i.fromCubemap(l);
                    return (
                      e.set(l, r), l.addEventListener("dispose", n), r.texture
                    );
                  }
                  return null;
                }
              }
            }
            return l;
          },
          dispose: function () {
            (e = new WeakMap()), null !== i && (i.dispose(), (i = null));
          },
        };
      }
      function Jn(t) {
        const e = {};
        function i(i) {
          if (void 0 !== e[i]) return e[i];
          let n;
          switch (i) {
            case "WEBGL_depth_texture":
              n =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n = t.getExtension(i);
          }
          return (e[i] = n), n;
        }
        return {
          has: function (t) {
            return null !== i(t);
          },
          init: function (t) {
            t.isWebGL2
              ? i("EXT_color_buffer_float")
              : (i("WEBGL_depth_texture"),
                i("OES_texture_float"),
                i("OES_texture_half_float"),
                i("OES_texture_half_float_linear"),
                i("OES_standard_derivatives"),
                i("OES_element_index_uint"),
                i("OES_vertex_array_object"),
                i("ANGLE_instanced_arrays")),
              i("OES_texture_float_linear"),
              i("EXT_color_buffer_half_float"),
              i("WEBGL_multisampled_render_to_texture");
          },
          get: function (t) {
            const e = i(t);
            return (
              null === e &&
                console.warn(
                  "THREE.WebGLRenderer: " + t + " extension not supported."
                ),
              e
            );
          },
        };
      }
      function Zn(t, e, i, n) {
        const r = {},
          s = new WeakMap();
        function a(t) {
          const o = t.target;
          null !== o.index && e.remove(o.index);
          for (const t in o.attributes) e.remove(o.attributes[t]);
          o.removeEventListener("dispose", a), delete r[o.id];
          const l = s.get(o);
          l && (e.remove(l), s.delete(o)),
            n.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            i.memory.geometries--;
        }
        function o(t) {
          const i = [],
            n = t.index,
            r = t.attributes.position;
          let a = 0;
          if (null !== n) {
            const t = n.array;
            a = n.version;
            for (let e = 0, n = t.length; e < n; e += 3) {
              const n = t[e + 0],
                r = t[e + 1],
                s = t[e + 2];
              i.push(n, r, r, s, s, n);
            }
          } else {
            const t = r.array;
            a = r.version;
            for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
              const t = e + 0,
                n = e + 1,
                r = e + 2;
              i.push(t, n, n, r, r, t);
            }
          }
          const o = new (Rt(i) ? bi : vi)(i, 1);
          o.version = a;
          const l = s.get(t);
          l && e.remove(l), s.set(t, o);
        }
        return {
          get: function (t, e) {
            return (
              !0 === r[e.id] ||
                (e.addEventListener("dispose", a),
                (r[e.id] = !0),
                i.memory.geometries++),
              e
            );
          },
          update: function (t) {
            const i = t.attributes;
            for (const t in i) e.update(i[t], 34962);
            const n = t.morphAttributes;
            for (const t in n) {
              const i = n[t];
              for (let t = 0, n = i.length; t < n; t++) e.update(i[t], 34962);
            }
          },
          getWireframeAttribute: function (t) {
            const e = s.get(t);
            if (e) {
              const i = t.index;
              null !== i && e.version < i.version && o(t);
            } else o(t);
            return s.get(t);
          },
        };
      }
      function Kn(t, e, i, n) {
        const r = n.isWebGL2;
        let s, a, o;
        (this.setMode = function (t) {
          s = t;
        }),
          (this.setIndex = function (t) {
            (a = t.type), (o = t.bytesPerElement);
          }),
          (this.render = function (e, n) {
            t.drawElements(s, n, a, e * o), i.update(n, s, 1);
          }),
          (this.renderInstances = function (n, l, h) {
            if (0 === h) return;
            let c, u;
            if (r) (c = t), (u = "drawElementsInstanced");
            else if (
              ((c = e.get("ANGLE_instanced_arrays")),
              (u = "drawElementsInstancedANGLE"),
              null === c)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            c[u](s, l, a, n * o, h), i.update(l, s, h);
          });
      }
      function Qn(t) {
        const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: e,
          programs: null,
          autoReset: !0,
          reset: function () {
            e.frame++,
              (e.calls = 0),
              (e.triangles = 0),
              (e.points = 0),
              (e.lines = 0);
          },
          update: function (t, i, n) {
            switch ((e.calls++, i)) {
              case 4:
                e.triangles += n * (t / 3);
                break;
              case 1:
                e.lines += n * (t / 2);
                break;
              case 3:
                e.lines += n * (t - 1);
                break;
              case 2:
                e.lines += n * t;
                break;
              case 0:
                e.points += n * t;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", i);
            }
          },
        };
      }
      class $n extends Gt {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null),
            (this.image = { data: t, width: e, height: i, depth: n }),
            (this.magFilter = p),
            (this.minFilter = p),
            (this.wrapR = u),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      function tr(t, e) {
        return t[0] - e[0];
      }
      function er(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1]);
      }
      function ir(t, e) {
        let i = 1;
        const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        n instanceof Int8Array
          ? (i = 127)
          : n instanceof Int16Array
          ? (i = 32767)
          : n instanceof Int32Array
          ? (i = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              n
            ),
          t.divideScalar(i);
      }
      function nr(t, e, i) {
        const n = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          a = new Jt(),
          o = [];
        for (let t = 0; t < 8; t++) o[t] = [t, 0];
        return {
          update: function (l, h, c, u) {
            const d = l.morphTargetInfluences;
            if (!0 === e.isWebGL2) {
              const n = h.morphAttributes.position.length;
              let r = s.get(h);
              if (void 0 === r || r.count !== n) {
                void 0 !== r && r.texture.dispose();
                const t = void 0 !== h.morphAttributes.normal,
                  i = h.morphAttributes.position,
                  o = h.morphAttributes.normal || [],
                  l = !0 === t ? 2 : 1;
                let c = h.attributes.position.count * l,
                  u = 1;
                c > e.maxTextureSize &&
                  ((u = Math.ceil(c / e.maxTextureSize)),
                  (c = e.maxTextureSize));
                const d = new Float32Array(c * u * 4 * n),
                  p = new $n(d, c, u, n);
                (p.format = T), (p.type = M), (p.needsUpdate = !0);
                const m = 4 * l;
                for (let e = 0; e < n; e++) {
                  const n = i[e],
                    r = o[e],
                    s = c * u * 4 * e;
                  for (let e = 0; e < n.count; e++) {
                    a.fromBufferAttribute(n, e),
                      !0 === n.normalized && ir(a, n);
                    const i = e * m;
                    (d[s + i + 0] = a.x),
                      (d[s + i + 1] = a.y),
                      (d[s + i + 2] = a.z),
                      (d[s + i + 3] = 0),
                      !0 === t &&
                        (a.fromBufferAttribute(r, e),
                        !0 === r.normalized && ir(a, r),
                        (d[s + i + 4] = a.x),
                        (d[s + i + 5] = a.y),
                        (d[s + i + 6] = a.z),
                        (d[s + i + 7] = 0));
                  }
                }
                function f() {
                  p.dispose(), s.delete(h), h.removeEventListener("dispose", f);
                }
                (r = { count: n, texture: p, size: new Et(c, u) }),
                  s.set(h, r),
                  h.addEventListener("dispose", f);
              }
              let o = 0;
              for (let t = 0; t < d.length; t++) o += d[t];
              const l = h.morphTargetsRelative ? 1 : 1 - o;
              u.getUniforms().setValue(t, "morphTargetBaseInfluence", l),
                u.getUniforms().setValue(t, "morphTargetInfluences", d),
                u
                  .getUniforms()
                  .setValue(t, "morphTargetsTexture", r.texture, i),
                u.getUniforms().setValue(t, "morphTargetsTextureSize", r.size);
            } else {
              const e = void 0 === d ? 0 : d.length;
              let i = n[h.id];
              if (void 0 === i || i.length !== e) {
                i = [];
                for (let t = 0; t < e; t++) i[t] = [t, 0];
                n[h.id] = i;
              }
              for (let t = 0; t < e; t++) {
                const e = i[t];
                (e[0] = t), (e[1] = d[t]);
              }
              i.sort(er);
              for (let t = 0; t < 8; t++)
                t < e && i[t][1]
                  ? ((o[t][0] = i[t][0]), (o[t][1] = i[t][1]))
                  : ((o[t][0] = Number.MAX_SAFE_INTEGER), (o[t][1] = 0));
              o.sort(tr);
              const s = h.morphAttributes.position,
                a = h.morphAttributes.normal;
              let l = 0;
              for (let t = 0; t < 8; t++) {
                const e = o[t],
                  i = e[0],
                  n = e[1];
                i !== Number.MAX_SAFE_INTEGER && n
                  ? (s &&
                      h.getAttribute("morphTarget" + t) !== s[i] &&
                      h.setAttribute("morphTarget" + t, s[i]),
                    a &&
                      h.getAttribute("morphNormal" + t) !== a[i] &&
                      h.setAttribute("morphNormal" + t, a[i]),
                    (r[t] = n),
                    (l += n))
                  : (s &&
                      !0 === h.hasAttribute("morphTarget" + t) &&
                      h.deleteAttribute("morphTarget" + t),
                    a &&
                      !0 === h.hasAttribute("morphNormal" + t) &&
                      h.deleteAttribute("morphNormal" + t),
                    (r[t] = 0));
              }
              const c = h.morphTargetsRelative ? 1 : 1 - l;
              u.getUniforms().setValue(t, "morphTargetBaseInfluence", c),
                u.getUniforms().setValue(t, "morphTargetInfluences", r);
            }
          },
        };
      }
      function rr(t, e, i, n) {
        let r = new WeakMap();
        function s(t) {
          const e = t.target;
          e.removeEventListener("dispose", s),
            i.remove(e.instanceMatrix),
            null !== e.instanceColor && i.remove(e.instanceColor);
        }
        return {
          update: function (t) {
            const a = n.render.frame,
              o = t.geometry,
              l = e.get(t, o);
            return (
              r.get(l) !== a && (e.update(l), r.set(l, a)),
              t.isInstancedMesh &&
                (!1 === t.hasEventListener("dispose", s) &&
                  t.addEventListener("dispose", s),
                i.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && i.update(t.instanceColor, 34962)),
              l
            );
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      $n.prototype.isDataTexture2DArray = !0;
      class sr extends Gt {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null),
            (this.image = { data: t, width: e, height: i, depth: n }),
            (this.magFilter = p),
            (this.minFilter = p),
            (this.wrapR = u),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      sr.prototype.isDataTexture3D = !0;
      const ar = new Gt(),
        or = new $n(),
        lr = new sr(),
        hr = new ln(),
        cr = [],
        ur = [],
        dr = new Float32Array(16),
        pr = new Float32Array(9),
        mr = new Float32Array(4);
      function fr(t, e, i) {
        const n = t[0];
        if (n <= 0 || n > 0) return t;
        const r = e * i;
        let s = cr[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (cr[r] = s)), 0 !== e)
        ) {
          n.toArray(s, 0);
          for (let n = 1, r = 0; n !== e; ++n) (r += i), t[n].toArray(s, r);
        }
        return s;
      }
      function gr(t, e) {
        if (t.length !== e.length) return !1;
        for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
        return !0;
      }
      function yr(t, e) {
        for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
      }
      function xr(t, e) {
        let i = ur[e];
        void 0 === i && ((i = new Int32Array(e)), (ur[e] = i));
        for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
        return i;
      }
      function vr(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
      }
      function _r(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
        else {
          if (gr(i, e)) return;
          t.uniform2fv(this.addr, e), yr(i, e);
        }
      }
      function br(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y && i[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (i[0] = e.x),
            (i[1] = e.y),
            (i[2] = e.z));
        else if (void 0 !== e.r)
          (i[0] === e.r && i[1] === e.g && i[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (i[0] = e.r),
            (i[1] = e.g),
            (i[2] = e.b));
        else {
          if (gr(i, e)) return;
          t.uniform3fv(this.addr, e), yr(i, e);
        }
      }
      function Mr(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (i[0] = e.x),
            (i[1] = e.y),
            (i[2] = e.z),
            (i[3] = e.w));
        else {
          if (gr(i, e)) return;
          t.uniform4fv(this.addr, e), yr(i, e);
        }
      }
      function wr(t, e) {
        const i = this.cache,
          n = e.elements;
        if (void 0 === n) {
          if (gr(i, e)) return;
          t.uniformMatrix2fv(this.addr, !1, e), yr(i, e);
        } else {
          if (gr(i, n)) return;
          mr.set(n), t.uniformMatrix2fv(this.addr, !1, mr), yr(i, n);
        }
      }
      function Sr(t, e) {
        const i = this.cache,
          n = e.elements;
        if (void 0 === n) {
          if (gr(i, e)) return;
          t.uniformMatrix3fv(this.addr, !1, e), yr(i, e);
        } else {
          if (gr(i, n)) return;
          pr.set(n), t.uniformMatrix3fv(this.addr, !1, pr), yr(i, n);
        }
      }
      function Tr(t, e) {
        const i = this.cache,
          n = e.elements;
        if (void 0 === n) {
          if (gr(i, e)) return;
          t.uniformMatrix4fv(this.addr, !1, e), yr(i, e);
        } else {
          if (gr(i, n)) return;
          dr.set(n), t.uniformMatrix4fv(this.addr, !1, dr), yr(i, n);
        }
      }
      function Er(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
      }
      function Ar(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform2iv(this.addr, e), yr(i, e));
      }
      function Rr(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform3iv(this.addr, e), yr(i, e));
      }
      function Lr(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform4iv(this.addr, e), yr(i, e));
      }
      function Cr(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e));
      }
      function Pr(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform2uiv(this.addr, e), yr(i, e));
      }
      function Ir(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform3uiv(this.addr, e), yr(i, e));
      }
      function zr(t, e) {
        const i = this.cache;
        gr(i, e) || (t.uniform4uiv(this.addr, e), yr(i, e));
      }
      function Dr(t, e, i) {
        const n = this.cache,
          r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
          i.safeSetTexture2D(e || ar, r);
      }
      function Nr(t, e, i) {
        const n = this.cache,
          r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
          i.setTexture3D(e || lr, r);
      }
      function Or(t, e, i) {
        const n = this.cache,
          r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
          i.safeSetTextureCube(e || hr, r);
      }
      function Br(t, e, i) {
        const n = this.cache,
          r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
          i.setTexture2DArray(e || or, r);
      }
      function Fr(t, e) {
        t.uniform1fv(this.addr, e);
      }
      function Hr(t, e) {
        const i = fr(e, this.size, 2);
        t.uniform2fv(this.addr, i);
      }
      function Ur(t, e) {
        const i = fr(e, this.size, 3);
        t.uniform3fv(this.addr, i);
      }
      function kr(t, e) {
        const i = fr(e, this.size, 4);
        t.uniform4fv(this.addr, i);
      }
      function Gr(t, e) {
        const i = fr(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, i);
      }
      function Vr(t, e) {
        const i = fr(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, i);
      }
      function Wr(t, e) {
        const i = fr(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, i);
      }
      function jr(t, e) {
        t.uniform1iv(this.addr, e);
      }
      function qr(t, e) {
        t.uniform2iv(this.addr, e);
      }
      function Xr(t, e) {
        t.uniform3iv(this.addr, e);
      }
      function Yr(t, e) {
        t.uniform4iv(this.addr, e);
      }
      function Jr(t, e) {
        t.uniform1uiv(this.addr, e);
      }
      function Zr(t, e) {
        t.uniform2uiv(this.addr, e);
      }
      function Kr(t, e) {
        t.uniform3uiv(this.addr, e);
      }
      function Qr(t, e) {
        t.uniform4uiv(this.addr, e);
      }
      function $r(t, e, i) {
        const n = e.length,
          r = xr(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || ar, r[t]);
      }
      function ts(t, e, i) {
        const n = e.length,
          r = xr(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t) i.setTexture3D(e[t] || lr, r[t]);
      }
      function es(t, e, i) {
        const n = e.length,
          r = xr(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || hr, r[t]);
      }
      function is(t, e, i) {
        const n = e.length,
          r = xr(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t) i.setTexture2DArray(e[t] || or, r[t]);
      }
      function ns(t, e, i) {
        (this.id = t),
          (this.addr = i),
          (this.cache = []),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return vr;
              case 35664:
                return _r;
              case 35665:
                return br;
              case 35666:
                return Mr;
              case 35674:
                return wr;
              case 35675:
                return Sr;
              case 35676:
                return Tr;
              case 5124:
              case 35670:
                return Er;
              case 35667:
              case 35671:
                return Ar;
              case 35668:
              case 35672:
                return Rr;
              case 35669:
              case 35673:
                return Lr;
              case 5125:
                return Cr;
              case 36294:
                return Pr;
              case 36295:
                return Ir;
              case 36296:
                return zr;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Dr;
              case 35679:
              case 36299:
              case 36307:
                return Nr;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Or;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return Br;
            }
          })(e.type));
      }
      function rs(t, e, i) {
        (this.id = t),
          (this.addr = i),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return Fr;
              case 35664:
                return Hr;
              case 35665:
                return Ur;
              case 35666:
                return kr;
              case 35674:
                return Gr;
              case 35675:
                return Vr;
              case 35676:
                return Wr;
              case 5124:
              case 35670:
                return jr;
              case 35667:
              case 35671:
                return qr;
              case 35668:
              case 35672:
                return Xr;
              case 35669:
              case 35673:
                return Yr;
              case 5125:
                return Jr;
              case 36294:
                return Zr;
              case 36295:
                return Kr;
              case 36296:
                return Qr;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return $r;
              case 35679:
              case 36299:
              case 36307:
                return ts;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return es;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return is;
            }
          })(e.type));
      }
      function ss(t) {
        (this.id = t), (this.seq = []), (this.map = {});
      }
      (rs.prototype.updateCache = function (t) {
        const e = this.cache;
        t instanceof Float32Array &&
          e.length !== t.length &&
          (this.cache = new Float32Array(t.length)),
          yr(e, t);
      }),
        (ss.prototype.setValue = function (t, e, i) {
          const n = this.seq;
          for (let r = 0, s = n.length; r !== s; ++r) {
            const s = n[r];
            s.setValue(t, e[s.id], i);
          }
        });
      const as = /(\w+)(\])?(\[|\.)?/g;
      function os(t, e) {
        t.seq.push(e), (t.map[e.id] = e);
      }
      function ls(t, e, i) {
        const n = t.name,
          r = n.length;
        for (as.lastIndex = 0; ; ) {
          const s = as.exec(n),
            a = as.lastIndex;
          let o = s[1];
          const l = "]" === s[2],
            h = s[3];
          if ((l && (o |= 0), void 0 === h || ("[" === h && a + 2 === r))) {
            os(i, void 0 === h ? new ns(o, t, e) : new rs(o, t, e));
            break;
          }
          {
            let t = i.map[o];
            void 0 === t && ((t = new ss(o)), os(i, t)), (i = t);
          }
        }
      }
      function hs(t, e) {
        (this.seq = []), (this.map = {});
        const i = t.getProgramParameter(e, 35718);
        for (let n = 0; n < i; ++n) {
          const i = t.getActiveUniform(e, n);
          ls(i, t.getUniformLocation(e, i.name), this);
        }
      }
      function cs(t, e, i) {
        const n = t.createShader(e);
        return t.shaderSource(n, i), t.compileShader(n), n;
      }
      (hs.prototype.setValue = function (t, e, i, n) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, i, n);
      }),
        (hs.prototype.setOptional = function (t, e, i) {
          const n = e[i];
          void 0 !== n && this.setValue(t, i, n);
        }),
        (hs.upload = function (t, e, i, n) {
          for (let r = 0, s = e.length; r !== s; ++r) {
            const s = e[r],
              a = i[s.id];
            !1 !== a.needsUpdate && s.setValue(t, a.value, n);
          }
        }),
        (hs.seqWithValue = function (t, e) {
          const i = [];
          for (let n = 0, r = t.length; n !== r; ++n) {
            const r = t[n];
            r.id in e && i.push(r);
          }
          return i;
        });
      let us = 0;
      function ds(t, e, i) {
        const n = t.getShaderParameter(e, 35713),
          r = t.getShaderInfoLog(e).trim();
        return n && "" === r
          ? ""
          : i.toUpperCase() +
              "\n\n" +
              r +
              "\n\n" +
              (function (t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                return e.join("\n");
              })(t.getShaderSource(e));
      }
      function ps(t, e) {
        const i = (function (t) {
          switch (t) {
            case at:
              return ["Linear", "( value )"];
            case ot:
              return ["sRGB", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
              );
          }
        })(e);
        return (
          "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        );
      }
      function ms(t, e) {
        let i;
        switch (e) {
          case 1:
            i = "Linear";
            break;
          case 2:
            i = "Reinhard";
            break;
          case 3:
            i = "OptimizedCineon";
            break;
          case 4:
            i = "ACESFilmic";
            break;
          case 5:
            i = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (i = "Linear");
        }
        return (
          "vec3 " +
          t +
          "( vec3 color ) { return " +
          i +
          "ToneMapping( color ); }"
        );
      }
      function fs(t) {
        return "" !== t;
      }
      function gs(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function ys(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const xs = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function vs(t) {
        return t.replace(xs, _s);
      }
      function _s(t, e) {
        const i = _n[e];
        if (void 0 === i)
          throw new Error("Can not resolve #include <" + e + ">");
        return vs(i);
      }
      const bs =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Ms =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function ws(t) {
        return t.replace(Ms, Ts).replace(bs, Ss);
      }
      function Ss(t, e, i, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          Ts(0, e, i, n)
        );
      }
      function Ts(t, e, i, n) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(i); t++)
          r += n
            .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, t);
        return r;
      }
      function Es(t) {
        let e =
          "precision " +
          t.precision +
          " float;\nprecision " +
          t.precision +
          " int;";
        return (
          "highp" === t.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === t.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function As(t, e, i, n) {
        const a = t.getContext(),
          o = i.defines;
        let c = i.vertexShader,
          u = i.fragmentShader;
        const d = (function (t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return (
              1 === t.shadowMapType
                ? (e = "SHADOWMAP_TYPE_PCF")
                : 2 === t.shadowMapType
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
              e
            );
          })(i),
          p = (function (t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
              switch (t.envMapMode) {
                case r:
                case s:
                  e = "ENVMAP_TYPE_CUBE";
                  break;
                case l:
                case h:
                  e = "ENVMAP_TYPE_CUBE_UV";
              }
            return e;
          })(i),
          m = (function (t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
              switch (t.envMapMode) {
                case s:
                case h:
                  e = "ENVMAP_MODE_REFRACTION";
              }
            return e;
          })(i),
          f = (function (t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
              switch (t.combine) {
                case 0:
                  e = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  e = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  e = "ENVMAP_BLENDING_ADD";
              }
            return e;
          })(i),
          g = i.isWebGL2
            ? ""
            : (function (t) {
                return [
                  t.extensionDerivatives ||
                  t.envMapCubeUV ||
                  t.bumpMap ||
                  t.tangentSpaceNormalMap ||
                  t.clearcoatNormalMap ||
                  t.flatShading ||
                  "physical" === t.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                  t.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                  t.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(fs)
                  .join("\n");
              })(i),
          y = (function (t) {
            const e = [];
            for (const i in t) {
              const n = t[i];
              !1 !== n && e.push("#define " + i + " " + n);
            }
            return e.join("\n");
          })(o),
          x = a.createProgram();
        let v,
          _,
          b = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
        i.isRawShaderMaterial
          ? ((v = [y].filter(fs).join("\n")),
            v.length > 0 && (v += "\n"),
            (_ = [g, y].filter(fs).join("\n")),
            _.length > 0 && (_ += "\n"))
          : ((v = [
              Es(i),
              "#define SHADER_NAME " + i.shaderName,
              y,
              i.instancing ? "#define USE_INSTANCING" : "",
              i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define MAX_BONES " + i.maxBones,
              i.useFog && i.fog ? "#define USE_FOG" : "",
              i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
              i.map ? "#define USE_MAP" : "",
              i.envMap ? "#define USE_ENVMAP" : "",
              i.envMap ? "#define " + m : "",
              i.lightMap ? "#define USE_LIGHTMAP" : "",
              i.aoMap ? "#define USE_AOMAP" : "",
              i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              i.bumpMap ? "#define USE_BUMPMAP" : "",
              i.normalMap ? "#define USE_NORMALMAP" : "",
              i.normalMap && i.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              i.normalMap && i.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              i.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              i.displacementMap && i.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              i.specularMap ? "#define USE_SPECULARMAP" : "",
              i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              i.metalnessMap ? "#define USE_METALNESSMAP" : "",
              i.alphaMap ? "#define USE_ALPHAMAP" : "",
              i.transmission ? "#define USE_TRANSMISSION" : "",
              i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              i.vertexTangents ? "#define USE_TANGENT" : "",
              i.vertexColors ? "#define USE_COLOR" : "",
              i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              i.vertexUvs ? "#define USE_UV" : "",
              i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              i.flatShading ? "#define FLAT_SHADED" : "",
              i.skinning ? "#define USE_SKINNING" : "",
              i.useVertexTexture ? "#define BONE_TEXTURE" : "",
              i.morphTargets ? "#define USE_MORPHTARGETS" : "",
              i.morphNormals && !1 === i.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              i.morphTargets && i.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              i.morphTargets && i.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
                : "",
              i.doubleSided ? "#define DOUBLE_SIDED" : "",
              i.flipSided ? "#define FLIP_SIDED" : "",
              i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              i.shadowMapEnabled ? "#define " + d : "",
              i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(fs)
              .join("\n")),
            (_ = [
              g,
              Es(i),
              "#define SHADER_NAME " + i.shaderName,
              y,
              i.useFog && i.fog ? "#define USE_FOG" : "",
              i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
              i.map ? "#define USE_MAP" : "",
              i.matcap ? "#define USE_MATCAP" : "",
              i.envMap ? "#define USE_ENVMAP" : "",
              i.envMap ? "#define " + p : "",
              i.envMap ? "#define " + m : "",
              i.envMap ? "#define " + f : "",
              i.lightMap ? "#define USE_LIGHTMAP" : "",
              i.aoMap ? "#define USE_AOMAP" : "",
              i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              i.bumpMap ? "#define USE_BUMPMAP" : "",
              i.normalMap ? "#define USE_NORMALMAP" : "",
              i.normalMap && i.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              i.normalMap && i.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              i.clearcoat ? "#define USE_CLEARCOAT" : "",
              i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              i.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              i.specularMap ? "#define USE_SPECULARMAP" : "",
              i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              i.metalnessMap ? "#define USE_METALNESSMAP" : "",
              i.alphaMap ? "#define USE_ALPHAMAP" : "",
              i.alphaTest ? "#define USE_ALPHATEST" : "",
              i.sheen ? "#define USE_SHEEN" : "",
              i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              i.transmission ? "#define USE_TRANSMISSION" : "",
              i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              i.vertexTangents ? "#define USE_TANGENT" : "",
              i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
              i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              i.vertexUvs ? "#define USE_UV" : "",
              i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              i.gradientMap ? "#define USE_GRADIENTMAP" : "",
              i.flatShading ? "#define FLAT_SHADED" : "",
              i.doubleSided ? "#define DOUBLE_SIDED" : "",
              i.flipSided ? "#define FLIP_SIDED" : "",
              i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              i.shadowMapEnabled ? "#define " + d : "",
              i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              i.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (i.extensionShaderTextureLOD || i.envMap) &&
              i.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== i.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== i.toneMapping ? _n.tonemapping_pars_fragment : "",
              0 !== i.toneMapping ? ms("toneMapping", i.toneMapping) : "",
              i.dithering ? "#define DITHERING" : "",
              i.transparent ? "" : "#define OPAQUE",
              _n.encodings_pars_fragment,
              ps("linearToOutputTexel", i.outputEncoding),
              i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
              "\n",
            ]
              .filter(fs)
              .join("\n"))),
          (c = vs(c)),
          (c = gs(c, i)),
          (c = ys(c, i)),
          (u = vs(u)),
          (u = gs(u, i)),
          (u = ys(u, i)),
          (c = ws(c)),
          (u = ws(u)),
          i.isWebGL2 &&
            !0 !== i.isRawShaderMaterial &&
            ((b = "#version 300 es\n"),
            (v =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              v),
            (_ =
              [
                "#define varying in",
                i.glslVersion === ut
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                i.glslVersion === ut ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              _));
        const M = b + _ + u,
          w = cs(a, 35633, b + v + c),
          S = cs(a, 35632, M);
        if (
          (a.attachShader(x, w),
          a.attachShader(x, S),
          void 0 !== i.index0AttributeName
            ? a.bindAttribLocation(x, 0, i.index0AttributeName)
            : !0 === i.morphTargets && a.bindAttribLocation(x, 0, "position"),
          a.linkProgram(x),
          t.debug.checkShaderErrors)
        ) {
          const t = a.getProgramInfoLog(x).trim(),
            e = a.getShaderInfoLog(w).trim(),
            i = a.getShaderInfoLog(S).trim();
          let n = !0,
            r = !0;
          if (!1 === a.getProgramParameter(x, 35714)) {
            n = !1;
            const e = ds(a, w, "vertex"),
              i = ds(a, S, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                a.getError() +
                " - VALIDATE_STATUS " +
                a.getProgramParameter(x, 35715) +
                "\n\nProgram Info Log: " +
                t +
                "\n" +
                e +
                "\n" +
                i
            );
          } else
            "" !== t
              ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
              : ("" !== e && "" !== i) || (r = !1);
          r &&
            (this.diagnostics = {
              runnable: n,
              programLog: t,
              vertexShader: { log: e, prefix: v },
              fragmentShader: { log: i, prefix: _ },
            });
        }
        let T, E;
        return (
          a.deleteShader(w),
          a.deleteShader(S),
          (this.getUniforms = function () {
            return void 0 === T && (T = new hs(a, x)), T;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === E &&
                (E = (function (t, e) {
                  const i = {},
                    n = t.getProgramParameter(e, 35721);
                  for (let r = 0; r < n; r++) {
                    const n = t.getActiveAttrib(e, r),
                      s = n.name;
                    let a = 1;
                    35674 === n.type && (a = 2),
                      35675 === n.type && (a = 3),
                      35676 === n.type && (a = 4),
                      (i[s] = {
                        type: n.type,
                        location: t.getAttribLocation(e, s),
                        locationSize: a,
                      });
                  }
                  return i;
                })(a, x)),
              E
            );
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              a.deleteProgram(x),
              (this.program = void 0);
          }),
          (this.name = i.shaderName),
          (this.id = us++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = x),
          (this.vertexShader = w),
          (this.fragmentShader = S),
          this
        );
      }
      let Rs = 0;
      class Ls {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(t) {
          const e = t.vertexShader,
            i = t.fragmentShader,
            n = this._getShaderStage(e),
            r = this._getShaderStage(i),
            s = this._getShaderCacheForMaterial(t);
          return (
            !1 === s.has(n) && (s.add(n), n.usedTimes++),
            !1 === s.has(r) && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const t of e)
            t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          return !1 === e.has(t) && e.set(t, new Set()), e.get(t);
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          if (!1 === e.has(t)) {
            const i = new Cs();
            e.set(t, i);
          }
          return e.get(t);
        }
      }
      class Cs {
        constructor() {
          (this.id = Rs++), (this.usedTimes = 0);
        }
      }
      function Ps(t, e, i, n, r, s, a) {
        const o = new Be(),
          c = new Ls(),
          u = [],
          d = r.isWebGL2,
          p = r.logarithmicDepthBuffer,
          m = r.floatVertexTextures,
          f = r.maxVertexUniforms,
          g = r.vertexTextures;
        let y = r.precision;
        const x = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        return {
          getParameters: function (s, o, u, v, _) {
            const b = v.fog,
              M = s.isMeshStandardMaterial ? v.environment : null,
              w = (s.isMeshStandardMaterial ? i : e).get(s.envMap || M),
              S = x[s.type],
              T = _.isSkinnedMesh
                ? (function (t) {
                    const e = t.skeleton.bones;
                    if (m) return 1024;
                    {
                      const t = f,
                        i = Math.floor((t - 20) / 4),
                        n = Math.min(i, e.length);
                      return n < e.length
                        ? (console.warn(
                            "THREE.WebGLRenderer: Skeleton has " +
                              e.length +
                              " bones. This GPU supports " +
                              n +
                              "."
                          ),
                          0)
                        : n;
                    }
                  })(_)
                : 0;
            let E, A, R, L;
            if (
              (null !== s.precision &&
                ((y = r.getMaxPrecision(s.precision)),
                y !== s.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    s.precision,
                    "not supported, using",
                    y,
                    "instead."
                  )),
              S)
            ) {
              const t = Mn[S];
              (E = t.vertexShader), (A = t.fragmentShader);
            } else
              (E = s.vertexShader),
                (A = s.fragmentShader),
                c.update(s),
                (R = c.getVertexShaderID(s)),
                (L = c.getFragmentShaderID(s));
            const C = t.getRenderTarget(),
              P = s.alphaTest > 0,
              I = s.clearcoat > 0;
            return {
              isWebGL2: d,
              shaderID: S,
              shaderName: s.type,
              vertexShader: E,
              fragmentShader: A,
              defines: s.defines,
              customVertexShaderID: R,
              customFragmentShaderID: L,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: y,
              instancing: !0 === _.isInstancedMesh,
              instancingColor:
                !0 === _.isInstancedMesh && null !== _.instanceColor,
              supportsVertexTextures: g,
              outputEncoding:
                null === C
                  ? t.outputEncoding
                  : !0 === C.isXRRenderTarget
                  ? C.texture.encoding
                  : at,
              map: !!s.map,
              matcap: !!s.matcap,
              envMap: !!w,
              envMapMode: w && w.mapping,
              envMapCubeUV: !!w && (w.mapping === l || w.mapping === h),
              lightMap: !!s.lightMap,
              aoMap: !!s.aoMap,
              emissiveMap: !!s.emissiveMap,
              bumpMap: !!s.bumpMap,
              normalMap: !!s.normalMap,
              objectSpaceNormalMap: 1 === s.normalMapType,
              tangentSpaceNormalMap: 0 === s.normalMapType,
              decodeVideoTexture:
                !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === ot,
              clearcoat: I,
              clearcoatMap: I && !!s.clearcoatMap,
              clearcoatRoughnessMap: I && !!s.clearcoatRoughnessMap,
              clearcoatNormalMap: I && !!s.clearcoatNormalMap,
              displacementMap: !!s.displacementMap,
              roughnessMap: !!s.roughnessMap,
              metalnessMap: !!s.metalnessMap,
              specularMap: !!s.specularMap,
              specularIntensityMap: !!s.specularIntensityMap,
              specularColorMap: !!s.specularColorMap,
              transparent: s.transparent,
              alphaMap: !!s.alphaMap,
              alphaTest: P,
              gradientMap: !!s.gradientMap,
              sheen: s.sheen > 0,
              sheenColorMap: !!s.sheenColorMap,
              sheenRoughnessMap: !!s.sheenRoughnessMap,
              transmission: s.transmission > 0,
              transmissionMap: !!s.transmissionMap,
              thicknessMap: !!s.thicknessMap,
              combine: s.combine,
              vertexTangents:
                !!s.normalMap &&
                !!_.geometry &&
                !!_.geometry.attributes.tangent,
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!_.geometry &&
                !!_.geometry.attributes.color &&
                4 === _.geometry.attributes.color.itemSize,
              vertexUvs: !!(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatMap ||
                s.clearcoatRoughnessMap ||
                s.clearcoatNormalMap ||
                s.displacementMap ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularColorMap ||
                s.sheenColorMap ||
                s.sheenRoughnessMap
              ),
              uvsVertexOnly: !(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatNormalMap ||
                s.transmission > 0 ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularColorMap ||
                s.sheen > 0 ||
                s.sheenColorMap ||
                s.sheenRoughnessMap ||
                !s.displacementMap
              ),
              fog: !!b,
              useFog: s.fog,
              fogExp2: b && b.isFogExp2,
              flatShading: !!s.flatShading,
              sizeAttenuation: s.sizeAttenuation,
              logarithmicDepthBuffer: p,
              skinning: !0 === _.isSkinnedMesh && T > 0,
              maxBones: T,
              useVertexTexture: m,
              morphTargets:
                !!_.geometry && !!_.geometry.morphAttributes.position,
              morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
              morphTargetsCount:
                _.geometry && _.geometry.morphAttributes.position
                  ? _.geometry.morphAttributes.position.length
                  : 0,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: s.toneMapped ? t.toneMapping : 0,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: 2 === s.side,
              flipSided: 1 === s.side,
              depthPacking: void 0 !== s.depthPacking && s.depthPacking,
              index0AttributeName: s.index0AttributeName,
              extensionDerivatives: s.extensions && s.extensions.derivatives,
              extensionFragDepth: s.extensions && s.extensions.fragDepth,
              extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
              extensionShaderTextureLOD:
                s.extensions && s.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                d || n.has("EXT_shader_texture_lod"),
              customProgramCacheKey: s.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (e) {
            const i = [];
            if (
              (e.shaderID
                ? i.push(e.shaderID)
                : (i.push(e.customVertexShaderID),
                  i.push(e.customFragmentShaderID)),
              void 0 !== e.defines)
            )
              for (const t in e.defines) i.push(t), i.push(e.defines[t]);
            return (
              !1 === e.isRawShaderMaterial &&
                ((function (t, e) {
                  t.push(e.precision),
                    t.push(e.outputEncoding),
                    t.push(e.envMapMode),
                    t.push(e.combine),
                    t.push(e.vertexUvs),
                    t.push(e.fogExp2),
                    t.push(e.sizeAttenuation),
                    t.push(e.maxBones),
                    t.push(e.morphTargetsCount),
                    t.push(e.numDirLights),
                    t.push(e.numPointLights),
                    t.push(e.numSpotLights),
                    t.push(e.numHemiLights),
                    t.push(e.numRectAreaLights),
                    t.push(e.numDirLightShadows),
                    t.push(e.numPointLightShadows),
                    t.push(e.numSpotLightShadows),
                    t.push(e.shadowMapType),
                    t.push(e.toneMapping),
                    t.push(e.numClippingPlanes),
                    t.push(e.numClipIntersection);
                })(i, e),
                (function (t, e) {
                  o.disableAll(),
                    e.isWebGL2 && o.enable(0),
                    e.supportsVertexTextures && o.enable(1),
                    e.instancing && o.enable(2),
                    e.instancingColor && o.enable(3),
                    e.map && o.enable(4),
                    e.matcap && o.enable(5),
                    e.envMap && o.enable(6),
                    e.envMapCubeUV && o.enable(7),
                    e.lightMap && o.enable(8),
                    e.aoMap && o.enable(9),
                    e.emissiveMap && o.enable(10),
                    e.bumpMap && o.enable(11),
                    e.normalMap && o.enable(12),
                    e.objectSpaceNormalMap && o.enable(13),
                    e.tangentSpaceNormalMap && o.enable(14),
                    e.clearcoat && o.enable(15),
                    e.clearcoatMap && o.enable(16),
                    e.clearcoatRoughnessMap && o.enable(17),
                    e.clearcoatNormalMap && o.enable(18),
                    e.displacementMap && o.enable(19),
                    e.specularMap && o.enable(20),
                    e.roughnessMap && o.enable(21),
                    e.metalnessMap && o.enable(22),
                    e.gradientMap && o.enable(23),
                    e.alphaMap && o.enable(24),
                    e.alphaTest && o.enable(25),
                    e.vertexColors && o.enable(26),
                    e.vertexAlphas && o.enable(27),
                    e.vertexUvs && o.enable(28),
                    e.vertexTangents && o.enable(29),
                    e.uvsVertexOnly && o.enable(30),
                    e.fog && o.enable(31),
                    t.push(o.mask),
                    o.disableAll(),
                    e.useFog && o.enable(0),
                    e.flatShading && o.enable(1),
                    e.logarithmicDepthBuffer && o.enable(2),
                    e.skinning && o.enable(3),
                    e.useVertexTexture && o.enable(4),
                    e.morphTargets && o.enable(5),
                    e.morphNormals && o.enable(6),
                    e.premultipliedAlpha && o.enable(7),
                    e.shadowMapEnabled && o.enable(8),
                    e.physicallyCorrectLights && o.enable(9),
                    e.doubleSided && o.enable(10),
                    e.flipSided && o.enable(11),
                    e.depthPacking && o.enable(12),
                    e.dithering && o.enable(13),
                    e.specularIntensityMap && o.enable(14),
                    e.specularColorMap && o.enable(15),
                    e.transmission && o.enable(16),
                    e.transmissionMap && o.enable(17),
                    e.thicknessMap && o.enable(18),
                    e.sheen && o.enable(19),
                    e.sheenColorMap && o.enable(20),
                    e.sheenRoughnessMap && o.enable(21),
                    e.decodeVideoTexture && o.enable(22),
                    e.transparent && o.enable(23),
                    t.push(o.mask);
                })(i, e),
                i.push(t.outputEncoding)),
              i.push(e.customProgramCacheKey),
              i.join()
            );
          },
          getUniforms: function (t) {
            const e = x[t.type];
            let i;
            if (e) {
              const t = Mn[e];
              i = en.clone(t.uniforms);
            } else i = t.uniforms;
            return i;
          },
          acquireProgram: function (e, i) {
            let n;
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t];
              if (e.cacheKey === i) {
                (n = e), ++n.usedTimes;
                break;
              }
            }
            return void 0 === n && ((n = new As(t, i, e, s)), u.push(n)), n;
          },
          releaseProgram: function (t) {
            if (0 == --t.usedTimes) {
              const e = u.indexOf(t);
              (u[e] = u[u.length - 1]), u.pop(), t.destroy();
            }
          },
          releaseShaderCache: function (t) {
            c.remove(t);
          },
          programs: u,
          dispose: function () {
            c.dispose();
          },
        };
      }
      function Is() {
        let t = new WeakMap();
        return {
          get: function (e) {
            let i = t.get(e);
            return void 0 === i && ((i = {}), t.set(e, i)), i;
          },
          remove: function (e) {
            t.delete(e);
          },
          update: function (e, i, n) {
            t.get(e)[i] = n;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function zs(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id;
      }
      function Ds(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id;
      }
      function Ns() {
        const t = [];
        let e = 0;
        const i = [],
          n = [],
          r = [];
        function s(i, n, r, s, a, o) {
          let l = t[e];
          return (
            void 0 === l
              ? ((l = {
                  id: i.id,
                  object: i,
                  geometry: n,
                  material: r,
                  groupOrder: s,
                  renderOrder: i.renderOrder,
                  z: a,
                  group: o,
                }),
                (t[e] = l))
              : ((l.id = i.id),
                (l.object = i),
                (l.geometry = n),
                (l.material = r),
                (l.groupOrder = s),
                (l.renderOrder = i.renderOrder),
                (l.z = a),
                (l.group = o)),
            e++,
            l
          );
        }
        return {
          opaque: i,
          transmissive: n,
          transparent: r,
          init: function () {
            (e = 0), (i.length = 0), (n.length = 0), (r.length = 0);
          },
          push: function (t, e, a, o, l, h) {
            const c = s(t, e, a, o, l, h);
            a.transmission > 0
              ? n.push(c)
              : !0 === a.transparent
              ? r.push(c)
              : i.push(c);
          },
          unshift: function (t, e, a, o, l, h) {
            const c = s(t, e, a, o, l, h);
            a.transmission > 0
              ? n.unshift(c)
              : !0 === a.transparent
              ? r.unshift(c)
              : i.unshift(c);
          },
          finish: function () {
            for (let i = e, n = t.length; i < n; i++) {
              const e = t[i];
              if (null === e.id) break;
              (e.id = null),
                (e.object = null),
                (e.geometry = null),
                (e.material = null),
                (e.group = null);
            }
          },
          sort: function (t, e) {
            i.length > 1 && i.sort(t || zs),
              n.length > 1 && n.sort(e || Ds),
              r.length > 1 && r.sort(e || Ds);
          },
        };
      }
      function Os() {
        let t = new WeakMap();
        return {
          get: function (e, i) {
            let n;
            return (
              !1 === t.has(e)
                ? ((n = new Ns()), t.set(e, [n]))
                : i >= t.get(e).length
                ? ((n = new Ns()), t.get(e).push(n))
                : (n = t.get(e)[i]),
              n
            );
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function Bs() {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let i;
            switch (e.type) {
              case "DirectionalLight":
                i = { direction: new Jt(), color: new Ft() };
                break;
              case "SpotLight":
                i = {
                  position: new Jt(),
                  direction: new Jt(),
                  color: new Ft(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                i = {
                  position: new Jt(),
                  color: new Ft(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                i = {
                  direction: new Jt(),
                  skyColor: new Ft(),
                  groundColor: new Ft(),
                };
                break;
              case "RectAreaLight":
                i = {
                  color: new Ft(),
                  position: new Jt(),
                  halfWidth: new Jt(),
                  halfHeight: new Jt(),
                };
            }
            return (t[e.id] = i), i;
          },
        };
      }
      let Fs = 0;
      function Hs(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
      }
      function Us(t, e) {
        const i = new Bs(),
          n = (function () {
            const t = {};
            return {
              get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                let i;
                switch (e.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    i = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Et(),
                    };
                    break;
                  case "PointLight":
                    i = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Et(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (t[e.id] = i), i;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let t = 0; t < 9; t++) r.probe.push(new Jt());
        const s = new Jt(),
          a = new Ee(),
          o = new Ee();
        return {
          setup: function (s, a) {
            let o = 0,
              l = 0,
              h = 0;
            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
            let c = 0,
              u = 0,
              d = 0,
              p = 0,
              m = 0,
              f = 0,
              g = 0,
              y = 0;
            s.sort(Hs);
            const x = !0 !== a ? Math.PI : 1;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t],
                a = e.color,
                v = e.intensity,
                _ = e.distance,
                b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
              if (e.isAmbientLight)
                (o += a.r * v * x), (l += a.g * v * x), (h += a.b * v * x);
              else if (e.isLightProbe)
                for (let t = 0; t < 9; t++)
                  r.probe[t].addScaledVector(e.sh.coefficients[t], v);
              else if (e.isDirectionalLight) {
                const t = i.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    i = n.get(e);
                  (i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (r.directionalShadow[c] = i),
                    (r.directionalShadowMap[c] = b),
                    (r.directionalShadowMatrix[c] = e.shadow.matrix),
                    f++;
                }
                (r.directional[c] = t), c++;
              } else if (e.isSpotLight) {
                const t = i.get(e);
                if (
                  (t.position.setFromMatrixPosition(e.matrixWorld),
                  t.color.copy(a).multiplyScalar(v * x),
                  (t.distance = _),
                  (t.coneCos = Math.cos(e.angle)),
                  (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    i = n.get(e);
                  (i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (r.spotShadow[d] = i),
                    (r.spotShadowMap[d] = b),
                    (r.spotShadowMatrix[d] = e.shadow.matrix),
                    y++;
                }
                (r.spot[d] = t), d++;
              } else if (e.isRectAreaLight) {
                const t = i.get(e);
                t.color.copy(a).multiplyScalar(v),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  (r.rectArea[p] = t),
                  p++;
              } else if (e.isPointLight) {
                const t = i.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                  (t.distance = e.distance),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    i = n.get(e);
                  (i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (i.shadowCameraNear = t.camera.near),
                    (i.shadowCameraFar = t.camera.far),
                    (r.pointShadow[u] = i),
                    (r.pointShadowMap[u] = b),
                    (r.pointShadowMatrix[u] = e.shadow.matrix),
                    g++;
                }
                (r.point[u] = t), u++;
              } else if (e.isHemisphereLight) {
                const t = i.get(e);
                t.skyColor.copy(e.color).multiplyScalar(v * x),
                  t.groundColor.copy(e.groundColor).multiplyScalar(v * x),
                  (r.hemi[m] = t),
                  m++;
              }
            }
            p > 0 &&
              (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = bn.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = bn.LTC_FLOAT_2))
                : !0 === t.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = bn.LTC_HALF_1),
                  (r.rectAreaLTC2 = bn.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = o),
              (r.ambient[1] = l),
              (r.ambient[2] = h);
            const v = r.hash;
            (v.directionalLength === c &&
              v.pointLength === u &&
              v.spotLength === d &&
              v.rectAreaLength === p &&
              v.hemiLength === m &&
              v.numDirectionalShadows === f &&
              v.numPointShadows === g &&
              v.numSpotShadows === y) ||
              ((r.directional.length = c),
              (r.spot.length = d),
              (r.rectArea.length = p),
              (r.point.length = u),
              (r.hemi.length = m),
              (r.directionalShadow.length = f),
              (r.directionalShadowMap.length = f),
              (r.pointShadow.length = g),
              (r.pointShadowMap.length = g),
              (r.spotShadow.length = y),
              (r.spotShadowMap.length = y),
              (r.directionalShadowMatrix.length = f),
              (r.pointShadowMatrix.length = g),
              (r.spotShadowMatrix.length = y),
              (v.directionalLength = c),
              (v.pointLength = u),
              (v.spotLength = d),
              (v.rectAreaLength = p),
              (v.hemiLength = m),
              (v.numDirectionalShadows = f),
              (v.numPointShadows = g),
              (v.numSpotShadows = y),
              (r.version = Fs++));
          },
          setupView: function (t, e) {
            let i = 0,
              n = 0,
              l = 0,
              h = 0,
              c = 0;
            const u = e.matrixWorldInverse;
            for (let e = 0, d = t.length; e < d; e++) {
              const d = t[e];
              if (d.isDirectionalLight) {
                const t = r.directional[i];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(u),
                  i++;
              } else if (d.isSpotLight) {
                const t = r.spot[l];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(u),
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(u),
                  l++;
              } else if (d.isRectAreaLight) {
                const t = r.rectArea[h];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(u),
                  o.identity(),
                  a.copy(d.matrixWorld),
                  a.premultiply(u),
                  o.extractRotation(a),
                  t.halfWidth.set(0.5 * d.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * d.height, 0),
                  t.halfWidth.applyMatrix4(o),
                  t.halfHeight.applyMatrix4(o),
                  h++;
              } else if (d.isPointLight) {
                const t = r.point[n];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(u),
                  n++;
              } else if (d.isHemisphereLight) {
                const t = r.hemi[c];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  t.direction.transformDirection(u),
                  t.direction.normalize(),
                  c++;
              }
            }
          },
          state: r,
        };
      }
      function ks(t, e) {
        const i = new Us(t, e),
          n = [],
          r = [];
        return {
          init: function () {
            (n.length = 0), (r.length = 0);
          },
          state: { lightsArray: n, shadowsArray: r, lights: i },
          setupLights: function (t) {
            i.setup(n, t);
          },
          setupLightsView: function (t) {
            i.setupView(n, t);
          },
          pushLight: function (t) {
            n.push(t);
          },
          pushShadow: function (t) {
            r.push(t);
          },
        };
      }
      function Gs(t, e) {
        let i = new WeakMap();
        return {
          get: function (n, r = 0) {
            let s;
            return (
              !1 === i.has(n)
                ? ((s = new ks(t, e)), i.set(n, [s]))
                : r >= i.get(n).length
                ? ((s = new ks(t, e)), i.get(n).push(s))
                : (s = i.get(n)[r]),
              s
            );
          },
          dispose: function () {
            i = new WeakMap();
          },
        };
      }
      class Vs extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      }
      Vs.prototype.isMeshDepthMaterial = !0;
      class Ws extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new Jt()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      }
      function js(t, e, i) {
        let n = new gn();
        const r = new Et(),
          s = new Et(),
          a = new Wt(),
          o = new Vs({ depthPacking: 3201 }),
          l = new Ws(),
          h = {},
          c = i.maxTextureSize,
          u = { 0: 1, 1: 0, 2: 2 },
          d = new nn({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Et() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          m = d.clone();
        m.defines.HORIZONTAL_PASS = 1;
        const f = new Ii();
        f.setAttribute(
          "position",
          new mi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const y = new Zi(f, d),
          x = this;
        function v(i, n) {
          const r = e.update(y);
          d.defines.VSM_SAMPLES !== i.blurSamples &&
            ((d.defines.VSM_SAMPLES = i.blurSamples),
            (m.defines.VSM_SAMPLES = i.blurSamples),
            (d.needsUpdate = !0),
            (m.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = i.map.texture),
            (d.uniforms.resolution.value = i.mapSize),
            (d.uniforms.radius.value = i.radius),
            t.setRenderTarget(i.mapPass),
            t.clear(),
            t.renderBufferDirect(n, null, r, d, y, null),
            (m.uniforms.shadow_pass.value = i.mapPass.texture),
            (m.uniforms.resolution.value = i.mapSize),
            (m.uniforms.radius.value = i.radius),
            t.setRenderTarget(i.map),
            t.clear(),
            t.renderBufferDirect(n, null, r, m, y, null);
        }
        function _(e, i, n, r, s, a, c) {
          let d = null;
          const p =
            !0 === r.isPointLight
              ? e.customDistanceMaterial
              : e.customDepthMaterial;
          if (
            ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o),
            (t.localClippingEnabled &&
              !0 === n.clipShadows &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0))
          ) {
            const t = d.uuid,
              e = n.uuid;
            let i = h[t];
            void 0 === i && ((i = {}), (h[t] = i));
            let r = i[e];
            void 0 === r && ((r = d.clone()), (i[e] = r)), (d = r);
          }
          return (
            (d.visible = n.visible),
            (d.wireframe = n.wireframe),
            (d.side =
              3 === c
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : u[n.side]),
            (d.alphaMap = n.alphaMap),
            (d.alphaTest = n.alphaTest),
            (d.clipShadows = n.clipShadows),
            (d.clippingPlanes = n.clippingPlanes),
            (d.clipIntersection = n.clipIntersection),
            (d.displacementMap = n.displacementMap),
            (d.displacementScale = n.displacementScale),
            (d.displacementBias = n.displacementBias),
            (d.wireframeLinewidth = n.wireframeLinewidth),
            (d.linewidth = n.linewidth),
            !0 === r.isPointLight &&
              !0 === d.isMeshDistanceMaterial &&
              (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (d.nearDistance = s),
              (d.farDistance = a)),
            d
          );
        }
        function b(i, r, s, a, o) {
          if (!1 === i.visible) return;
          if (
            i.layers.test(r.layers) &&
            (i.isMesh || i.isLine || i.isPoints) &&
            (i.castShadow || (i.receiveShadow && 3 === o)) &&
            (!i.frustumCulled || n.intersectsObject(i))
          ) {
            i.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              i.matrixWorld
            );
            const n = e.update(i),
              r = i.material;
            if (Array.isArray(r)) {
              const e = n.groups;
              for (let l = 0, h = e.length; l < h; l++) {
                const h = e[l],
                  c = r[h.materialIndex];
                if (c && c.visible) {
                  const e = _(i, 0, c, a, s.near, s.far, o);
                  t.renderBufferDirect(s, null, n, e, i, h);
                }
              }
            } else if (r.visible) {
              const e = _(i, 0, r, a, s.near, s.far, o);
              t.renderBufferDirect(s, null, n, e, i, null);
            }
          }
          const l = i.children;
          for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, a, o);
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (e, i, o) {
            if (!1 === x.enabled) return;
            if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
            if (0 === e.length) return;
            const l = t.getRenderTarget(),
              h = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              d = t.state;
            d.setBlending(0),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1);
            for (let l = 0, h = e.length; l < h; l++) {
              const h = e[l],
                u = h.shadow;
              if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                continue;
              }
              if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
              r.copy(u.mapSize);
              const m = u.getFrameExtents();
              if (
                (r.multiply(m),
                s.copy(u.mapSize),
                (r.x > c || r.y > c) &&
                  (r.x > c &&
                    ((s.x = Math.floor(c / m.x)),
                    (r.x = s.x * m.x),
                    (u.mapSize.x = s.x)),
                  r.y > c &&
                    ((s.y = Math.floor(c / m.y)),
                    (r.y = s.y * m.y),
                    (u.mapSize.y = s.y))),
                null === u.map && !u.isPointLightShadow && 3 === this.type)
              ) {
                const t = { minFilter: g, magFilter: g, format: T };
                (u.map = new jt(r.x, r.y, t)),
                  (u.map.texture.name = h.name + ".shadowMap"),
                  (u.mapPass = new jt(r.x, r.y, t)),
                  u.camera.updateProjectionMatrix();
              }
              if (null === u.map) {
                const t = { minFilter: p, magFilter: p, format: T };
                (u.map = new jt(r.x, r.y, t)),
                  (u.map.texture.name = h.name + ".shadowMap"),
                  u.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(u.map), t.clear();
              const f = u.getViewportCount();
              for (let t = 0; t < f; t++) {
                const e = u.getViewport(t);
                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                  d.viewport(a),
                  u.updateMatrices(h, t),
                  (n = u.getFrustum()),
                  b(i, o, u.camera, h, this.type);
              }
              u.isPointLightShadow || 3 !== this.type || v(u, o),
                (u.needsUpdate = !1);
            }
            (x.needsUpdate = !1), t.setRenderTarget(l, h, u);
          });
      }
      function qs(t, e, n) {
        const r = n.isWebGL2,
          s = new (function () {
            let e = !1;
            const i = new Wt();
            let n = null;
            const r = new Wt(0, 0, 0, 0);
            return {
              setMask: function (i) {
                n === i || e || (t.colorMask(i, i, i, i), (n = i));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e, n, s, a, o) {
                !0 === o && ((e *= a), (n *= a), (s *= a)),
                  i.set(e, n, s, a),
                  !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i));
              },
              reset: function () {
                (e = !1), (n = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          a = new (function () {
            let e = !1,
              i = null,
              n = null,
              r = null;
            return {
              setTest: function (t) {
                t ? H(2929) : U(2929);
              },
              setMask: function (n) {
                i === n || e || (t.depthMask(n), (i = n));
              },
              setFunc: function (e) {
                if (n !== e) {
                  if (e)
                    switch (e) {
                      case 0:
                        t.depthFunc(512);
                        break;
                      case 1:
                        t.depthFunc(519);
                        break;
                      case 2:
                        t.depthFunc(513);
                        break;
                      case 3:
                      default:
                        t.depthFunc(515);
                        break;
                      case 4:
                        t.depthFunc(514);
                        break;
                      case 5:
                        t.depthFunc(518);
                        break;
                      case 6:
                        t.depthFunc(516);
                        break;
                      case 7:
                        t.depthFunc(517);
                    }
                  else t.depthFunc(515);
                  n = e;
                }
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                r !== e && (t.clearDepth(e), (r = e));
              },
              reset: function () {
                (e = !1), (i = null), (n = null), (r = null);
              },
            };
          })(),
          o = new (function () {
            let e = !1,
              i = null,
              n = null,
              r = null,
              s = null,
              a = null,
              o = null,
              l = null,
              h = null;
            return {
              setTest: function (t) {
                e || (t ? H(2960) : U(2960));
              },
              setMask: function (n) {
                i === n || e || (t.stencilMask(n), (i = n));
              },
              setFunc: function (e, i, a) {
                (n === e && r === i && s === a) ||
                  (t.stencilFunc(e, i, a), (n = e), (r = i), (s = a));
              },
              setOp: function (e, i, n) {
                (a === e && o === i && l === n) ||
                  (t.stencilOp(e, i, n), (a = e), (o = i), (l = n));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                h !== e && (t.clearStencil(e), (h = e));
              },
              reset: function () {
                (e = !1),
                  (i = null),
                  (n = null),
                  (r = null),
                  (s = null),
                  (a = null),
                  (o = null),
                  (l = null),
                  (h = null);
              },
            };
          })();
        let l = {},
          h = {},
          c = new WeakMap(),
          u = [],
          d = null,
          p = !1,
          m = null,
          f = null,
          g = null,
          y = null,
          x = null,
          v = null,
          _ = null,
          b = !1,
          M = null,
          w = null,
          S = null,
          T = null,
          E = null;
        const A = t.getParameter(35661);
        let R = !1,
          L = 0;
        const C = t.getParameter(7938);
        -1 !== C.indexOf("WebGL")
          ? ((L = parseFloat(/^WebGL (\d)/.exec(C)[1])), (R = L >= 1))
          : -1 !== C.indexOf("OpenGL ES") &&
            ((L = parseFloat(/^OpenGL ES (\d)/.exec(C)[1])), (R = L >= 2));
        let P = null,
          I = {};
        const z = t.getParameter(3088),
          D = t.getParameter(2978),
          N = new Wt().fromArray(z),
          O = new Wt().fromArray(D);
        function B(e, i, n) {
          const r = new Uint8Array(4),
            s = t.createTexture();
          t.bindTexture(e, s),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
          for (let e = 0; e < n; e++)
            t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
          return s;
        }
        const F = {};
        function H(e) {
          !0 !== l[e] && (t.enable(e), (l[e] = !0));
        }
        function U(e) {
          !1 !== l[e] && (t.disable(e), (l[e] = !1));
        }
        (F[3553] = B(3553, 3553, 1)),
          (F[34067] = B(34067, 34069, 6)),
          s.setClear(0, 0, 0, 1),
          a.setClear(1),
          o.setClear(0),
          H(2929),
          a.setFunc(3),
          W(!1),
          j(1),
          H(2884),
          V(0);
        const k = { [i]: 32774, 101: 32778, 102: 32779 };
        if (r) (k[103] = 32775), (k[104] = 32776);
        else {
          const t = e.get("EXT_blend_minmax");
          null !== t && ((k[103] = t.MIN_EXT), (k[104] = t.MAX_EXT));
        }
        const G = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        };
        function V(e, n, r, s, a, o, l, h) {
          if (0 !== e) {
            if ((!1 === p && (H(3042), (p = !0)), 5 === e))
              (a = a || n),
                (o = o || r),
                (l = l || s),
                (n === f && a === x) ||
                  (t.blendEquationSeparate(k[n], k[a]), (f = n), (x = a)),
                (r === g && s === y && o === v && l === _) ||
                  (t.blendFuncSeparate(G[r], G[s], G[o], G[l]),
                  (g = r),
                  (y = s),
                  (v = o),
                  (_ = l)),
                (m = e),
                (b = null);
            else if (e !== m || h !== b) {
              if (
                ((f === i && x === i) ||
                  (t.blendEquation(32774), (f = i), (x = i)),
                h)
              )
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    t.blendFunc(1, 1);
                    break;
                  case 3:
                    t.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    t.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              else
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    t.blendFunc(770, 1);
                    break;
                  case 3:
                    t.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    t.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              (g = null), (y = null), (v = null), (_ = null), (m = e), (b = h);
            }
          } else !0 === p && (U(3042), (p = !1));
        }
        function W(e) {
          M !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (M = e));
        }
        function j(e) {
          0 !== e
            ? (H(2884),
              e !== w &&
                (1 === e
                  ? t.cullFace(1029)
                  : 2 === e
                  ? t.cullFace(1028)
                  : t.cullFace(1032)))
            : U(2884),
            (w = e);
        }
        function q(e, i, n) {
          e
            ? (H(32823),
              (T === i && E === n) || (t.polygonOffset(i, n), (T = i), (E = n)))
            : U(32823);
        }
        function X(e) {
          void 0 === e && (e = 33984 + A - 1),
            P !== e && (t.activeTexture(e), (P = e));
        }
        return {
          buffers: { color: s, depth: a, stencil: o },
          enable: H,
          disable: U,
          bindFramebuffer: function (e, i) {
            return (
              h[e] !== i &&
              (t.bindFramebuffer(e, i),
              (h[e] = i),
              r &&
                (36009 === e && (h[36160] = i), 36160 === e && (h[36009] = i)),
              !0)
            );
          },
          drawBuffers: function (i, r) {
            let s = u,
              a = !1;
            if (i)
              if (
                ((s = c.get(r)),
                void 0 === s && ((s = []), c.set(r, s)),
                i.isWebGLMultipleRenderTargets)
              ) {
                const t = i.texture;
                if (s.length !== t.length || 36064 !== s[0]) {
                  for (let e = 0, i = t.length; e < i; e++) s[e] = 36064 + e;
                  (s.length = t.length), (a = !0);
                }
              } else 36064 !== s[0] && ((s[0] = 36064), (a = !0));
            else 1029 !== s[0] && ((s[0] = 1029), (a = !0));
            a &&
              (n.isWebGL2
                ? t.drawBuffers(s)
                : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
          },
          useProgram: function (e) {
            return d !== e && (t.useProgram(e), (d = e), !0);
          },
          setBlending: V,
          setMaterial: function (t, e) {
            2 === t.side ? U(2884) : H(2884);
            let i = 1 === t.side;
            e && (i = !i),
              W(i),
              1 === t.blending && !1 === t.transparent
                ? V(0)
                : V(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha
                  ),
              a.setFunc(t.depthFunc),
              a.setTest(t.depthTest),
              a.setMask(t.depthWrite),
              s.setMask(t.colorWrite);
            const n = t.stencilWrite;
            o.setTest(n),
              n &&
                (o.setMask(t.stencilWriteMask),
                o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              q(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage ? H(32926) : U(32926);
          },
          setFlipSided: W,
          setCullFace: j,
          setLineWidth: function (e) {
            e !== S && (R && t.lineWidth(e), (S = e));
          },
          setPolygonOffset: q,
          setScissorTest: function (t) {
            t ? H(3089) : U(3089);
          },
          activeTexture: X,
          bindTexture: function (e, i) {
            null === P && X();
            let n = I[P];
            void 0 === n &&
              ((n = { type: void 0, texture: void 0 }), (I[P] = n)),
              (n.type === e && n.texture === i) ||
                (t.bindTexture(e, i || F[e]), (n.type = e), (n.texture = i));
          },
          unbindTexture: function () {
            const e = I[P];
            void 0 !== e &&
              void 0 !== e.type &&
              (t.bindTexture(e.type, null),
              (e.type = void 0),
              (e.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texStorage2D: function () {
            try {
              t.texStorage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texStorage3D: function () {
            try {
              t.texStorage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage2D: function () {
            try {
              t.texSubImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage3D: function () {
            try {
              t.texSubImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              t.compressedTexSubImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function (e) {
            !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e));
          },
          viewport: function (e) {
            !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), O.copy(e));
          },
          reset: function () {
            t.disable(3042),
              t.disable(2884),
              t.disable(2929),
              t.disable(32823),
              t.disable(3089),
              t.disable(2960),
              t.disable(32926),
              t.blendEquation(32774),
              t.blendFunc(1, 0),
              t.blendFuncSeparate(1, 0, 1, 0),
              t.colorMask(!0, !0, !0, !0),
              t.clearColor(0, 0, 0, 0),
              t.depthMask(!0),
              t.depthFunc(513),
              t.clearDepth(1),
              t.stencilMask(4294967295),
              t.stencilFunc(519, 0, 4294967295),
              t.stencilOp(7680, 7680, 7680),
              t.clearStencil(0),
              t.cullFace(1029),
              t.frontFace(2305),
              t.polygonOffset(0, 0),
              t.activeTexture(33984),
              t.bindFramebuffer(36160, null),
              !0 === r &&
                (t.bindFramebuffer(36009, null),
                t.bindFramebuffer(36008, null)),
              t.useProgram(null),
              t.lineWidth(1),
              t.scissor(0, 0, t.canvas.width, t.canvas.height),
              t.viewport(0, 0, t.canvas.width, t.canvas.height),
              (l = {}),
              (P = null),
              (I = {}),
              (h = {}),
              (c = new WeakMap()),
              (u = []),
              (d = null),
              (p = !1),
              (m = null),
              (f = null),
              (g = null),
              (y = null),
              (x = null),
              (v = null),
              (_ = null),
              (b = !1),
              (M = null),
              (w = null),
              (S = null),
              (T = null),
              (E = null),
              N.set(0, 0, t.canvas.width, t.canvas.height),
              O.set(0, 0, t.canvas.width, t.canvas.height),
              s.reset(),
              a.reset(),
              o.reset();
          },
        };
      }
      function Xs(t, e, i, n, r, s, a) {
        const o = r.isWebGL2,
          l = r.maxTextures,
          h = r.maxCubemapSize,
          R = r.maxTextureSize,
          L = r.maxSamples,
          C = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : void 0,
          P = new WeakMap();
        let I,
          z = !1;
        try {
          z =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t) {}
        function D(t, e) {
          return z ? new OffscreenCanvas(t, e) : Pt("canvas");
        }
        function N(t, e, i, n) {
          let r = 1;
          if (
            ((t.width > n || t.height > n) &&
              (r = n / Math.max(t.width, t.height)),
            r < 1 || !0 === e)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const n = e ? St : Math.floor,
                s = n(r * t.width),
                a = n(r * t.height);
              void 0 === I && (I = D(s, a));
              const o = i ? D(s, a) : I;
              return (
                (o.width = s),
                (o.height = a),
                o.getContext("2d").drawImage(t, 0, 0, s, a),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    t.width +
                    "x" +
                    t.height +
                    ") to (" +
                    s +
                    "x" +
                    a +
                    ")."
                ),
                o
              );
            }
            return (
              "data" in t &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    t.width +
                    "x" +
                    t.height +
                    ")."
                ),
              t
            );
          }
          return t;
        }
        function O(t) {
          return Mt(t.width) && Mt(t.height);
        }
        function B(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== p && t.minFilter !== g
          );
        }
        function F(e) {
          t.generateMipmap(e);
        }
        function H(i, n, r, s, a = !1) {
          if (!1 === o) return n;
          if (null !== i) {
            if (void 0 !== t[i]) return t[i];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                i +
                "'"
            );
          }
          let l = n;
          return (
            6403 === n &&
              (5126 === r && (l = 33326),
              5131 === r && (l = 33325),
              5121 === r && (l = 33321)),
            33319 === n &&
              (5126 === r && (l = 33328),
              5131 === r && (l = 33327),
              5121 === r && (l = 33323)),
            6408 === n &&
              (5126 === r && (l = 34836),
              5131 === r && (l = 34842),
              5121 === r && (l = s === ot && !1 === a ? 35907 : 32856),
              32819 === r && (l = 32854),
              32820 === r && (l = 32855)),
            (33325 !== l &&
              33326 !== l &&
              33327 !== l &&
              33328 !== l &&
              34842 !== l &&
              34836 !== l) ||
              e.get("EXT_color_buffer_float"),
            l
          );
        }
        function U(t, e, i) {
          return !0 === B(t, i) ||
            (t.isFramebufferTexture && t.minFilter !== p && t.minFilter !== g)
            ? Math.log2(Math.max(e.width, e.height)) + 1
            : void 0 !== t.mipmaps && t.mipmaps.length > 0
            ? t.mipmaps.length
            : t.isCompressedTexture && Array.isArray(t.image)
            ? e.mipmaps.length
            : 1;
        }
        function k(t) {
          return t === p || t === m || t === f ? 9728 : 9729;
        }
        function G(e) {
          const i = e.target;
          i.removeEventListener("dispose", G),
            (function (e) {
              const i = n.get(e);
              void 0 !== i.__webglInit &&
                (t.deleteTexture(i.__webglTexture), n.remove(e));
            })(i),
            i.isVideoTexture && P.delete(i),
            a.memory.textures--;
        }
        function V(e) {
          const i = e.target;
          i.removeEventListener("dispose", V),
            (function (e) {
              const i = e.texture,
                r = n.get(e),
                s = n.get(i);
              if (e) {
                if (
                  (void 0 !== s.__webglTexture &&
                    (t.deleteTexture(s.__webglTexture), a.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]),
                      r.__webglDepthbuffer &&
                        t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                else
                  t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = i.length; e < r; e++) {
                    const r = n.get(i[e]);
                    r.__webglTexture &&
                      (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                      n.remove(i[e]);
                  }
                n.remove(i), n.remove(e);
              }
            })(i);
        }
        let W = 0;
        function j(t, e) {
          const r = n.get(t);
          if (
            (t.isVideoTexture &&
              (function (t) {
                const e = a.render.frame;
                P.get(t) !== e && (P.set(t, e), t.update());
              })(t),
            t.version > 0 && r.__version !== t.version)
          ) {
            const i = t.image;
            if (void 0 === i)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else {
              if (!1 !== i.complete) return void K(r, t, e);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture);
        }
        function q(e, r) {
          const a = n.get(e);
          e.version > 0 && a.__version !== e.version
            ? (function (e, n, r) {
                if (6 !== n.image.length) return;
                Z(e, n),
                  i.activeTexture(33984 + r),
                  i.bindTexture(34067, e.__webglTexture),
                  t.pixelStorei(37440, n.flipY),
                  t.pixelStorei(37441, n.premultiplyAlpha),
                  t.pixelStorei(3317, n.unpackAlignment),
                  t.pixelStorei(37443, 0);
                const a =
                    n &&
                    (n.isCompressedTexture || n.image[0].isCompressedTexture),
                  l = n.image[0] && n.image[0].isDataTexture,
                  c = [];
                for (let t = 0; t < 6; t++)
                  (c[t] =
                    a || l
                      ? l
                        ? n.image[t].image
                        : n.image[t]
                      : N(n.image[t], !1, !0, h)),
                    (c[t] = it(n, c[t]));
                const u = c[0],
                  d = O(u) || o,
                  p = s.convert(n.format, n.encoding),
                  m = s.convert(n.type),
                  f = H(n.internalFormat, p, m, n.encoding),
                  g = o && !0 !== n.isVideoTexture,
                  y = void 0 === e.__version;
                let x,
                  v = U(n, u, d);
                if ((J(34067, n, d), a)) {
                  g && y && i.texStorage2D(34067, v, f, u.width, u.height);
                  for (let t = 0; t < 6; t++) {
                    x = c[t].mipmaps;
                    for (let e = 0; e < x.length; e++) {
                      const r = x[e];
                      n.format !== T
                        ? null !== p
                          ? g
                            ? i.compressedTexSubImage2D(
                                34069 + t,
                                e,
                                0,
                                0,
                                r.width,
                                r.height,
                                p,
                                r.data
                              )
                            : i.compressedTexImage2D(
                                34069 + t,
                                e,
                                f,
                                r.width,
                                r.height,
                                0,
                                r.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : g
                        ? i.texSubImage2D(
                            34069 + t,
                            e,
                            0,
                            0,
                            r.width,
                            r.height,
                            p,
                            m,
                            r.data
                          )
                        : i.texImage2D(
                            34069 + t,
                            e,
                            f,
                            r.width,
                            r.height,
                            0,
                            p,
                            m,
                            r.data
                          );
                    }
                  }
                } else {
                  (x = n.mipmaps),
                    g &&
                      y &&
                      (x.length > 0 && v++,
                      i.texStorage2D(34067, v, f, c[0].width, c[0].height));
                  for (let t = 0; t < 6; t++)
                    if (l) {
                      g
                        ? i.texSubImage2D(
                            34069 + t,
                            0,
                            0,
                            0,
                            c[t].width,
                            c[t].height,
                            p,
                            m,
                            c[t].data
                          )
                        : i.texImage2D(
                            34069 + t,
                            0,
                            f,
                            c[t].width,
                            c[t].height,
                            0,
                            p,
                            m,
                            c[t].data
                          );
                      for (let e = 0; e < x.length; e++) {
                        const n = x[e].image[t].image;
                        g
                          ? i.texSubImage2D(
                              34069 + t,
                              e + 1,
                              0,
                              0,
                              n.width,
                              n.height,
                              p,
                              m,
                              n.data
                            )
                          : i.texImage2D(
                              34069 + t,
                              e + 1,
                              f,
                              n.width,
                              n.height,
                              0,
                              p,
                              m,
                              n.data
                            );
                      }
                    } else {
                      g
                        ? i.texSubImage2D(34069 + t, 0, 0, 0, p, m, c[t])
                        : i.texImage2D(34069 + t, 0, f, p, m, c[t]);
                      for (let e = 0; e < x.length; e++) {
                        const n = x[e];
                        g
                          ? i.texSubImage2D(
                              34069 + t,
                              e + 1,
                              0,
                              0,
                              p,
                              m,
                              n.image[t]
                            )
                          : i.texImage2D(34069 + t, e + 1, f, p, m, n.image[t]);
                      }
                    }
                }
                B(n, d) && F(34067),
                  (e.__version = n.version),
                  n.onUpdate && n.onUpdate(n);
              })(a, e, r)
            : (i.activeTexture(33984 + r),
              i.bindTexture(34067, a.__webglTexture));
        }
        const X = { [c]: 10497, [u]: 33071, [d]: 33648 },
          Y = {
            [p]: 9728,
            [m]: 9984,
            [f]: 9986,
            [g]: 9729,
            [y]: 9985,
            [x]: 9987,
          };
        function J(i, s, a) {
          if (
            (a
              ? (t.texParameteri(i, 10242, X[s.wrapS]),
                t.texParameteri(i, 10243, X[s.wrapT]),
                (32879 !== i && 35866 !== i) ||
                  t.texParameteri(i, 32882, X[s.wrapR]),
                t.texParameteri(i, 10240, Y[s.magFilter]),
                t.texParameteri(i, 10241, Y[s.minFilter]))
              : (t.texParameteri(i, 10242, 33071),
                t.texParameteri(i, 10243, 33071),
                (32879 !== i && 35866 !== i) ||
                  t.texParameteri(i, 32882, 33071),
                (s.wrapS === u && s.wrapT === u) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                t.texParameteri(i, 10240, k(s.magFilter)),
                t.texParameteri(i, 10241, k(s.minFilter)),
                s.minFilter !== p &&
                  s.minFilter !== g &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const a = e.get("EXT_texture_filter_anisotropic");
            if (s.type === M && !1 === e.has("OES_texture_float_linear"))
              return;
            if (
              !1 === o &&
              s.type === w &&
              !1 === e.has("OES_texture_half_float_linear")
            )
              return;
            (s.anisotropy > 1 || n.get(s).__currentAnisotropy) &&
              (t.texParameterf(
                i,
                a.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy())
              ),
              (n.get(s).__currentAnisotropy = s.anisotropy));
          }
        }
        function Z(e, i) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            i.addEventListener("dispose", G),
            (e.__webglTexture = t.createTexture()),
            a.memory.textures++);
        }
        function K(e, n, r) {
          let a = 3553;
          n.isDataTexture2DArray && (a = 35866),
            n.isDataTexture3D && (a = 32879),
            Z(e, n),
            i.activeTexture(33984 + r),
            i.bindTexture(a, e.__webglTexture),
            t.pixelStorei(37440, n.flipY),
            t.pixelStorei(37441, n.premultiplyAlpha),
            t.pixelStorei(3317, n.unpackAlignment),
            t.pixelStorei(37443, 0);
          const l =
            (function (t) {
              return (
                !o &&
                (t.wrapS !== u ||
                  t.wrapT !== u ||
                  (t.minFilter !== p && t.minFilter !== g))
              );
            })(n) && !1 === O(n.image);
          let h = N(n.image, l, !1, R);
          h = it(n, h);
          const c = O(h) || o,
            d = s.convert(n.format, n.encoding);
          let m,
            f = s.convert(n.type),
            y = H(n.internalFormat, d, f, n.encoding, n.isVideoTexture);
          J(a, n, c);
          const x = n.mipmaps,
            v = o && !0 !== n.isVideoTexture,
            w = void 0 === e.__version,
            L = U(n, h, c);
          if (n.isDepthTexture)
            (y = 6402),
              o
                ? (y =
                    n.type === M
                      ? 36012
                      : n.type === b
                      ? 33190
                      : n.type === S
                      ? 35056
                      : 33189)
                : n.type === M &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              n.format === E &&
                6402 === y &&
                n.type !== _ &&
                n.type !== b &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (n.type = _),
                (f = s.convert(n.type))),
              n.format === A &&
                6402 === y &&
                ((y = 34041),
                n.type !== S &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (n.type = S),
                  (f = s.convert(n.type)))),
              v && w
                ? i.texStorage2D(3553, 1, y, h.width, h.height)
                : i.texImage2D(3553, 0, y, h.width, h.height, 0, d, f, null);
          else if (n.isDataTexture)
            if (x.length > 0 && c) {
              v && w && i.texStorage2D(3553, L, y, x[0].width, x[0].height);
              for (let t = 0, e = x.length; t < e; t++)
                (m = x[t]),
                  v
                    ? i.texSubImage2D(
                        3553,
                        0,
                        0,
                        0,
                        m.width,
                        m.height,
                        d,
                        f,
                        m.data
                      )
                    : i.texImage2D(
                        3553,
                        t,
                        y,
                        m.width,
                        m.height,
                        0,
                        d,
                        f,
                        m.data
                      );
              n.generateMipmaps = !1;
            } else
              v
                ? (w && i.texStorage2D(3553, L, y, h.width, h.height),
                  i.texSubImage2D(
                    3553,
                    0,
                    0,
                    0,
                    h.width,
                    h.height,
                    d,
                    f,
                    h.data
                  ))
                : i.texImage2D(3553, 0, y, h.width, h.height, 0, d, f, h.data);
          else if (n.isCompressedTexture) {
            v && w && i.texStorage2D(3553, L, y, x[0].width, x[0].height);
            for (let t = 0, e = x.length; t < e; t++)
              (m = x[t]),
                n.format !== T
                  ? null !== d
                    ? v
                      ? i.compressedTexSubImage2D(
                          3553,
                          t,
                          0,
                          0,
                          m.width,
                          m.height,
                          d,
                          m.data
                        )
                      : i.compressedTexImage2D(
                          3553,
                          t,
                          y,
                          m.width,
                          m.height,
                          0,
                          m.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : v
                  ? i.texSubImage2D(
                      3553,
                      t,
                      0,
                      0,
                      m.width,
                      m.height,
                      d,
                      f,
                      m.data
                    )
                  : i.texImage2D(
                      3553,
                      t,
                      y,
                      m.width,
                      m.height,
                      0,
                      d,
                      f,
                      m.data
                    );
          } else if (n.isDataTexture2DArray)
            v
              ? (w && i.texStorage3D(35866, L, y, h.width, h.height, h.depth),
                i.texSubImage3D(
                  35866,
                  0,
                  0,
                  0,
                  0,
                  h.width,
                  h.height,
                  h.depth,
                  d,
                  f,
                  h.data
                ))
              : i.texImage3D(
                  35866,
                  0,
                  y,
                  h.width,
                  h.height,
                  h.depth,
                  0,
                  d,
                  f,
                  h.data
                );
          else if (n.isDataTexture3D)
            v
              ? (w && i.texStorage3D(32879, L, y, h.width, h.height, h.depth),
                i.texSubImage3D(
                  32879,
                  0,
                  0,
                  0,
                  0,
                  h.width,
                  h.height,
                  h.depth,
                  d,
                  f,
                  h.data
                ))
              : i.texImage3D(
                  32879,
                  0,
                  y,
                  h.width,
                  h.height,
                  h.depth,
                  0,
                  d,
                  f,
                  h.data
                );
          else if (n.isFramebufferTexture)
            v && w
              ? i.texStorage2D(3553, L, y, h.width, h.height)
              : i.texImage2D(3553, 0, y, h.width, h.height, 0, d, f, null);
          else if (x.length > 0 && c) {
            v && w && i.texStorage2D(3553, L, y, x[0].width, x[0].height);
            for (let t = 0, e = x.length; t < e; t++)
              (m = x[t]),
                v
                  ? i.texSubImage2D(3553, t, 0, 0, d, f, m)
                  : i.texImage2D(3553, t, y, d, f, m);
            n.generateMipmaps = !1;
          } else
            v
              ? (w && i.texStorage2D(3553, L, y, h.width, h.height),
                i.texSubImage2D(3553, 0, 0, 0, d, f, h))
              : i.texImage2D(3553, 0, y, d, f, h);
          B(n, c) && F(a),
            (e.__version = n.version),
            n.onUpdate && n.onUpdate(n);
        }
        function Q(e, r, a, o, l) {
          const h = s.convert(a.format, a.encoding),
            c = s.convert(a.type),
            u = H(a.internalFormat, h, c, a.encoding);
          n.get(r).__hasExternalTextures ||
            (32879 === l || 35866 === l
              ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null)
              : i.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)),
            i.bindFramebuffer(36160, e),
            r.useRenderToTexture
              ? C.framebufferTexture2DMultisampleEXT(
                  36160,
                  o,
                  l,
                  n.get(a).__webglTexture,
                  0,
                  et(r)
                )
              : t.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0),
            i.bindFramebuffer(36160, null);
        }
        function $(e, i, n) {
          if (
            (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer)
          ) {
            let r = 33189;
            if (n || i.useRenderToTexture) {
              const e = i.depthTexture;
              e &&
                e.isDepthTexture &&
                (e.type === M ? (r = 36012) : e.type === b && (r = 33190));
              const n = et(i);
              i.useRenderToTexture
                ? C.renderbufferStorageMultisampleEXT(
                    36161,
                    n,
                    r,
                    i.width,
                    i.height
                  )
                : t.renderbufferStorageMultisample(
                    36161,
                    n,
                    r,
                    i.width,
                    i.height
                  );
            } else t.renderbufferStorage(36161, r, i.width, i.height);
            t.framebufferRenderbuffer(36160, 36096, 36161, e);
          } else if (i.depthBuffer && i.stencilBuffer) {
            const r = et(i);
            n && i.useRenderbuffer
              ? t.renderbufferStorageMultisample(
                  36161,
                  r,
                  35056,
                  i.width,
                  i.height
                )
              : i.useRenderToTexture
              ? C.renderbufferStorageMultisampleEXT(
                  36161,
                  r,
                  35056,
                  i.width,
                  i.height
                )
              : t.renderbufferStorage(36161, 34041, i.width, i.height),
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
          } else {
            const e =
                !0 === i.isWebGLMultipleRenderTargets
                  ? i.texture[0]
                  : i.texture,
              r = s.convert(e.format, e.encoding),
              a = s.convert(e.type),
              o = H(e.internalFormat, r, a, e.encoding),
              l = et(i);
            n && i.useRenderbuffer
              ? t.renderbufferStorageMultisample(36161, l, o, i.width, i.height)
              : i.useRenderToTexture
              ? C.renderbufferStorageMultisampleEXT(
                  36161,
                  l,
                  o,
                  i.width,
                  i.height
                )
              : t.renderbufferStorage(36161, o, i.width, i.height);
          }
          t.bindRenderbuffer(36161, null);
        }
        function tt(e) {
          const r = n.get(e),
            s = !0 === e.isWebGLCubeRenderTarget;
          if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (e, r) {
              if (r && r.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (i.bindFramebuffer(36160, e),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (n.get(r.depthTexture).__webglTexture &&
                r.depthTexture.image.width === r.width &&
                r.depthTexture.image.height === r.height) ||
                ((r.depthTexture.image.width = r.width),
                (r.depthTexture.image.height = r.height),
                (r.depthTexture.needsUpdate = !0)),
                j(r.depthTexture, 0);
              const s = n.get(r.depthTexture).__webglTexture,
                a = et(r);
              if (r.depthTexture.format === E)
                r.useRenderToTexture
                  ? C.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      s,
                      0,
                      a
                    )
                  : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
              else {
                if (r.depthTexture.format !== A)
                  throw new Error("Unknown depthTexture format");
                r.useRenderToTexture
                  ? C.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      s,
                      0,
                      a
                    )
                  : t.framebufferTexture2D(36160, 33306, 3553, s, 0);
              }
            })(r.__webglFramebuffer, e);
          } else if (s) {
            r.__webglDepthbuffer = [];
            for (let n = 0; n < 6; n++)
              i.bindFramebuffer(36160, r.__webglFramebuffer[n]),
                (r.__webglDepthbuffer[n] = t.createRenderbuffer()),
                $(r.__webglDepthbuffer[n], e, !1);
          } else
            i.bindFramebuffer(36160, r.__webglFramebuffer),
              (r.__webglDepthbuffer = t.createRenderbuffer()),
              $(r.__webglDepthbuffer, e, !1);
          i.bindFramebuffer(36160, null);
        }
        function et(t) {
          return o && (t.useRenderbuffer || t.useRenderToTexture)
            ? Math.min(L, t.samples)
            : 0;
        }
        function it(t, i) {
          const n = t.encoding,
            r = t.format,
            s = t.type;
          return (
            !0 === t.isCompressedTexture ||
              !0 === t.isVideoTexture ||
              t.format === dt ||
              (n !== at &&
                (n === ot
                  ? !1 === o
                    ? !0 === e.has("EXT_sRGB") && r === T
                      ? ((t.format = dt),
                        (t.minFilter = g),
                        (t.generateMipmaps = !1))
                      : (i = Ut.sRGBToLinear(i))
                    : (r === T && s === v) ||
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      n
                    ))),
            i
          );
        }
        let nt = !1,
          rt = !1;
        (this.allocateTextureUnit = function () {
          const t = W;
          return (
            t >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  l
              ),
            (W += 1),
            t
          );
        }),
          (this.resetTextureUnits = function () {
            W = 0;
          }),
          (this.setTexture2D = j),
          (this.setTexture2DArray = function (t, e) {
            const r = n.get(t);
            t.version > 0 && r.__version !== t.version
              ? K(r, t, e)
              : (i.activeTexture(33984 + e),
                i.bindTexture(35866, r.__webglTexture));
          }),
          (this.setTexture3D = function (t, e) {
            const r = n.get(t);
            t.version > 0 && r.__version !== t.version
              ? K(r, t, e)
              : (i.activeTexture(33984 + e),
                i.bindTexture(32879, r.__webglTexture));
          }),
          (this.setTextureCube = q),
          (this.rebindTextures = function (t, e, i) {
            const r = n.get(t);
            void 0 !== e && Q(r.__webglFramebuffer, t, t.texture, 36064, 3553),
              void 0 !== i && tt(t);
          }),
          (this.setupRenderTarget = function (e) {
            const l = e.texture,
              h = n.get(e),
              c = n.get(l);
            e.addEventListener("dispose", V),
              !0 !== e.isWebGLMultipleRenderTargets &&
                (void 0 === c.__webglTexture &&
                  (c.__webglTexture = t.createTexture()),
                (c.__version = l.version),
                a.memory.textures++);
            const u = !0 === e.isWebGLCubeRenderTarget,
              d = !0 === e.isWebGLMultipleRenderTargets,
              p = l.isDataTexture3D || l.isDataTexture2DArray,
              m = O(e) || o;
            if (u) {
              h.__webglFramebuffer = [];
              for (let e = 0; e < 6; e++)
                h.__webglFramebuffer[e] = t.createFramebuffer();
            } else if (((h.__webglFramebuffer = t.createFramebuffer()), d))
              if (r.drawBuffers) {
                const i = e.texture;
                for (let e = 0, r = i.length; e < r; e++) {
                  const r = n.get(i[e]);
                  void 0 === r.__webglTexture &&
                    ((r.__webglTexture = t.createTexture()),
                    a.memory.textures++);
                }
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                );
            else if (e.useRenderbuffer)
              if (o) {
                (h.__webglMultisampledFramebuffer = t.createFramebuffer()),
                  (h.__webglColorRenderbuffer = t.createRenderbuffer()),
                  t.bindRenderbuffer(36161, h.__webglColorRenderbuffer);
                const n = s.convert(l.format, l.encoding),
                  r = s.convert(l.type),
                  a = H(l.internalFormat, n, r, l.encoding),
                  o = et(e);
                t.renderbufferStorageMultisample(
                  36161,
                  o,
                  a,
                  e.width,
                  e.height
                ),
                  i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                  t.framebufferRenderbuffer(
                    36160,
                    36064,
                    36161,
                    h.__webglColorRenderbuffer
                  ),
                  t.bindRenderbuffer(36161, null),
                  e.depthBuffer &&
                    ((h.__webglDepthRenderbuffer = t.createRenderbuffer()),
                    $(h.__webglDepthRenderbuffer, e, !0)),
                  i.bindFramebuffer(36160, null);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
            if (u) {
              i.bindTexture(34067, c.__webglTexture), J(34067, l, m);
              for (let t = 0; t < 6; t++)
                Q(h.__webglFramebuffer[t], e, l, 36064, 34069 + t);
              B(l, m) && F(34067), i.unbindTexture();
            } else if (d) {
              const t = e.texture;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = n.get(s);
                i.bindTexture(3553, a.__webglTexture),
                  J(3553, s, m),
                  Q(h.__webglFramebuffer, e, s, 36064 + r, 3553),
                  B(s, m) && F(3553);
              }
              i.unbindTexture();
            } else {
              let t = 3553;
              p &&
                (o
                  ? (t = l.isDataTexture3D ? 32879 : 35866)
                  : console.warn(
                      "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                    )),
                i.bindTexture(t, c.__webglTexture),
                J(t, l, m),
                Q(h.__webglFramebuffer, e, l, 36064, t),
                B(l, m) && F(t),
                i.unbindTexture();
            }
            e.depthBuffer && tt(e);
          }),
          (this.updateRenderTargetMipmap = function (t) {
            const e = O(t) || o,
              r =
                !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
            for (let s = 0, a = r.length; s < a; s++) {
              const a = r[s];
              if (B(a, e)) {
                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  r = n.get(a).__webglTexture;
                i.bindTexture(e, r), F(e), i.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (e) {
            if (e.useRenderbuffer)
              if (o) {
                const r = e.width,
                  s = e.height;
                let a = 16384;
                const o = [36064],
                  l = e.stencilBuffer ? 33306 : 36096;
                e.depthBuffer && o.push(l),
                  e.ignoreDepthForMultisampleCopy ||
                    (e.depthBuffer && (a |= 256),
                    e.stencilBuffer && (a |= 1024));
                const h = n.get(e);
                i.bindFramebuffer(36008, h.__webglMultisampledFramebuffer),
                  i.bindFramebuffer(36009, h.__webglFramebuffer),
                  e.ignoreDepthForMultisampleCopy &&
                    (t.invalidateFramebuffer(36008, [l]),
                    t.invalidateFramebuffer(36009, [l])),
                  t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                  t.invalidateFramebuffer(36008, o),
                  i.bindFramebuffer(36008, null),
                  i.bindFramebuffer(36009, h.__webglMultisampledFramebuffer);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
          }),
          (this.setupDepthRenderbuffer = tt),
          (this.setupFrameBufferTexture = Q),
          (this.safeSetTexture2D = function (t, e) {
            t &&
              t.isWebGLRenderTarget &&
              (!1 === nt &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (nt = !0)),
              (t = t.texture)),
              j(t, e);
          }),
          (this.safeSetTextureCube = function (t, e) {
            t &&
              t.isWebGLCubeRenderTarget &&
              (!1 === rt &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (rt = !0)),
              (t = t.texture)),
              q(t, e);
          });
      }
      function Ys(t, e, i) {
        const n = i.isWebGL2;
        return {
          convert: function (t, i = null) {
            let r;
            if (t === v) return 5121;
            if (1017 === t) return 32819;
            if (1018 === t) return 32820;
            if (1010 === t) return 5120;
            if (1011 === t) return 5122;
            if (t === _) return 5123;
            if (1013 === t) return 5124;
            if (t === b) return 5125;
            if (t === M) return 5126;
            if (t === w)
              return n
                ? 5131
                : ((r = e.get("OES_texture_half_float")),
                  null !== r ? r.HALF_FLOAT_OES : null);
            if (1021 === t) return 6406;
            if (t === T) return 6408;
            if (1024 === t) return 6409;
            if (1025 === t) return 6410;
            if (t === E) return 6402;
            if (t === A) return 34041;
            if (1028 === t) return 6403;
            if (1022 === t)
              return (
                console.warn(
                  "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
                ),
                6408
              );
            if (t === dt)
              return (
                (r = e.get("EXT_sRGB")), null !== r ? r.SRGB_ALPHA_EXT : null
              );
            if (1029 === t) return 36244;
            if (1030 === t) return 33319;
            if (1031 === t) return 33320;
            if (1033 === t) return 36249;
            if (t === R || t === L || t === C || t === P)
              if (i === ot) {
                if (
                  ((r = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === r)
                )
                  return null;
                if (t === R) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (t === L) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (t === C) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (t === P) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((r = e.get("WEBGL_compressed_texture_s3tc")), null === r))
                  return null;
                if (t === R) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === L) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === C) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === P) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (t === I || t === z || t === D || t === N) {
              if (((r = e.get("WEBGL_compressed_texture_pvrtc")), null === r))
                return null;
              if (t === I) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (t === z) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (t === D) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (t === N) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === t)
              return (
                (r = e.get("WEBGL_compressed_texture_etc1")),
                null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (t === O || t === B) {
              if (((r = e.get("WEBGL_compressed_texture_etc")), null === r))
                return null;
              if (t === O)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ETC2
                  : r.COMPRESSED_RGB8_ETC2;
              if (t === B)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : r.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              t === F ||
              t === H ||
              t === U ||
              t === k ||
              t === G ||
              t === V ||
              t === W ||
              t === j ||
              t === q ||
              t === X ||
              t === Y ||
              t === J ||
              t === Z ||
              t === K
            ) {
              if (((r = e.get("WEBGL_compressed_texture_astc")), null === r))
                return null;
              if (t === F)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (t === H)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (t === U)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (t === k)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (t === G)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (t === V)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (t === W)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (t === j)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (t === q)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (t === X)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (t === Y)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (t === J)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (t === Z)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (t === K)
                return i === ot
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (t === Q) {
              if (((r = e.get("EXT_texture_compression_bptc")), null === r))
                return null;
              if (t === Q)
                return i === ot
                  ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            return t === S
              ? n
                ? 34042
                : ((r = e.get("WEBGL_depth_texture")),
                  null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0;
          },
        };
      }
      Ws.prototype.isMeshDistanceMaterial = !0;
      class Js extends sn {
        constructor(t = []) {
          super(), (this.cameras = t);
        }
      }
      Js.prototype.isArrayCamera = !0;
      class Zs extends Ke {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      Zs.prototype.isGroup = !0;
      const Ks = { type: "move" };
      class Qs {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new Zs()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new Zs()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new Jt()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new Jt())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new Zs()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new Jt()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new Jt())),
            this._grip
          );
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          );
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: "disconnected", data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(t, e, i) {
          let n = null,
            r = null,
            s = null;
          const a = this._targetRay,
            o = this._grip,
            l = this._hand;
          if (t && "visible-blurred" !== e.session.visibilityState)
            if (
              (null !== a &&
                ((n = e.getPose(t.targetRaySpace, i)),
                null !== n &&
                  (a.matrix.fromArray(n.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  n.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(n.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  n.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(n.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(Ks))),
              l && t.hand)
            ) {
              s = !0;
              for (const n of t.hand.values()) {
                const t = e.getJointPose(n, i);
                if (void 0 === l.joints[n.jointName]) {
                  const t = new Zs();
                  (t.matrixAutoUpdate = !1),
                    (t.visible = !1),
                    (l.joints[n.jointName] = t),
                    l.add(t);
                }
                const r = l.joints[n.jointName];
                null !== t &&
                  (r.matrix.fromArray(t.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.jointRadius = t.radius)),
                  (r.visible = null !== t);
              }
              const n = l.joints["index-finger-tip"],
                r = l.joints["thumb-tip"],
                a = n.position.distanceTo(r.position),
                o = 0.02,
                h = 0.005;
              l.inputState.pinching && a > o + h
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  a <= o - h &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            } else
              null !== o &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, i)),
                null !== r &&
                  (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  r.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(r.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(r.angularVelocity))
                    : (o.hasAngularVelocity = !1)));
          return (
            null !== a && (a.visible = null !== n),
            null !== o && (o.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
          );
        }
      }
      class $s extends Gt {
        constructor(t, e, i, n, r, s, a, o, l, h) {
          if ((h = void 0 !== h ? h : E) !== E && h !== A)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === i && h === E && (i = _),
            void 0 === i && h === A && (i = S),
            super(null, n, r, s, a, o, h, i, l),
            (this.image = { width: t, height: e }),
            (this.magFilter = void 0 !== a ? a : p),
            (this.minFilter = void 0 !== o ? o : p),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      $s.prototype.isDepthTexture = !0;
      class ta extends pt {
        constructor(t, e) {
          super();
          const i = this;
          let n = null,
            r = 1,
            s = null,
            a = "local-floor";
          const o = t.extensions.has("WEBGL_multisampled_render_to_texture");
          let l = null,
            h = null,
            c = null,
            u = null,
            d = !1,
            p = null;
          const m = e.getContextAttributes();
          let f = null,
            g = null;
          const y = [],
            x = new Map(),
            b = new sn();
          b.layers.enable(1), (b.viewport = new Wt());
          const M = new sn();
          M.layers.enable(2), (M.viewport = new Wt());
          const w = [b, M],
            R = new Js();
          R.layers.enable(1), R.layers.enable(2);
          let L = null,
            C = null;
          function P(t) {
            const e = x.get(t.inputSource);
            e && e.dispatchEvent({ type: t.type, data: t.inputSource });
          }
          function I() {
            x.forEach(function (t, e) {
              t.disconnect(e);
            }),
              x.clear(),
              (L = null),
              (C = null),
              t.setRenderTarget(f),
              (u = null),
              (c = null),
              (h = null),
              (n = null),
              (g = null),
              F.stop(),
              (i.isPresenting = !1),
              i.dispatchEvent({ type: "sessionend" });
          }
          function z(t) {
            const e = n.inputSources;
            for (let t = 0; t < y.length; t++) x.set(e[t], y[t]);
            for (let e = 0; e < t.removed.length; e++) {
              const i = t.removed[e],
                n = x.get(i);
              n &&
                (n.dispatchEvent({ type: "disconnected", data: i }),
                x.delete(i));
            }
            for (let e = 0; e < t.added.length; e++) {
              const i = t.added[e],
                n = x.get(i);
              n && n.dispatchEvent({ type: "connected", data: i });
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = y[t];
              return (
                void 0 === e && ((e = new Qs()), (y[t] = e)),
                e.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (t) {
              let e = y[t];
              return (
                void 0 === e && ((e = new Qs()), (y[t] = e)), e.getGripSpace()
              );
            }),
            (this.getHand = function (t) {
              let e = y[t];
              return (
                void 0 === e && ((e = new Qs()), (y[t] = e)), e.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (t) {
              (r = t),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (t) {
              (a = t),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return s;
            }),
            (this.getBaseLayer = function () {
              return null !== c ? c : u;
            }),
            (this.getBinding = function () {
              return h;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return n;
            }),
            (this.setSession = async function (l) {
              if (((n = l), null !== n)) {
                if (
                  ((f = t.getRenderTarget()),
                  n.addEventListener("select", P),
                  n.addEventListener("selectstart", P),
                  n.addEventListener("selectend", P),
                  n.addEventListener("squeeze", P),
                  n.addEventListener("squeezestart", P),
                  n.addEventListener("squeezeend", P),
                  n.addEventListener("end", I),
                  n.addEventListener("inputsourceschange", z),
                  !0 !== m.xrCompatible && (await e.makeXRCompatible()),
                  void 0 === n.renderState.layers ||
                    !1 === t.capabilities.isWebGL2)
                ) {
                  const i = {
                    antialias: void 0 !== n.renderState.layers || m.antialias,
                    alpha: m.alpha,
                    depth: m.depth,
                    stencil: m.stencil,
                    framebufferScaleFactor: r,
                  };
                  (u = new XRWebGLLayer(n, e, i)),
                    n.updateRenderState({ baseLayer: u }),
                    (g = new jt(u.framebufferWidth, u.framebufferHeight, {
                      format: T,
                      type: v,
                      encoding: t.outputEncoding,
                    }));
                } else {
                  d = m.antialias;
                  let i = null,
                    s = null,
                    a = null;
                  m.depth &&
                    ((a = m.stencil ? 35056 : 33190),
                    (i = m.stencil ? A : E),
                    (s = m.stencil ? S : _));
                  const l = {
                    colorFormat: t.outputEncoding === ot ? 35907 : 32856,
                    depthFormat: a,
                    scaleFactor: r,
                  };
                  (h = new XRWebGLBinding(n, e)),
                    (c = h.createProjectionLayer(l)),
                    n.updateRenderState({ layers: [c] }),
                    (g = d
                      ? new Xt(c.textureWidth, c.textureHeight, {
                          format: T,
                          type: v,
                          depthTexture: new $s(
                            c.textureWidth,
                            c.textureHeight,
                            s,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            i
                          ),
                          stencilBuffer: m.stencil,
                          ignoreDepth: c.ignoreDepthValues,
                          useRenderToTexture: o,
                          encoding: t.outputEncoding,
                        })
                      : new jt(c.textureWidth, c.textureHeight, {
                          format: T,
                          type: v,
                          depthTexture: new $s(
                            c.textureWidth,
                            c.textureHeight,
                            s,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            i
                          ),
                          stencilBuffer: m.stencil,
                          ignoreDepth: c.ignoreDepthValues,
                          encoding: t.outputEncoding,
                        }));
                }
                (g.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (s = await n.requestReferenceSpace(a)),
                  F.setContext(n),
                  F.start(),
                  (i.isPresenting = !0),
                  i.dispatchEvent({ type: "sessionstart" });
              }
            });
          const D = new Jt(),
            N = new Jt();
          function O(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
          }
          (this.updateCamera = function (t) {
            if (null === n) return;
            (R.near = M.near = b.near = t.near),
              (R.far = M.far = b.far = t.far),
              (L === R.near && C === R.far) ||
                (n.updateRenderState({ depthNear: R.near, depthFar: R.far }),
                (L = R.near),
                (C = R.far));
            const e = t.parent,
              i = R.cameras;
            O(R, e);
            for (let t = 0; t < i.length; t++) O(i[t], e);
            R.matrixWorld.decompose(R.position, R.quaternion, R.scale),
              t.position.copy(R.position),
              t.quaternion.copy(R.quaternion),
              t.scale.copy(R.scale),
              t.matrix.copy(R.matrix),
              t.matrixWorld.copy(R.matrixWorld);
            const r = t.children;
            for (let t = 0, e = r.length; t < e; t++)
              r[t].updateMatrixWorld(!0);
            2 === i.length
              ? (function (t, e, i) {
                  D.setFromMatrixPosition(e.matrixWorld),
                    N.setFromMatrixPosition(i.matrixWorld);
                  const n = D.distanceTo(N),
                    r = e.projectionMatrix.elements,
                    s = i.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    h = (r[9] - 1) / r[5],
                    c = (r[8] - 1) / r[0],
                    u = (s[8] + 1) / s[0],
                    d = a * c,
                    p = a * u,
                    m = n / (-c + u),
                    f = m * -c;
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(f),
                    t.translateZ(m),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                  const g = a + m,
                    y = o + m,
                    x = d - f,
                    v = p + (n - f),
                    _ = ((l * o) / y) * g,
                    b = ((h * o) / y) * g;
                  t.projectionMatrix.makePerspective(x, v, _, b, g, y);
                })(R, b, M)
              : R.projectionMatrix.copy(b.projectionMatrix);
          }),
            (this.getCamera = function () {
              return R;
            }),
            (this.getFoveation = function () {
              return null !== c
                ? c.fixedFoveation
                : null !== u
                ? u.fixedFoveation
                : void 0;
            }),
            (this.setFoveation = function (t) {
              null !== c && (c.fixedFoveation = t),
                null !== u &&
                  void 0 !== u.fixedFoveation &&
                  (u.fixedFoveation = t);
            });
          let B = null;
          const F = new yn();
          F.setAnimationLoop(function (e, i) {
            if (((l = i.getViewerPose(s)), (p = i), null !== l)) {
              const e = l.views;
              null !== u &&
                (t.setRenderTargetFramebuffer(g, u.framebuffer),
                t.setRenderTarget(g));
              let i = !1;
              e.length !== R.cameras.length &&
                ((R.cameras.length = 0), (i = !0));
              for (let n = 0; n < e.length; n++) {
                const r = e[n];
                let s = null;
                if (null !== u) s = u.getViewport(r);
                else {
                  const e = h.getViewSubImage(c, r);
                  (s = e.viewport),
                    0 === n &&
                      (t.setRenderTargetTextures(
                        g,
                        e.colorTexture,
                        c.ignoreDepthValues ? void 0 : e.depthStencilTexture
                      ),
                      t.setRenderTarget(g));
                }
                const a = w[n];
                a.matrix.fromArray(r.transform.matrix),
                  a.projectionMatrix.fromArray(r.projectionMatrix),
                  a.viewport.set(s.x, s.y, s.width, s.height),
                  0 === n && R.matrix.copy(a.matrix),
                  !0 === i && R.cameras.push(a);
              }
            }
            const r = n.inputSources;
            for (let t = 0; t < y.length; t++) {
              const e = y[t],
                n = r[t];
              e.update(n, i, s);
            }
            B && B(e, i), (p = null);
          }),
            (this.setAnimationLoop = function (t) {
              B = t;
            }),
            (this.dispose = function () {});
        }
      }
      function ea(t) {
        function e(e, i) {
          (e.opacity.value = i.opacity),
            i.color && e.diffuse.value.copy(i.color),
            i.emissive &&
              e.emissive.value
                .copy(i.emissive)
                .multiplyScalar(i.emissiveIntensity),
            i.map && (e.map.value = i.map),
            i.alphaMap && (e.alphaMap.value = i.alphaMap),
            i.specularMap && (e.specularMap.value = i.specularMap),
            i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
          const n = t.get(i).envMap;
          let r, s;
          n &&
            ((e.envMap.value = n),
            (e.flipEnvMap.value =
              n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1),
            (e.reflectivity.value = i.reflectivity),
            (e.ior.value = i.ior),
            (e.refractionRatio.value = i.refractionRatio)),
            i.lightMap &&
              ((e.lightMap.value = i.lightMap),
              (e.lightMapIntensity.value = i.lightMapIntensity)),
            i.aoMap &&
              ((e.aoMap.value = i.aoMap),
              (e.aoMapIntensity.value = i.aoMapIntensity)),
            i.map
              ? (r = i.map)
              : i.specularMap
              ? (r = i.specularMap)
              : i.displacementMap
              ? (r = i.displacementMap)
              : i.normalMap
              ? (r = i.normalMap)
              : i.bumpMap
              ? (r = i.bumpMap)
              : i.roughnessMap
              ? (r = i.roughnessMap)
              : i.metalnessMap
              ? (r = i.metalnessMap)
              : i.alphaMap
              ? (r = i.alphaMap)
              : i.emissiveMap
              ? (r = i.emissiveMap)
              : i.clearcoatMap
              ? (r = i.clearcoatMap)
              : i.clearcoatNormalMap
              ? (r = i.clearcoatNormalMap)
              : i.clearcoatRoughnessMap
              ? (r = i.clearcoatRoughnessMap)
              : i.specularIntensityMap
              ? (r = i.specularIntensityMap)
              : i.specularColorMap
              ? (r = i.specularColorMap)
              : i.transmissionMap
              ? (r = i.transmissionMap)
              : i.thicknessMap
              ? (r = i.thicknessMap)
              : i.sheenColorMap
              ? (r = i.sheenColorMap)
              : i.sheenRoughnessMap && (r = i.sheenRoughnessMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix)),
            i.aoMap ? (s = i.aoMap) : i.lightMap && (s = i.lightMap),
            void 0 !== s &&
              (s.isWebGLRenderTarget && (s = s.texture),
              !0 === s.matrixAutoUpdate && s.updateMatrix(),
              e.uv2Transform.value.copy(s.matrix));
        }
        function i(e, i) {
          (e.roughness.value = i.roughness),
            (e.metalness.value = i.metalness),
            i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
            i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
            i.emissiveMap && (e.emissiveMap.value = i.emissiveMap),
            i.bumpMap &&
              ((e.bumpMap.value = i.bumpMap),
              (e.bumpScale.value = i.bumpScale),
              1 === i.side && (e.bumpScale.value *= -1)),
            i.normalMap &&
              ((e.normalMap.value = i.normalMap),
              e.normalScale.value.copy(i.normalScale),
              1 === i.side && e.normalScale.value.negate()),
            i.displacementMap &&
              ((e.displacementMap.value = i.displacementMap),
              (e.displacementScale.value = i.displacementScale),
              (e.displacementBias.value = i.displacementBias)),
            t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
        }
        return {
          refreshFogUniforms: function (t, e) {
            t.fogColor.value.copy(e.color),
              e.isFog
                ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                : e.isFogExp2 && (t.fogDensity.value = e.density);
          },
          refreshMaterialUniforms: function (t, n, r, s, a) {
            n.isMeshBasicMaterial
              ? e(t, n)
              : n.isMeshLambertMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(t, n))
              : n.isMeshToonMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.gradientMap && (t.gradientMap.value = e.gradientMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, n))
              : n.isMeshPhongMaterial
              ? (e(t, n),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, n))
              : n.isMeshStandardMaterial
              ? (e(t, n),
                n.isMeshPhysicalMaterial
                  ? (function (t, e, n) {
                      i(t, e),
                        (t.ior.value = e.ior),
                        e.sheen > 0 &&
                          (t.sheenColor.value
                            .copy(e.sheenColor)
                            .multiplyScalar(e.sheen),
                          (t.sheenRoughness.value = e.sheenRoughness),
                          e.sheenColorMap &&
                            (t.sheenColorMap.value = e.sheenColorMap),
                          e.sheenRoughnessMap &&
                            (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
                        e.clearcoat > 0 &&
                          ((t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.clearcoatMap &&
                            (t.clearcoatMap.value = e.clearcoatMap),
                          e.clearcoatRoughnessMap &&
                            (t.clearcoatRoughnessMap.value =
                              e.clearcoatRoughnessMap),
                          e.clearcoatNormalMap &&
                            (t.clearcoatNormalScale.value.copy(
                              e.clearcoatNormalScale
                            ),
                            (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            1 === e.side &&
                              t.clearcoatNormalScale.value.negate())),
                        e.transmission > 0 &&
                          ((t.transmission.value = e.transmission),
                          (t.transmissionSamplerMap.value = n.texture),
                          t.transmissionSamplerSize.value.set(
                            n.width,
                            n.height
                          ),
                          e.transmissionMap &&
                            (t.transmissionMap.value = e.transmissionMap),
                          (t.thickness.value = e.thickness),
                          e.thicknessMap &&
                            (t.thicknessMap.value = e.thicknessMap),
                          (t.attenuationDistance.value = e.attenuationDistance),
                          t.attenuationColor.value.copy(e.attenuationColor)),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularColor.value.copy(e.specularColor),
                        e.specularIntensityMap &&
                          (t.specularIntensityMap.value =
                            e.specularIntensityMap),
                        e.specularColorMap &&
                          (t.specularColorMap.value = e.specularColorMap);
                    })(t, n, a)
                  : i(t, n))
              : n.isMeshMatcapMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, n))
              : n.isMeshDepthMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(t, n))
              : n.isMeshDistanceMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                    t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance);
                })(t, n))
              : n.isMeshNormalMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, n))
              : n.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                })(t, n),
                n.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(t, n))
              : n.isPointsMaterial
              ? (function (t, e, i, n) {
                  let r;
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * i),
                    (t.scale.value = 0.5 * n),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix));
                })(t, n, r, s)
              : n.isSpriteMaterial
              ? (function (t, e) {
                  let i;
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                    void 0 !== i &&
                      (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                      t.uvTransform.value.copy(i.matrix));
                })(t, n)
              : n.isShadowMaterial
              ? (t.color.value.copy(n.color), (t.opacity.value = n.opacity))
              : n.isShaderMaterial && (n.uniformsNeedUpdate = !1);
          },
        };
      }
      function ia(t = {}) {
        const e =
            void 0 !== t.canvas
              ? t.canvas
              : (function () {
                  const t = Pt("canvas");
                  return (t.style.display = "block"), t;
                })(),
          i = void 0 !== t.context ? t.context : null,
          n = void 0 !== t.alpha && t.alpha,
          r = void 0 === t.depth || t.depth,
          s = void 0 === t.stencil || t.stencil,
          a = void 0 !== t.antialias && t.antialias,
          o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          h = void 0 !== t.powerPreference ? t.powerPreference : "default",
          c =
            void 0 !== t.failIfMajorPerformanceCaveat &&
            t.failIfMajorPerformanceCaveat;
        let d = null,
          m = null;
        const f = [],
          g = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = at),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1);
        const y = this;
        let _ = !1,
          b = 0,
          S = 0,
          E = null,
          A = -1,
          R = null;
        const L = new Wt(),
          C = new Wt();
        let P = null,
          I = e.width,
          z = e.height,
          D = 1,
          N = null,
          O = null;
        const B = new Wt(0, 0, I, z),
          F = new Wt(0, 0, I, z);
        let H = !1;
        const U = new gn();
        let k = !1,
          G = !1,
          V = null;
        const W = new Ee(),
          j = new Jt(),
          q = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function X() {
          return null === E ? D : 1;
        }
        let Y,
          J,
          Z,
          K,
          Q,
          $,
          tt,
          et,
          it,
          nt,
          rt,
          st,
          ot,
          lt,
          ht,
          ct,
          ut,
          dt,
          pt,
          mt,
          ft,
          gt,
          yt,
          xt = i;
        function vt(t, i) {
          for (let n = 0; n < t.length; n++) {
            const r = t[n],
              s = e.getContext(r, i);
            if (null !== s) return s;
          }
          return null;
        }
        try {
          const t = {
            alpha: !0,
            depth: r,
            stencil: s,
            antialias: a,
            premultipliedAlpha: o,
            preserveDrawingBuffer: l,
            powerPreference: h,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", "three.js r137"),
            e.addEventListener("webglcontextlost", Mt, !1),
            e.addEventListener("webglcontextrestored", wt, !1),
            null === xt)
          ) {
            const e = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === y.isWebGL1Renderer && e.shift(),
              (xt = vt(e, t)),
              null === xt)
            )
              throw vt(e)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === xt.getShaderPrecisionFormat &&
            (xt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (t) {
          throw (console.error("THREE.WebGLRenderer: " + t.message), t);
        }
        function _t() {
          (Y = new Jn(xt)),
            (J = new En(xt, Y, t)),
            Y.init(J),
            (gt = new Ys(xt, Y, J)),
            (Z = new qs(xt, Y, J)),
            (K = new Qn(xt)),
            (Q = new Is()),
            ($ = new Xs(xt, Y, Z, Q, J, gt, K)),
            (tt = new Rn(y)),
            (et = new Yn(y)),
            (it = new xn(xt, J)),
            (yt = new Sn(xt, Y, it, J)),
            (nt = new Zn(xt, it, K, yt)),
            (rt = new rr(xt, nt, it, K)),
            (pt = new nr(xt, J, $)),
            (ct = new An(Q)),
            (st = new Ps(y, tt, et, Y, J, yt, ct)),
            (ot = new ea(Q)),
            (lt = new Os()),
            (ht = new Gs(Y, J)),
            (dt = new wn(y, tt, Z, rt, n, o)),
            (ut = new js(y, rt, J)),
            (mt = new Tn(xt, Y, K, J)),
            (ft = new Kn(xt, Y, K, J)),
            (K.programs = st.programs),
            (y.capabilities = J),
            (y.extensions = Y),
            (y.properties = Q),
            (y.renderLists = lt),
            (y.shadowMap = ut),
            (y.state = Z),
            (y.info = K);
        }
        _t();
        const bt = new ta(y, xt);
        function Mt(t) {
          t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (_ = !0);
        }
        function wt() {
          console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
          const t = K.autoReset,
            e = ut.enabled,
            i = ut.autoUpdate,
            n = ut.needsUpdate,
            r = ut.type;
          _t(),
            (K.autoReset = t),
            (ut.enabled = e),
            (ut.autoUpdate = i),
            (ut.needsUpdate = n),
            (ut.type = r);
        }
        function St(t) {
          const e = t.target;
          e.removeEventListener("dispose", St),
            (function (t) {
              (function (t) {
                const e = Q.get(t).programs;
                void 0 !== e &&
                  (e.forEach(function (t) {
                    st.releaseProgram(t);
                  }),
                  t.isShaderMaterial && st.releaseShaderCache(t));
              })(t),
                Q.remove(t);
            })(e);
        }
        (this.xr = bt),
          (this.getContext = function () {
            return xt;
          }),
          (this.getContextAttributes = function () {
            return xt.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const t = Y.get("WEBGL_lose_context");
            t && t.loseContext();
          }),
          (this.forceContextRestore = function () {
            const t = Y.get("WEBGL_lose_context");
            t && t.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return D;
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((D = t), this.setSize(I, z, !1));
          }),
          (this.getSize = function (t) {
            return t.set(I, z);
          }),
          (this.setSize = function (t, i, n) {
            bt.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((I = t),
                (z = i),
                (e.width = Math.floor(t * D)),
                (e.height = Math.floor(i * D)),
                !1 !== n &&
                  ((e.style.width = t + "px"), (e.style.height = i + "px")),
                this.setViewport(0, 0, t, i));
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(I * D, z * D).floor();
          }),
          (this.setDrawingBufferSize = function (t, i, n) {
            (I = t),
              (z = i),
              (D = n),
              (e.width = Math.floor(t * n)),
              (e.height = Math.floor(i * n)),
              this.setViewport(0, 0, t, i);
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(L);
          }),
          (this.getViewport = function (t) {
            return t.copy(B);
          }),
          (this.setViewport = function (t, e, i, n) {
            t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, i, n),
              Z.viewport(L.copy(B).multiplyScalar(D).floor());
          }),
          (this.getScissor = function (t) {
            return t.copy(F);
          }),
          (this.setScissor = function (t, e, i, n) {
            t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, i, n),
              Z.scissor(C.copy(F).multiplyScalar(D).floor());
          }),
          (this.getScissorTest = function () {
            return H;
          }),
          (this.setScissorTest = function (t) {
            Z.setScissorTest((H = t));
          }),
          (this.setOpaqueSort = function (t) {
            N = t;
          }),
          (this.setTransparentSort = function (t) {
            O = t;
          }),
          (this.getClearColor = function (t) {
            return t.copy(dt.getClearColor());
          }),
          (this.setClearColor = function () {
            dt.setClearColor.apply(dt, arguments);
          }),
          (this.getClearAlpha = function () {
            return dt.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            dt.setClearAlpha.apply(dt, arguments);
          }),
          (this.clear = function (t, e, i) {
            let n = 0;
            (void 0 === t || t) && (n |= 16384),
              (void 0 === e || e) && (n |= 256),
              (void 0 === i || i) && (n |= 1024),
              xt.clear(n);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", Mt, !1),
              e.removeEventListener("webglcontextrestored", wt, !1),
              lt.dispose(),
              ht.dispose(),
              Q.dispose(),
              tt.dispose(),
              et.dispose(),
              rt.dispose(),
              yt.dispose(),
              st.dispose(),
              bt.dispose(),
              bt.removeEventListener("sessionstart", Et),
              bt.removeEventListener("sessionend", At),
              V && (V.dispose(), (V = null)),
              Rt.stop();
          }),
          (this.renderBufferDirect = function (t, e, i, n, r, s) {
            null === e && (e = q);
            const a = r.isMesh && r.matrixWorld.determinant() < 0,
              o = (function (t, e, i, n, r) {
                !0 !== e.isScene && (e = q), $.resetTextureUnits();
                const s = e.fog,
                  a = n.isMeshStandardMaterial ? e.environment : null,
                  o =
                    null === E
                      ? y.outputEncoding
                      : !0 === E.isXRRenderTarget
                      ? E.texture.encoding
                      : at,
                  l = (n.isMeshStandardMaterial ? et : tt).get(n.envMap || a),
                  h =
                    !0 === n.vertexColors &&
                    !!i.attributes.color &&
                    4 === i.attributes.color.itemSize,
                  c = !!n.normalMap && !!i.attributes.tangent,
                  u = !!i.morphAttributes.position,
                  d = !!i.morphAttributes.normal,
                  p = i.morphAttributes.position
                    ? i.morphAttributes.position.length
                    : 0,
                  f = n.toneMapped ? y.toneMapping : 0,
                  g = Q.get(n),
                  x = m.state.lights;
                if (!0 === k && (!0 === G || t !== R)) {
                  const e = t === R && n.id === A;
                  ct.setState(n, t, e);
                }
                let v = !1;
                n.version === g.__version
                  ? (g.needsLights &&
                      g.lightsStateVersion !== x.state.version) ||
                    g.outputEncoding !== o ||
                    (r.isInstancedMesh && !1 === g.instancing)
                    ? (v = !0)
                    : r.isInstancedMesh || !0 !== g.instancing
                    ? r.isSkinnedMesh && !1 === g.skinning
                      ? (v = !0)
                      : r.isSkinnedMesh || !0 !== g.skinning
                      ? g.envMap !== l || (n.fog && g.fog !== s)
                        ? (v = !0)
                        : void 0 === g.numClippingPlanes ||
                          (g.numClippingPlanes === ct.numPlanes &&
                            g.numIntersection === ct.numIntersection)
                        ? (g.vertexAlphas !== h ||
                            g.vertexTangents !== c ||
                            g.morphTargets !== u ||
                            g.morphNormals !== d ||
                            g.toneMapping !== f ||
                            (!0 === J.isWebGL2 && g.morphTargetsCount !== p)) &&
                          (v = !0)
                        : (v = !0)
                      : (v = !0)
                    : (v = !0)
                  : ((v = !0), (g.__version = n.version));
                let _ = g.currentProgram;
                !0 === v && (_ = Dt(n, e, r));
                let b = !1,
                  M = !1,
                  w = !1;
                const S = _.getUniforms(),
                  T = g.uniforms;
                if (
                  (Z.useProgram(_.program) && ((b = !0), (M = !0), (w = !0)),
                  n.id !== A && ((A = n.id), (M = !0)),
                  b || R !== t)
                ) {
                  if (
                    (S.setValue(xt, "projectionMatrix", t.projectionMatrix),
                    J.logarithmicDepthBuffer &&
                      S.setValue(
                        xt,
                        "logDepthBufFC",
                        2 / (Math.log(t.far + 1) / Math.LN2)
                      ),
                    R !== t && ((R = t), (M = !0), (w = !0)),
                    n.isShaderMaterial ||
                      n.isMeshPhongMaterial ||
                      n.isMeshToonMaterial ||
                      n.isMeshStandardMaterial ||
                      n.envMap)
                  ) {
                    const e = S.map.cameraPosition;
                    void 0 !== e &&
                      e.setValue(xt, j.setFromMatrixPosition(t.matrixWorld));
                  }
                  (n.isMeshPhongMaterial ||
                    n.isMeshToonMaterial ||
                    n.isMeshLambertMaterial ||
                    n.isMeshBasicMaterial ||
                    n.isMeshStandardMaterial ||
                    n.isShaderMaterial) &&
                    S.setValue(
                      xt,
                      "isOrthographic",
                      !0 === t.isOrthographicCamera
                    ),
                    (n.isMeshPhongMaterial ||
                      n.isMeshToonMaterial ||
                      n.isMeshLambertMaterial ||
                      n.isMeshBasicMaterial ||
                      n.isMeshStandardMaterial ||
                      n.isShaderMaterial ||
                      n.isShadowMaterial ||
                      r.isSkinnedMesh) &&
                      S.setValue(xt, "viewMatrix", t.matrixWorldInverse);
                }
                if (r.isSkinnedMesh) {
                  S.setOptional(xt, r, "bindMatrix"),
                    S.setOptional(xt, r, "bindMatrixInverse");
                  const t = r.skeleton;
                  t &&
                    (J.floatVertexTextures
                      ? (null === t.boneTexture && t.computeBoneTexture(),
                        S.setValue(xt, "boneTexture", t.boneTexture, $),
                        S.setValue(xt, "boneTextureSize", t.boneTextureSize))
                      : S.setOptional(xt, t, "boneMatrices"));
                }
                var L, C;
                return (
                  !i ||
                    (void 0 === i.morphAttributes.position &&
                      void 0 === i.morphAttributes.normal) ||
                    pt.update(r, i, n, _),
                  (M || g.receiveShadow !== r.receiveShadow) &&
                    ((g.receiveShadow = r.receiveShadow),
                    S.setValue(xt, "receiveShadow", r.receiveShadow)),
                  M &&
                    (S.setValue(
                      xt,
                      "toneMappingExposure",
                      y.toneMappingExposure
                    ),
                    g.needsLights &&
                      ((C = w),
                      ((L = T).ambientLightColor.needsUpdate = C),
                      (L.lightProbe.needsUpdate = C),
                      (L.directionalLights.needsUpdate = C),
                      (L.directionalLightShadows.needsUpdate = C),
                      (L.pointLights.needsUpdate = C),
                      (L.pointLightShadows.needsUpdate = C),
                      (L.spotLights.needsUpdate = C),
                      (L.spotLightShadows.needsUpdate = C),
                      (L.rectAreaLights.needsUpdate = C),
                      (L.hemisphereLights.needsUpdate = C)),
                    s && n.fog && ot.refreshFogUniforms(T, s),
                    ot.refreshMaterialUniforms(T, n, D, z, V),
                    hs.upload(xt, g.uniformsList, T, $)),
                  n.isShaderMaterial &&
                    !0 === n.uniformsNeedUpdate &&
                    (hs.upload(xt, g.uniformsList, T, $),
                    (n.uniformsNeedUpdate = !1)),
                  n.isSpriteMaterial && S.setValue(xt, "center", r.center),
                  S.setValue(xt, "modelViewMatrix", r.modelViewMatrix),
                  S.setValue(xt, "normalMatrix", r.normalMatrix),
                  S.setValue(xt, "modelMatrix", r.matrixWorld),
                  _
                );
              })(t, e, i, n, r);
            Z.setMaterial(n, a);
            let l = i.index;
            const h = i.attributes.position;
            if (null === l) {
              if (void 0 === h || 0 === h.count) return;
            } else if (0 === l.count) return;
            let c,
              u = 1;
            !0 === n.wireframe && ((l = nt.getWireframeAttribute(i)), (u = 2)),
              yt.setup(r, n, o, i, l);
            let d = mt;
            null !== l && ((c = it.get(l)), (d = ft), d.setIndex(c));
            const p = null !== l ? l.count : h.count,
              f = i.drawRange.start * u,
              g = i.drawRange.count * u,
              x = null !== s ? s.start * u : 0,
              v = null !== s ? s.count * u : 1 / 0,
              _ = Math.max(f, x),
              b = Math.min(p, f + g, x + v) - 1,
              M = Math.max(0, b - _ + 1);
            if (0 !== M) {
              if (r.isMesh)
                !0 === n.wireframe
                  ? (Z.setLineWidth(n.wireframeLinewidth * X()), d.setMode(1))
                  : d.setMode(4);
              else if (r.isLine) {
                let t = n.linewidth;
                void 0 === t && (t = 1),
                  Z.setLineWidth(t * X()),
                  r.isLineSegments
                    ? d.setMode(1)
                    : r.isLineLoop
                    ? d.setMode(2)
                    : d.setMode(3);
              } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
              if (r.isInstancedMesh) d.renderInstances(_, M, r.count);
              else if (i.isInstancedBufferGeometry) {
                const t = Math.min(i.instanceCount, i._maxInstanceCount);
                d.renderInstances(_, M, t);
              } else d.render(_, M);
            }
          }),
          (this.compile = function (t, e) {
            (m = ht.get(t)),
              m.init(),
              g.push(m),
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (m.pushLight(t), t.castShadow && m.pushShadow(t));
              }),
              m.setupLights(y.physicallyCorrectLights),
              t.traverse(function (e) {
                const i = e.material;
                if (i)
                  if (Array.isArray(i))
                    for (let n = 0; n < i.length; n++) Dt(i[n], t, e);
                  else Dt(i, t, e);
              }),
              g.pop(),
              (m = null);
          });
        let Tt = null;
        function Et() {
          Rt.stop();
        }
        function At() {
          Rt.start();
        }
        const Rt = new yn();
        function Lt(t, e, i, n) {
          if (!1 === t.visible) return;
          if (t.layers.test(e.layers))
            if (t.isGroup) i = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
            else if (t.isSprite) {
              if (!t.frustumCulled || U.intersectsSprite(t)) {
                n && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
                const e = rt.update(t),
                  r = t.material;
                r.visible && d.push(t, e, r, i, j.z, null);
              }
            } else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== K.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = K.render.frame)),
              !t.frustumCulled || U.intersectsObject(t))
            ) {
              n && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
              const e = rt.update(t),
                r = t.material;
              if (Array.isArray(r)) {
                const n = e.groups;
                for (let s = 0, a = n.length; s < a; s++) {
                  const a = n[s],
                    o = r[a.materialIndex];
                  o && o.visible && d.push(t, e, o, i, j.z, a);
                }
              } else r.visible && d.push(t, e, r, i, j.z, null);
            }
          const r = t.children;
          for (let t = 0, s = r.length; t < s; t++) Lt(r[t], e, i, n);
        }
        function Ct(t, e, i, n) {
          const r = t.opaque,
            s = t.transmissive,
            o = t.transparent;
          m.setupLightsView(i),
            s.length > 0 &&
              (function (t, e, i) {
                if (null === V) {
                  const t = !0 === a && !0 === J.isWebGL2;
                  V = new (t ? Xt : jt)(1024, 1024, {
                    generateMipmaps: !0,
                    type: null !== gt.convert(w) ? w : v,
                    minFilter: x,
                    magFilter: p,
                    wrapS: u,
                    wrapT: u,
                    useRenderToTexture: Y.has(
                      "WEBGL_multisampled_render_to_texture"
                    ),
                  });
                }
                const n = y.getRenderTarget();
                y.setRenderTarget(V), y.clear();
                const r = y.toneMapping;
                (y.toneMapping = 0),
                  It(t, e, i),
                  (y.toneMapping = r),
                  $.updateMultisampleRenderTarget(V),
                  $.updateRenderTargetMipmap(V),
                  y.setRenderTarget(n);
              })(r, e, i),
            n && Z.viewport(L.copy(n)),
            r.length > 0 && It(r, e, i),
            s.length > 0 && It(s, e, i),
            o.length > 0 && It(o, e, i);
        }
        function It(t, e, i) {
          const n = !0 === e.isScene ? e.overrideMaterial : null;
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              a = s.object,
              o = s.geometry,
              l = null === n ? s.material : n,
              h = s.group;
            a.layers.test(i.layers) && zt(a, e, i, o, l, h);
          }
        }
        function zt(t, e, i, n, r, s) {
          t.onBeforeRender(y, e, i, n, r, s),
            t.modelViewMatrix.multiplyMatrices(
              i.matrixWorldInverse,
              t.matrixWorld
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            r.onBeforeRender(y, e, i, n, t, s),
            !0 === r.transparent && 2 === r.side
              ? ((r.side = 1),
                (r.needsUpdate = !0),
                y.renderBufferDirect(i, e, n, r, t, s),
                (r.side = 0),
                (r.needsUpdate = !0),
                y.renderBufferDirect(i, e, n, r, t, s),
                (r.side = 2))
              : y.renderBufferDirect(i, e, n, r, t, s),
            t.onAfterRender(y, e, i, n, r, s);
        }
        function Dt(t, e, i) {
          !0 !== e.isScene && (e = q);
          const n = Q.get(t),
            r = m.state.lights,
            s = m.state.shadowsArray,
            a = r.state.version,
            o = st.getParameters(t, r.state, s, e, i),
            l = st.getProgramCacheKey(o);
          let h = n.programs;
          (n.environment = t.isMeshStandardMaterial ? e.environment : null),
            (n.fog = e.fog),
            (n.envMap = (t.isMeshStandardMaterial ? et : tt).get(
              t.envMap || n.environment
            )),
            void 0 === h &&
              (t.addEventListener("dispose", St),
              (h = new Map()),
              (n.programs = h));
          let c = h.get(l);
          if (void 0 !== c) {
            if (n.currentProgram === c && n.lightsStateVersion === a)
              return Nt(t, o), c;
          } else
            (o.uniforms = st.getUniforms(t)),
              t.onBuild(i, o, y),
              t.onBeforeCompile(o, y),
              (c = st.acquireProgram(o, l)),
              h.set(l, c),
              (n.uniforms = o.uniforms);
          const u = n.uniforms;
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (u.clippingPlanes = ct.uniform),
            Nt(t, o),
            (n.needsLights = (function (t) {
              return (
                t.isMeshLambertMaterial ||
                t.isMeshToonMaterial ||
                t.isMeshPhongMaterial ||
                t.isMeshStandardMaterial ||
                t.isShadowMaterial ||
                (t.isShaderMaterial && !0 === t.lights)
              );
            })(t)),
            (n.lightsStateVersion = a),
            n.needsLights &&
              ((u.ambientLightColor.value = r.state.ambient),
              (u.lightProbe.value = r.state.probe),
              (u.directionalLights.value = r.state.directional),
              (u.directionalLightShadows.value = r.state.directionalShadow),
              (u.spotLights.value = r.state.spot),
              (u.spotLightShadows.value = r.state.spotShadow),
              (u.rectAreaLights.value = r.state.rectArea),
              (u.ltc_1.value = r.state.rectAreaLTC1),
              (u.ltc_2.value = r.state.rectAreaLTC2),
              (u.pointLights.value = r.state.point),
              (u.pointLightShadows.value = r.state.pointShadow),
              (u.hemisphereLights.value = r.state.hemi),
              (u.directionalShadowMap.value = r.state.directionalShadowMap),
              (u.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (u.spotShadowMap.value = r.state.spotShadowMap),
              (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (u.pointShadowMap.value = r.state.pointShadowMap),
              (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const d = c.getUniforms(),
            p = hs.seqWithValue(d.seq, u);
          return (n.currentProgram = c), (n.uniformsList = p), c;
        }
        function Nt(t, e) {
          const i = Q.get(t);
          (i.outputEncoding = e.outputEncoding),
            (i.instancing = e.instancing),
            (i.skinning = e.skinning),
            (i.morphTargets = e.morphTargets),
            (i.morphNormals = e.morphNormals),
            (i.morphTargetsCount = e.morphTargetsCount),
            (i.numClippingPlanes = e.numClippingPlanes),
            (i.numIntersection = e.numClipIntersection),
            (i.vertexAlphas = e.vertexAlphas),
            (i.vertexTangents = e.vertexTangents),
            (i.toneMapping = e.toneMapping);
        }
        Rt.setAnimationLoop(function (t) {
          Tt && Tt(t);
        }),
          "undefined" != typeof window && Rt.setContext(window),
          (this.setAnimationLoop = function (t) {
            (Tt = t),
              bt.setAnimationLoop(t),
              null === t ? Rt.stop() : Rt.start();
          }),
          bt.addEventListener("sessionstart", Et),
          bt.addEventListener("sessionend", At),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === _) return;
            !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              !0 === bt.enabled &&
                !0 === bt.isPresenting &&
                (!0 === bt.cameraAutoUpdate && bt.updateCamera(e),
                (e = bt.getCamera())),
              !0 === t.isScene && t.onBeforeRender(y, t, e, E),
              (m = ht.get(t, g.length)),
              m.init(),
              g.push(m),
              W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              U.setFromProjectionMatrix(W),
              (G = this.localClippingEnabled),
              (k = ct.init(this.clippingPlanes, G, e)),
              (d = lt.get(t, f.length)),
              d.init(),
              f.push(d),
              Lt(t, e, 0, y.sortObjects),
              d.finish(),
              !0 === y.sortObjects && d.sort(N, O),
              !0 === k && ct.beginShadows();
            const i = m.state.shadowsArray;
            if (
              (ut.render(i, t, e),
              !0 === k && ct.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              dt.render(d, t),
              m.setupLights(y.physicallyCorrectLights),
              e.isArrayCamera)
            ) {
              const i = e.cameras;
              for (let e = 0, n = i.length; e < n; e++) {
                const n = i[e];
                Ct(d, t, n, n.viewport);
              }
            } else Ct(d, t, e);
            null !== E &&
              ($.updateMultisampleRenderTarget(E),
              $.updateRenderTargetMipmap(E)),
              !0 === t.isScene && t.onAfterRender(y, t, e),
              Z.buffers.depth.setTest(!0),
              Z.buffers.depth.setMask(!0),
              Z.buffers.color.setMask(!0),
              Z.setPolygonOffset(!1),
              yt.resetDefaultState(),
              (A = -1),
              (R = null),
              g.pop(),
              (m = g.length > 0 ? g[g.length - 1] : null),
              f.pop(),
              (d = f.length > 0 ? f[f.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return b;
          }),
          (this.getActiveMipmapLevel = function () {
            return S;
          }),
          (this.getRenderTarget = function () {
            return E;
          }),
          (this.setRenderTargetTextures = function (t, e, i) {
            (Q.get(t.texture).__webglTexture = e),
              (Q.get(t.depthTexture).__webglTexture = i);
            const n = Q.get(t);
            (n.__hasExternalTextures = !0),
              n.__hasExternalTextures &&
                ((n.__autoAllocateDepthBuffer = void 0 === i),
                n.__autoAllocateDepthBuffer ||
                  (t.useRenderToTexture &&
                    (console.warn(
                      "render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (t.useRenderToTexture = !1),
                    (t.useRenderbuffer = !0))));
          }),
          (this.setRenderTargetFramebuffer = function (t, e) {
            const i = Q.get(t);
            (i.__webglFramebuffer = e),
              (i.__useDefaultFramebuffer = void 0 === e);
          }),
          (this.setRenderTarget = function (t, e = 0, i = 0) {
            (E = t), (b = e), (S = i);
            let n = !0;
            if (t) {
              const e = Q.get(t);
              void 0 !== e.__useDefaultFramebuffer
                ? (Z.bindFramebuffer(36160, null), (n = !1))
                : void 0 === e.__webglFramebuffer
                ? $.setupRenderTarget(t)
                : e.__hasExternalTextures &&
                  $.rebindTextures(
                    t,
                    Q.get(t.texture).__webglTexture,
                    Q.get(t.depthTexture).__webglTexture
                  );
            }
            let r = null,
              s = !1,
              a = !1;
            if (t) {
              const i = t.texture;
              (i.isDataTexture3D || i.isDataTexture2DArray) && (a = !0);
              const n = Q.get(t).__webglFramebuffer;
              t.isWebGLCubeRenderTarget
                ? ((r = n[e]), (s = !0))
                : (r = t.useRenderbuffer
                    ? Q.get(t).__webglMultisampledFramebuffer
                    : n),
                L.copy(t.viewport),
                C.copy(t.scissor),
                (P = t.scissorTest);
            } else
              L.copy(B).multiplyScalar(D).floor(),
                C.copy(F).multiplyScalar(D).floor(),
                (P = H);
            if (
              (Z.bindFramebuffer(36160, r) &&
                J.drawBuffers &&
                n &&
                Z.drawBuffers(t, r),
              Z.viewport(L),
              Z.scissor(C),
              Z.setScissorTest(P),
              s)
            ) {
              const n = Q.get(t.texture);
              xt.framebufferTexture2D(
                36160,
                36064,
                34069 + e,
                n.__webglTexture,
                i
              );
            } else if (a) {
              const n = Q.get(t.texture),
                r = e || 0;
              xt.framebufferTextureLayer(
                36160,
                36064,
                n.__webglTexture,
                i || 0,
                r
              );
            }
            A = -1;
          }),
          (this.readRenderTargetPixels = function (t, e, i, n, r, s, a) {
            if (!t || !t.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let o = Q.get(t).__webglFramebuffer;
            if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
              Z.bindFramebuffer(36160, o);
              try {
                const a = t.texture,
                  o = a.format,
                  l = a.type;
                if (o !== T && gt.convert(o) !== xt.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const h =
                  l === w &&
                  (Y.has("EXT_color_buffer_half_float") ||
                    (J.isWebGL2 && Y.has("EXT_color_buffer_float")));
                if (
                  !(
                    l === v ||
                    gt.convert(l) === xt.getParameter(35738) ||
                    (l === M &&
                      (J.isWebGL2 ||
                        Y.has("OES_texture_float") ||
                        Y.has("WEBGL_color_buffer_float"))) ||
                    h
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === xt.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - n &&
                    i >= 0 &&
                    i <= t.height - r &&
                    xt.readPixels(e, i, n, r, gt.convert(o), gt.convert(l), s)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const t = null !== E ? Q.get(E).__webglFramebuffer : null;
                Z.bindFramebuffer(36160, t);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, i = 0) {
            if (!0 !== e.isFramebufferTexture)
              return void console.error(
                "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
              );
            const n = Math.pow(2, -i),
              r = Math.floor(e.image.width * n),
              s = Math.floor(e.image.height * n);
            $.setTexture2D(e, 0),
              xt.copyTexSubImage2D(3553, i, 0, 0, t.x, t.y, r, s),
              Z.unbindTexture();
          }),
          (this.copyTextureToTexture = function (t, e, i, n = 0) {
            const r = e.image.width,
              s = e.image.height,
              a = gt.convert(i.format),
              o = gt.convert(i.type);
            $.setTexture2D(i, 0),
              xt.pixelStorei(37440, i.flipY),
              xt.pixelStorei(37441, i.premultiplyAlpha),
              xt.pixelStorei(3317, i.unpackAlignment),
              e.isDataTexture
                ? xt.texSubImage2D(3553, n, t.x, t.y, r, s, a, o, e.image.data)
                : e.isCompressedTexture
                ? xt.compressedTexSubImage2D(
                    3553,
                    n,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    a,
                    e.mipmaps[0].data
                  )
                : xt.texSubImage2D(3553, n, t.x, t.y, a, o, e.image),
              0 === n && i.generateMipmaps && xt.generateMipmap(3553),
              Z.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (t, e, i, n, r = 0) {
            if (y.isWebGL1Renderer)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            const s = t.max.x - t.min.x + 1,
              a = t.max.y - t.min.y + 1,
              o = t.max.z - t.min.z + 1,
              l = gt.convert(n.format),
              h = gt.convert(n.type);
            let c;
            if (n.isDataTexture3D) $.setTexture3D(n, 0), (c = 32879);
            else {
              if (!n.isDataTexture2DArray)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
              $.setTexture2DArray(n, 0), (c = 35866);
            }
            xt.pixelStorei(37440, n.flipY),
              xt.pixelStorei(37441, n.premultiplyAlpha),
              xt.pixelStorei(3317, n.unpackAlignment);
            const u = xt.getParameter(3314),
              d = xt.getParameter(32878),
              p = xt.getParameter(3316),
              m = xt.getParameter(3315),
              f = xt.getParameter(32877),
              g = i.isCompressedTexture ? i.mipmaps[0] : i.image;
            xt.pixelStorei(3314, g.width),
              xt.pixelStorei(32878, g.height),
              xt.pixelStorei(3316, t.min.x),
              xt.pixelStorei(3315, t.min.y),
              xt.pixelStorei(32877, t.min.z),
              i.isDataTexture || i.isDataTexture3D
                ? xt.texSubImage3D(c, r, e.x, e.y, e.z, s, a, o, l, h, g.data)
                : i.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  xt.compressedTexSubImage3D(
                    c,
                    r,
                    e.x,
                    e.y,
                    e.z,
                    s,
                    a,
                    o,
                    l,
                    g.data
                  ))
                : xt.texSubImage3D(c, r, e.x, e.y, e.z, s, a, o, l, h, g),
              xt.pixelStorei(3314, u),
              xt.pixelStorei(32878, d),
              xt.pixelStorei(3316, p),
              xt.pixelStorei(3315, m),
              xt.pixelStorei(32877, f),
              0 === r && n.generateMipmaps && xt.generateMipmap(c),
              Z.unbindTexture();
          }),
          (this.initTexture = function (t) {
            $.setTexture2D(t, 0), Z.unbindTexture();
          }),
          (this.resetState = function () {
            (b = 0), (S = 0), (E = null), Z.reset(), yt.reset();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      ia.prototype.isWebGLRenderer = !0;
      class na extends ia {}
      na.prototype.isWebGL1Renderer = !0;
      class ra {
        constructor(t, e = 25e-5) {
          (this.name = ""), (this.color = new Ft(t)), (this.density = e);
        }
        clone() {
          return new ra(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }
      }
      ra.prototype.isFogExp2 = !0;
      class sa {
        constructor(t, e = 1, i = 1e3) {
          (this.name = ""),
            (this.color = new Ft(t)),
            (this.near = e),
            (this.far = i);
        }
        clone() {
          return new sa(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      sa.prototype.isFog = !0;
      class aa extends Ke {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
        }
      }
      aa.prototype.isScene = !0;
      class oa {
        constructor(t, e) {
          (this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = ht),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = xt());
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, i) {
          (t *= this.stride), (i *= e.stride);
          for (let n = 0, r = this.stride; n < r; n++)
            this.array[t + n] = e.array[i + n];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = xt()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid]
            ),
            i = new this.constructor(e, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = xt()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      oa.prototype.isInterleavedBuffer = !0;
      const la = new Jt();
      class ha {
        constructor(t, e, i, n = !1) {
          (this.name = ""),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = i),
            (this.normalized = !0 === n);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.data.count; e < i; e++)
            (la.x = this.getX(e)),
              (la.y = this.getY(e)),
              (la.z = this.getZ(e)),
              la.applyMatrix4(t),
              this.setXYZ(e, la.x, la.y, la.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (la.x = this.getX(e)),
              (la.y = this.getY(e)),
              (la.z = this.getZ(e)),
              la.applyNormalMatrix(t),
              this.setXYZ(e, la.x, la.y, la.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (la.x = this.getX(e)),
              (la.y = this.getY(e)),
              (la.z = this.getZ(e)),
              la.transformDirection(t),
              this.setXYZ(e, la.x, la.y, la.z);
          return this;
        }
        setX(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        }
        setY(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        }
        setZ(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        }
        setW(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        }
        getX(t) {
          return this.data.array[t * this.data.stride + this.offset];
        }
        getY(t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        }
        getZ(t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        }
        getW(t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        }
        setXY(t, e, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            this
          );
        }
        setXYZ(t, e, i, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = n),
            this
          );
        }
        setXYZW(t, e, i, n, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = n),
            (this.data.array[t + 3] = r),
            this
          );
        }
        clone(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const i = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[i + e]);
            }
            return new mi(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new ha(
              t.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const i = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[i + e]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      ha.prototype.isInterleavedBufferAttribute = !0;
      class ca extends ci {
        constructor(t) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new Ft(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      let ua;
      ca.prototype.isSpriteMaterial = !0;
      const da = new Jt(),
        pa = new Jt(),
        ma = new Jt(),
        fa = new Et(),
        ga = new Et(),
        ya = new Ee(),
        xa = new Jt(),
        va = new Jt(),
        _a = new Jt(),
        ba = new Et(),
        Ma = new Et(),
        wa = new Et();
      class Sa extends Ke {
        constructor(t) {
          if ((super(), (this.type = "Sprite"), void 0 === ua)) {
            ua = new Ii();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              e = new oa(t, 5);
            ua.setIndex([0, 1, 2, 0, 2, 3]),
              ua.setAttribute("position", new ha(e, 3, 0, !1)),
              ua.setAttribute("uv", new ha(e, 2, 3, !1));
          }
          (this.geometry = ua),
            (this.material = void 0 !== t ? t : new ca()),
            (this.center = new Et(0.5, 0.5));
        }
        raycast(t, e) {
          null === t.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            pa.setFromMatrixScale(this.matrixWorld),
            ya.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              t.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            ma.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              pa.multiplyScalar(-ma.z);
          const i = this.material.rotation;
          let n, r;
          0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
          const s = this.center;
          Ta(xa.set(-0.5, -0.5, 0), ma, s, pa, n, r),
            Ta(va.set(0.5, -0.5, 0), ma, s, pa, n, r),
            Ta(_a.set(0.5, 0.5, 0), ma, s, pa, n, r),
            ba.set(0, 0),
            Ma.set(1, 0),
            wa.set(1, 1);
          let a = t.ray.intersectTriangle(xa, va, _a, !1, da);
          if (
            null === a &&
            (Ta(va.set(-0.5, 0.5, 0), ma, s, pa, n, r),
            Ma.set(0, 1),
            (a = t.ray.intersectTriangle(xa, _a, va, !1, da)),
            null === a)
          )
            return;
          const o = t.ray.origin.distanceTo(da);
          o < t.near ||
            o > t.far ||
            e.push({
              distance: o,
              point: da.clone(),
              uv: li.getUV(da, xa, va, _a, ba, Ma, wa, new Et()),
              face: null,
              object: this,
            });
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            (this.material = t.material),
            this
          );
        }
      }
      function Ta(t, e, i, n, r, s) {
        fa.subVectors(t, i).addScalar(0.5).multiply(n),
          void 0 !== r
            ? ((ga.x = s * fa.x - r * fa.y), (ga.y = r * fa.x + s * fa.y))
            : ga.copy(fa),
          t.copy(e),
          (t.x += ga.x),
          (t.y += ga.y),
          t.applyMatrix4(ya);
      }
      Sa.prototype.isSprite = !0;
      const Ea = new Jt(),
        Aa = new Jt();
      class Ra extends Ke {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(t) {
          super.copy(t, !1);
          const e = t.levels;
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            this.addLevel(i.object.clone(), i.distance);
          }
          return (this.autoUpdate = t.autoUpdate), this;
        }
        addLevel(t, e = 0) {
          e = Math.abs(e);
          const i = this.levels;
          let n;
          for (n = 0; n < i.length && !(e < i[n].distance); n++);
          return i.splice(n, 0, { distance: e, object: t }), this.add(t), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(t) {
          const e = this.levels;
          if (e.length > 0) {
            let i, n;
            for (i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
            return e[i - 1].object;
          }
          return null;
        }
        raycast(t, e) {
          if (this.levels.length > 0) {
            Ea.setFromMatrixPosition(this.matrixWorld);
            const i = t.ray.origin.distanceTo(Ea);
            this.getObjectForDistance(i).raycast(t, e);
          }
        }
        update(t) {
          const e = this.levels;
          if (e.length > 1) {
            Ea.setFromMatrixPosition(t.matrixWorld),
              Aa.setFromMatrixPosition(this.matrixWorld);
            const i = Ea.distanceTo(Aa) / t.zoom;
            let n, r;
            for (
              e[0].object.visible = !0, n = 1, r = e.length;
              n < r && i >= e[n].distance;
              n++
            )
              (e[n - 1].object.visible = !1), (e[n].object.visible = !0);
            for (this._currentLevel = n - 1; n < r; n++)
              e[n].object.visible = !1;
          }
        }
        toJSON(t) {
          const e = super.toJSON(t);
          !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            (e.object.levels = []);
          const i = this.levels;
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            e.object.levels.push({
              object: n.object.uuid,
              distance: n.distance,
            });
          }
          return e;
        }
      }
      const La = new Jt(),
        Ca = new Wt(),
        Pa = new Wt(),
        Ia = new Jt(),
        za = new Ee();
      class Da extends Zi {
        constructor(t, e) {
          super(t, e),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new Ee()),
            (this.bindMatrixInverse = new Ee());
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          );
        }
        bind(t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t = new Wt(),
            e = this.geometry.attributes.skinWeight;
          for (let i = 0, n = e.count; i < n; i++) {
            (t.x = e.getX(i)),
              (t.y = e.getY(i)),
              (t.z = e.getZ(i)),
              (t.w = e.getW(i));
            const n = 1 / t.manhattanLength();
            n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
              e.setXYZW(i, t.x, t.y, t.z, t.w);
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(t, e) {
          const i = this.skeleton,
            n = this.geometry;
          Ca.fromBufferAttribute(n.attributes.skinIndex, t),
            Pa.fromBufferAttribute(n.attributes.skinWeight, t),
            La.copy(e).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
          for (let t = 0; t < 4; t++) {
            const n = Pa.getComponent(t);
            if (0 !== n) {
              const r = Ca.getComponent(t);
              za.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
                e.addScaledVector(Ia.copy(La).applyMatrix4(za), n);
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse);
        }
      }
      Da.prototype.isSkinnedMesh = !0;
      class Na extends Ke {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Na.prototype.isBone = !0;
      class Oa extends Gt {
        constructor(
          t = null,
          e = 1,
          i = 1,
          n,
          r,
          s,
          a,
          o,
          l = 1003,
          h = 1003,
          c,
          u
        ) {
          super(null, s, a, o, l, h, n, r, c, u),
            (this.image = { data: t, width: e, height: i }),
            (this.magFilter = l),
            (this.minFilter = h),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      Oa.prototype.isDataTexture = !0;
      const Ba = new Ee(),
        Fa = new Ee();
      class Ha {
        constructor(t = [], e = []) {
          (this.uuid = xt()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const t = this.bones,
            e = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * t.length)),
            0 === e.length)
          )
            this.calculateInverses();
          else if (t.length !== e.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let t = 0, e = this.bones.length; t < e; t++)
              this.boneInverses.push(new Ee());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new Ee();
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
              this.boneInverses.push(e);
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e && e.matrixWorld.copy(this.boneInverses[t]).invert();
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                  e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale));
          }
        }
        update() {
          const t = this.bones,
            e = this.boneInverses,
            i = this.boneMatrices,
            n = this.boneTexture;
          for (let n = 0, r = t.length; n < r; n++) {
            const r = t[n] ? t[n].matrixWorld : Fa;
            Ba.multiplyMatrices(r, e[n]), Ba.toArray(i, 16 * n);
          }
          null !== n && (n.needsUpdate = !0);
        }
        clone() {
          return new Ha(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length);
          (t = wt(t)), (t = Math.max(t, 4));
          const e = new Float32Array(t * t * 4);
          e.set(this.boneMatrices);
          const i = new Oa(e, t, t, T, M);
          return (
            (i.needsUpdate = !0),
            (this.boneMatrices = e),
            (this.boneTexture = i),
            (this.boneTextureSize = t),
            this
          );
        }
        getBoneByName(t) {
          for (let e = 0, i = this.bones.length; e < i; e++) {
            const i = this.bones[e];
            if (i.name === t) return i;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(t, e) {
          this.uuid = t.uuid;
          for (let i = 0, n = t.bones.length; i < n; i++) {
            const n = t.bones[i];
            let r = e[n];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", n),
              (r = new Na())),
              this.bones.push(r),
              this.boneInverses.push(new Ee().fromArray(t.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          t.uuid = this.uuid;
          const e = this.bones,
            i = this.boneInverses;
          for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            t.bones.push(r.uuid);
            const s = i[n];
            t.boneInverses.push(s.toArray());
          }
          return t;
        }
      }
      class Ua extends mi {
        constructor(t, e, i, n = 1) {
          "number" == typeof i &&
            ((n = i),
            (i = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(t, e, i),
            (this.meshPerAttribute = n);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        }
      }
      Ua.prototype.isInstancedBufferAttribute = !0;
      const ka = new Ee(),
        Ga = new Ee(),
        Va = [],
        Wa = new Zi();
      class ja extends Zi {
        constructor(t, e, i) {
          super(t, e),
            (this.instanceMatrix = new Ua(new Float32Array(16 * i), 16)),
            (this.instanceColor = null),
            (this.count = i),
            (this.frustumCulled = !1);
        }
        copy(t) {
          return (
            super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            this
          );
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t);
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t);
        }
        raycast(t, e) {
          const i = this.matrixWorld,
            n = this.count;
          if (
            ((Wa.geometry = this.geometry),
            (Wa.material = this.material),
            void 0 !== Wa.material)
          )
            for (let r = 0; r < n; r++) {
              this.getMatrixAt(r, ka),
                Ga.multiplyMatrices(i, ka),
                (Wa.matrixWorld = Ga),
                Wa.raycast(t, Va);
              for (let t = 0, i = Va.length; t < i; t++) {
                const i = Va[t];
                (i.instanceId = r), (i.object = this), e.push(i);
              }
              Va.length = 0;
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new Ua(
              new Float32Array(3 * this.instanceMatrix.count),
              3
            )),
            e.toArray(this.instanceColor.array, 3 * t);
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      ja.prototype.isInstancedMesh = !0;
      class qa extends ci {
        constructor(t) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new Ft(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          );
        }
      }
      qa.prototype.isLineBasicMaterial = !0;
      const Xa = new Jt(),
        Ya = new Jt(),
        Ja = new Ee(),
        Za = new Te(),
        Ka = new ye();
      class Qa extends Ke {
        constructor(t = new Ii(), e = new qa()) {
          super(),
            (this.type = "Line"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                i = [0];
              for (let t = 1, n = e.count; t < n; t++)
                Xa.fromBufferAttribute(e, t - 1),
                  Ya.fromBufferAttribute(e, t),
                  (i[t] = i[t - 1]),
                  (i[t] += Xa.distanceTo(Ya));
              t.setAttribute("lineDistance", new wi(i, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.matrixWorld,
            r = t.params.Line.threshold,
            s = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            Ka.copy(i.boundingSphere),
            Ka.applyMatrix4(n),
            (Ka.radius += r),
            !1 === t.ray.intersectsSphere(Ka))
          )
            return;
          Ja.copy(n).invert(), Za.copy(t.ray).applyMatrix4(Ja);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            l = new Jt(),
            h = new Jt(),
            c = new Jt(),
            u = new Jt(),
            d = this.isLineSegments ? 2 : 1;
          if (i.isBufferGeometry) {
            const n = i.index,
              r = i.attributes.position;
            if (null !== n)
              for (
                let i = Math.max(0, s.start),
                  a = Math.min(n.count, s.start + s.count) - 1;
                i < a;
                i += d
              ) {
                const s = n.getX(i),
                  a = n.getX(i + 1);
                if (
                  (l.fromBufferAttribute(r, s),
                  h.fromBufferAttribute(r, a),
                  Za.distanceSqToSegment(l, h, u, c) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const d = t.ray.origin.distanceTo(u);
                d < t.near ||
                  d > t.far ||
                  e.push({
                    distance: d,
                    point: c.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            else
              for (
                let i = Math.max(0, s.start),
                  n = Math.min(r.count, s.start + s.count) - 1;
                i < n;
                i += d
              ) {
                if (
                  (l.fromBufferAttribute(r, i),
                  h.fromBufferAttribute(r, i + 1),
                  Za.distanceSqToSegment(l, h, u, c) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const n = t.ray.origin.distanceTo(u);
                n < t.near ||
                  n > t.far ||
                  e.push({
                    distance: n,
                    point: c.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
          } else
            i.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e);
            if (i.length > 0) {
              const t = e[i[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[i] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Qa.prototype.isLine = !0;
      const $a = new Jt(),
        to = new Jt();
      class eo extends Qa {
        constructor(t, e) {
          super(t, e), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                i = [];
              for (let t = 0, n = e.count; t < n; t += 2)
                $a.fromBufferAttribute(e, t),
                  to.fromBufferAttribute(e, t + 1),
                  (i[t] = 0 === t ? 0 : i[t - 1]),
                  (i[t + 1] = i[t] + $a.distanceTo(to));
              t.setAttribute("lineDistance", new wi(i, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      eo.prototype.isLineSegments = !0;
      class io extends Qa {
        constructor(t, e) {
          super(t, e), (this.type = "LineLoop");
        }
      }
      io.prototype.isLineLoop = !0;
      class no extends ci {
        constructor(t) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new Ft(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      no.prototype.isPointsMaterial = !0;
      const ro = new Ee(),
        so = new Te(),
        ao = new ye(),
        oo = new Jt();
      class lo extends Ke {
        constructor(t = new Ii(), e = new no()) {
          super(),
            (this.type = "Points"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.matrixWorld,
            r = t.params.Points.threshold,
            s = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            ao.copy(i.boundingSphere),
            ao.applyMatrix4(n),
            (ao.radius += r),
            !1 === t.ray.intersectsSphere(ao))
          )
            return;
          ro.copy(n).invert(), so.copy(t.ray).applyMatrix4(ro);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a;
          if (i.isBufferGeometry) {
            const r = i.index,
              a = i.attributes.position;
            if (null !== r)
              for (
                let i = Math.max(0, s.start),
                  l = Math.min(r.count, s.start + s.count);
                i < l;
                i++
              ) {
                const s = r.getX(i);
                oo.fromBufferAttribute(a, s), ho(oo, s, o, n, t, e, this);
              }
            else
              for (
                let i = Math.max(0, s.start),
                  r = Math.min(a.count, s.start + s.count);
                i < r;
                i++
              )
                oo.fromBufferAttribute(a, i), ho(oo, i, o, n, t, e, this);
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e);
            if (i.length > 0) {
              const t = e[i[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[i] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      function ho(t, e, i, n, r, s, a) {
        const o = so.distanceSqToPoint(t);
        if (o < i) {
          const i = new Jt();
          so.closestPointToPoint(t, i), i.applyMatrix4(n);
          const l = r.ray.origin.distanceTo(i);
          if (l < r.near || l > r.far) return;
          s.push({
            distance: l,
            distanceToRay: Math.sqrt(o),
            point: i,
            index: e,
            face: null,
            object: a,
          });
        }
      }
      lo.prototype.isPoints = !0;
      class co extends Gt {
        constructor(t, e, i, n, r, s, a, o, l) {
          super(t, e, i, n, r, s, a, o, l),
            (this.minFilter = void 0 !== s ? s : g),
            (this.magFilter = void 0 !== r ? r : g),
            (this.generateMipmaps = !1);
          const h = this;
          "requestVideoFrameCallback" in t &&
            t.requestVideoFrameCallback(function e() {
              (h.needsUpdate = !0), t.requestVideoFrameCallback(e);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t = this.image;
          0 == "requestVideoFrameCallback" in t &&
            t.readyState >= t.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      co.prototype.isVideoTexture = !0;
      class uo extends Gt {
        constructor(t, e, i) {
          super({ width: t, height: e }),
            (this.format = i),
            (this.magFilter = p),
            (this.minFilter = p),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      }
      uo.prototype.isFramebufferTexture = !0;
      class po extends Gt {
        constructor(t, e, i, n, r, s, a, o, l, h, c, u) {
          super(null, s, a, o, l, h, n, r, c, u),
            (this.image = { width: e, height: i }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      po.prototype.isCompressedTexture = !0;
      class mo extends Gt {
        constructor(t, e, i, n, r, s, a, o, l) {
          super(t, e, i, n, r, s, a, o, l), (this.needsUpdate = !0);
        }
      }
      mo.prototype.isCanvasTexture = !0;
      class fo extends Ii {
        constructor(t = 1, e = 8, i = 0, n = 2 * Math.PI) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: t,
              segments: e,
              thetaStart: i,
              thetaLength: n,
            }),
            (e = Math.max(3, e));
          const r = [],
            s = [],
            a = [],
            o = [],
            l = new Jt(),
            h = new Et();
          s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
          for (let r = 0, c = 3; r <= e; r++, c += 3) {
            const u = i + (r / e) * n;
            (l.x = t * Math.cos(u)),
              (l.y = t * Math.sin(u)),
              s.push(l.x, l.y, l.z),
              a.push(0, 0, 1),
              (h.x = (s[c] / t + 1) / 2),
              (h.y = (s[c + 1] / t + 1) / 2),
              o.push(h.x, h.y);
          }
          for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
          this.setIndex(r),
            this.setAttribute("position", new wi(s, 3)),
            this.setAttribute("normal", new wi(a, 3)),
            this.setAttribute("uv", new wi(o, 2));
        }
        static fromJSON(t) {
          return new fo(t.radius, t.segments, t.thetaStart, t.thetaLength);
        }
      }
      class go extends Ii {
        constructor(
          t = 1,
          e = 1,
          i = 1,
          n = 8,
          r = 1,
          s = !1,
          a = 0,
          o = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: t,
              radiusBottom: e,
              height: i,
              radialSegments: n,
              heightSegments: r,
              openEnded: s,
              thetaStart: a,
              thetaLength: o,
            });
          const l = this;
          (n = Math.floor(n)), (r = Math.floor(r));
          const h = [],
            c = [],
            u = [],
            d = [];
          let p = 0;
          const m = [],
            f = i / 2;
          let g = 0;
          function y(i) {
            const r = p,
              s = new Et(),
              m = new Jt();
            let y = 0;
            const x = !0 === i ? t : e,
              v = !0 === i ? 1 : -1;
            for (let t = 1; t <= n; t++)
              c.push(0, f * v, 0), u.push(0, v, 0), d.push(0.5, 0.5), p++;
            const _ = p;
            for (let t = 0; t <= n; t++) {
              const e = (t / n) * o + a,
                i = Math.cos(e),
                r = Math.sin(e);
              (m.x = x * r),
                (m.y = f * v),
                (m.z = x * i),
                c.push(m.x, m.y, m.z),
                u.push(0, v, 0),
                (s.x = 0.5 * i + 0.5),
                (s.y = 0.5 * r * v + 0.5),
                d.push(s.x, s.y),
                p++;
            }
            for (let t = 0; t < n; t++) {
              const e = r + t,
                n = _ + t;
              !0 === i ? h.push(n, n + 1, e) : h.push(n + 1, n, e), (y += 3);
            }
            l.addGroup(g, y, !0 === i ? 1 : 2), (g += y);
          }
          !(function () {
            const s = new Jt(),
              y = new Jt();
            let x = 0;
            const v = (e - t) / i;
            for (let l = 0; l <= r; l++) {
              const h = [],
                g = l / r,
                x = g * (e - t) + t;
              for (let t = 0; t <= n; t++) {
                const e = t / n,
                  r = e * o + a,
                  l = Math.sin(r),
                  m = Math.cos(r);
                (y.x = x * l),
                  (y.y = -g * i + f),
                  (y.z = x * m),
                  c.push(y.x, y.y, y.z),
                  s.set(l, v, m).normalize(),
                  u.push(s.x, s.y, s.z),
                  d.push(e, 1 - g),
                  h.push(p++);
              }
              m.push(h);
            }
            for (let t = 0; t < n; t++)
              for (let e = 0; e < r; e++) {
                const i = m[e][t],
                  n = m[e + 1][t],
                  r = m[e + 1][t + 1],
                  s = m[e][t + 1];
                h.push(i, n, s), h.push(n, r, s), (x += 6);
              }
            l.addGroup(g, x, 0), (g += x);
          })(),
            !1 === s && (t > 0 && y(!0), e > 0 && y(!1)),
            this.setIndex(h),
            this.setAttribute("position", new wi(c, 3)),
            this.setAttribute("normal", new wi(u, 3)),
            this.setAttribute("uv", new wi(d, 2));
        }
        static fromJSON(t) {
          return new go(
            t.radiusTop,
            t.radiusBottom,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class yo extends go {
        constructor(
          t = 1,
          e = 1,
          i = 8,
          n = 1,
          r = !1,
          s = 0,
          a = 2 * Math.PI
        ) {
          super(0, t, e, i, n, r, s, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: t,
              height: e,
              radialSegments: i,
              heightSegments: n,
              openEnded: r,
              thetaStart: s,
              thetaLength: a,
            });
        }
        static fromJSON(t) {
          return new yo(
            t.radius,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class xo extends Ii {
        constructor(t = [], e = [], i = 1, n = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: t,
              indices: e,
              radius: i,
              detail: n,
            });
          const r = [],
            s = [];
          function a(t, e, i, n) {
            const r = n + 1,
              s = [];
            for (let n = 0; n <= r; n++) {
              s[n] = [];
              const a = t.clone().lerp(i, n / r),
                o = e.clone().lerp(i, n / r),
                l = r - n;
              for (let t = 0; t <= l; t++)
                s[n][t] = 0 === t && n === r ? a : a.clone().lerp(o, t / l);
            }
            for (let t = 0; t < r; t++)
              for (let e = 0; e < 2 * (r - t) - 1; e++) {
                const i = Math.floor(e / 2);
                e % 2 == 0
                  ? (o(s[t][i + 1]), o(s[t + 1][i]), o(s[t][i]))
                  : (o(s[t][i + 1]), o(s[t + 1][i + 1]), o(s[t + 1][i]));
              }
          }
          function o(t) {
            r.push(t.x, t.y, t.z);
          }
          function l(e, i) {
            const n = 3 * e;
            (i.x = t[n + 0]), (i.y = t[n + 1]), (i.z = t[n + 2]);
          }
          function h(t, e, i, n) {
            n < 0 && 1 === t.x && (s[e] = t.x - 1),
              0 === i.x && 0 === i.z && (s[e] = n / 2 / Math.PI + 0.5);
          }
          function c(t) {
            return Math.atan2(t.z, -t.x);
          }
          !(function (t) {
            const i = new Jt(),
              n = new Jt(),
              r = new Jt();
            for (let s = 0; s < e.length; s += 3)
              l(e[s + 0], i), l(e[s + 1], n), l(e[s + 2], r), a(i, n, r, t);
          })(n),
            (function (t) {
              const e = new Jt();
              for (let i = 0; i < r.length; i += 3)
                (e.x = r[i + 0]),
                  (e.y = r[i + 1]),
                  (e.z = r[i + 2]),
                  e.normalize().multiplyScalar(t),
                  (r[i + 0] = e.x),
                  (r[i + 1] = e.y),
                  (r[i + 2] = e.z);
            })(i),
            (function () {
              const t = new Jt();
              for (let i = 0; i < r.length; i += 3) {
                (t.x = r[i + 0]), (t.y = r[i + 1]), (t.z = r[i + 2]);
                const n = c(t) / 2 / Math.PI + 0.5,
                  a =
                    ((e = t),
                    Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
                      Math.PI +
                      0.5);
                s.push(n, 1 - a);
              }
              var e;
              (function () {
                const t = new Jt(),
                  e = new Jt(),
                  i = new Jt(),
                  n = new Jt(),
                  a = new Et(),
                  o = new Et(),
                  l = new Et();
                for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                  t.set(r[u + 0], r[u + 1], r[u + 2]),
                    e.set(r[u + 3], r[u + 4], r[u + 5]),
                    i.set(r[u + 6], r[u + 7], r[u + 8]),
                    a.set(s[d + 0], s[d + 1]),
                    o.set(s[d + 2], s[d + 3]),
                    l.set(s[d + 4], s[d + 5]),
                    n.copy(t).add(e).add(i).divideScalar(3);
                  const p = c(n);
                  h(a, d + 0, t, p), h(o, d + 2, e, p), h(l, d + 4, i, p);
                }
              })(),
                (function () {
                  for (let t = 0; t < s.length; t += 6) {
                    const e = s[t + 0],
                      i = s[t + 2],
                      n = s[t + 4],
                      r = Math.max(e, i, n),
                      a = Math.min(e, i, n);
                    r > 0.9 &&
                      a < 0.1 &&
                      (e < 0.2 && (s[t + 0] += 1),
                      i < 0.2 && (s[t + 2] += 1),
                      n < 0.2 && (s[t + 4] += 1));
                  }
                })();
            })(),
            this.setAttribute("position", new wi(r, 3)),
            this.setAttribute("normal", new wi(r.slice(), 3)),
            this.setAttribute("uv", new wi(s, 2)),
            0 === n ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(t) {
          return new xo(t.vertices, t.indices, t.radius, t.details);
        }
      }
      class vo extends xo {
        constructor(t = 1, e = 0) {
          const i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i;
          super(
            [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -n,
              -i,
              0,
              -n,
              i,
              0,
              n,
              -i,
              0,
              n,
              i,
              -n,
              -i,
              0,
              -n,
              i,
              0,
              n,
              -i,
              0,
              n,
              i,
              0,
              -i,
              0,
              -n,
              i,
              0,
              -n,
              -i,
              0,
              n,
              i,
              0,
              n,
            ],
            [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ],
            t,
            e
          ),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new vo(t.radius, t.detail);
        }
      }
      const _o = new Jt(),
        bo = new Jt(),
        Mo = new Jt(),
        wo = new li();
      class So extends Ii {
        constructor(t = null, e = 1) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { geometry: t, thresholdAngle: e }),
            null !== t)
          ) {
            const i = 4,
              n = Math.pow(10, i),
              r = Math.cos(gt * e),
              s = t.getIndex(),
              a = t.getAttribute("position"),
              o = s ? s.count : a.count,
              l = [0, 0, 0],
              h = ["a", "b", "c"],
              c = new Array(3),
              u = {},
              d = [];
            for (let t = 0; t < o; t += 3) {
              s
                ? ((l[0] = s.getX(t)),
                  (l[1] = s.getX(t + 1)),
                  (l[2] = s.getX(t + 2)))
                : ((l[0] = t), (l[1] = t + 1), (l[2] = t + 2));
              const { a: e, b: i, c: o } = wo;
              if (
                (e.fromBufferAttribute(a, l[0]),
                i.fromBufferAttribute(a, l[1]),
                o.fromBufferAttribute(a, l[2]),
                wo.getNormal(Mo),
                (c[0] = `${Math.round(e.x * n)},${Math.round(
                  e.y * n
                )},${Math.round(e.z * n)}`),
                (c[1] = `${Math.round(i.x * n)},${Math.round(
                  i.y * n
                )},${Math.round(i.z * n)}`),
                (c[2] = `${Math.round(o.x * n)},${Math.round(
                  o.y * n
                )},${Math.round(o.z * n)}`),
                c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
              )
                for (let t = 0; t < 3; t++) {
                  const e = (t + 1) % 3,
                    i = c[t],
                    n = c[e],
                    s = wo[h[t]],
                    a = wo[h[e]],
                    o = `${i}_${n}`,
                    p = `${n}_${i}`;
                  p in u && u[p]
                    ? (Mo.dot(u[p].normal) <= r &&
                        (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)),
                      (u[p] = null))
                    : o in u ||
                      (u[o] = {
                        index0: l[t],
                        index1: l[e],
                        normal: Mo.clone(),
                      });
                }
            }
            for (const t in u)
              if (u[t]) {
                const { index0: e, index1: i } = u[t];
                _o.fromBufferAttribute(a, e),
                  bo.fromBufferAttribute(a, i),
                  d.push(_o.x, _o.y, _o.z),
                  d.push(bo.x, bo.y, bo.z);
              }
            this.setAttribute("position", new wi(d, 3));
          }
        }
      }
      class To {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(t, e) {
          const i = this.getUtoTmapping(t);
          return this.getPoint(i, e);
        }
        getPoints(t = 5) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return e;
        }
        getSpacedPoints(t = 5) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
          return e;
        }
        getLength() {
          const t = this.getLengths();
          return t[t.length - 1];
        }
        getLengths(t = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const e = [];
          let i,
            n = this.getPoint(0),
            r = 0;
          e.push(0);
          for (let s = 1; s <= t; s++)
            (i = this.getPoint(s / t)),
              (r += i.distanceTo(n)),
              e.push(r),
              (n = i);
          return (this.cacheArcLengths = e), e;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(t, e) {
          const i = this.getLengths();
          let n = 0;
          const r = i.length;
          let s;
          s = e || t * i[r - 1];
          let a,
            o = 0,
            l = r - 1;
          for (; o <= l; )
            if (((n = Math.floor(o + (l - o) / 2)), (a = i[n] - s), a < 0))
              o = n + 1;
            else {
              if (!(a > 0)) {
                l = n;
                break;
              }
              l = n - 1;
            }
          if (((n = l), i[n] === s)) return n / (r - 1);
          const h = i[n];
          return (n + (s - h) / (i[n + 1] - h)) / (r - 1);
        }
        getTangent(t, e) {
          const i = 1e-4;
          let n = t - i,
            r = t + i;
          n < 0 && (n = 0), r > 1 && (r = 1);
          const s = this.getPoint(n),
            a = this.getPoint(r),
            o = e || (s.isVector2 ? new Et() : new Jt());
          return o.copy(a).sub(s).normalize(), o;
        }
        getTangentAt(t, e) {
          const i = this.getUtoTmapping(t);
          return this.getTangent(i, e);
        }
        computeFrenetFrames(t, e) {
          const i = new Jt(),
            n = [],
            r = [],
            s = [],
            a = new Jt(),
            o = new Ee();
          for (let e = 0; e <= t; e++) {
            const i = e / t;
            n[e] = this.getTangentAt(i, new Jt());
          }
          (r[0] = new Jt()), (s[0] = new Jt());
          let l = Number.MAX_VALUE;
          const h = Math.abs(n[0].x),
            c = Math.abs(n[0].y),
            u = Math.abs(n[0].z);
          h <= l && ((l = h), i.set(1, 0, 0)),
            c <= l && ((l = c), i.set(0, 1, 0)),
            u <= l && i.set(0, 0, 1),
            a.crossVectors(n[0], i).normalize(),
            r[0].crossVectors(n[0], a),
            s[0].crossVectors(n[0], r[0]);
          for (let e = 1; e <= t; e++) {
            if (
              ((r[e] = r[e - 1].clone()),
              (s[e] = s[e - 1].clone()),
              a.crossVectors(n[e - 1], n[e]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const t = Math.acos(vt(n[e - 1].dot(n[e]), -1, 1));
              r[e].applyMatrix4(o.makeRotationAxis(a, t));
            }
            s[e].crossVectors(n[e], r[e]);
          }
          if (!0 === e) {
            let e = Math.acos(vt(r[0].dot(r[t]), -1, 1));
            (e /= t), n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
            for (let i = 1; i <= t; i++)
              r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)),
                s[i].crossVectors(n[i], r[i]);
          }
          return { tangents: n, normals: r, binormals: s };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
      }
      class Eo extends To {
        constructor(
          t = 0,
          e = 0,
          i = 1,
          n = 1,
          r = 0,
          s = 2 * Math.PI,
          a = !1,
          o = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = i),
            (this.yRadius = n),
            (this.aStartAngle = r),
            (this.aEndAngle = s),
            (this.aClockwise = a),
            (this.aRotation = o);
        }
        getPoint(t, e) {
          const i = e || new Et(),
            n = 2 * Math.PI;
          let r = this.aEndAngle - this.aStartAngle;
          const s = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += n;
          for (; r > n; ) r -= n;
          r < Number.EPSILON && (r = s ? 0 : n),
            !0 !== this.aClockwise || s || (r === n ? (r = -n) : (r -= n));
          const a = this.aStartAngle + t * r;
          let o = this.aX + this.xRadius * Math.cos(a),
            l = this.aY + this.yRadius * Math.sin(a);
          if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              i = o - this.aX,
              n = l - this.aY;
            (o = i * t - n * e + this.aX), (l = i * e + n * t + this.aY);
          }
          return i.set(o, l);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
      }
      Eo.prototype.isEllipseCurve = !0;
      class Ao extends Eo {
        constructor(t, e, i, n, r, s) {
          super(t, e, i, i, n, r, s), (this.type = "ArcCurve");
        }
      }
      function Ro() {
        let t = 0,
          e = 0,
          i = 0,
          n = 0;
        function r(r, s, a, o) {
          (t = r),
            (e = a),
            (i = -3 * r + 3 * s - 2 * a - o),
            (n = 2 * r - 2 * s + a + o);
        }
        return {
          initCatmullRom: function (t, e, i, n, s) {
            r(e, i, s * (i - t), s * (n - e));
          },
          initNonuniformCatmullRom: function (t, e, i, n, s, a, o) {
            let l = (e - t) / s - (i - t) / (s + a) + (i - e) / a,
              h = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
            (l *= a), (h *= a), r(e, i, l, h);
          },
          calc: function (r) {
            const s = r * r;
            return t + e * r + i * s + n * (s * r);
          },
        };
      }
      Ao.prototype.isArcCurve = !0;
      const Lo = new Jt(),
        Co = new Ro(),
        Po = new Ro(),
        Io = new Ro();
      class zo extends To {
        constructor(t = [], e = !1, i = "centripetal", n = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = t),
            (this.closed = e),
            (this.curveType = i),
            (this.tension = n);
        }
        getPoint(t, e = new Jt()) {
          const i = e,
            n = this.points,
            r = n.length,
            s = (r - (this.closed ? 0 : 1)) * t;
          let a,
            o,
            l = Math.floor(s),
            h = s - l;
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
            : 0 === h && l === r - 1 && ((l = r - 2), (h = 1)),
            this.closed || l > 0
              ? (a = n[(l - 1) % r])
              : (Lo.subVectors(n[0], n[1]).add(n[0]), (a = Lo));
          const c = n[l % r],
            u = n[(l + 1) % r];
          if (
            (this.closed || l + 2 < r
              ? (o = n[(l + 2) % r])
              : (Lo.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), (o = Lo)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            const t = "chordal" === this.curveType ? 0.5 : 0.25;
            let e = Math.pow(a.distanceToSquared(c), t),
              i = Math.pow(c.distanceToSquared(u), t),
              n = Math.pow(u.distanceToSquared(o), t);
            i < 1e-4 && (i = 1),
              e < 1e-4 && (e = i),
              n < 1e-4 && (n = i),
              Co.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, e, i, n),
              Po.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, e, i, n),
              Io.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, e, i, n);
          } else
            "catmullrom" === this.curveType &&
              (Co.initCatmullRom(a.x, c.x, u.x, o.x, this.tension),
              Po.initCatmullRom(a.y, c.y, u.y, o.y, this.tension),
              Io.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
          return i.set(Co.calc(h), Po.calc(h), Io.calc(h)), i;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(i.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e];
            t.points.push(i.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(new Jt().fromArray(i));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
      }
      function Do(t, e, i, n, r) {
        const s = 0.5 * (n - e),
          a = 0.5 * (r - i),
          o = t * t;
        return (
          (2 * i - 2 * n + s + a) * (t * o) +
          (-3 * i + 3 * n - 2 * s - a) * o +
          s * t +
          i
        );
      }
      function No(t, e, i, n) {
        return (
          (function (t, e) {
            const i = 1 - t;
            return i * i * e;
          })(t, e) +
          (function (t, e) {
            return 2 * (1 - t) * t * e;
          })(t, i) +
          (function (t, e) {
            return t * t * e;
          })(t, n)
        );
      }
      function Oo(t, e, i, n, r) {
        return (
          (function (t, e) {
            const i = 1 - t;
            return i * i * i * e;
          })(t, e) +
          (function (t, e) {
            const i = 1 - t;
            return 3 * i * i * t * e;
          })(t, i) +
          (function (t, e) {
            return 3 * (1 - t) * t * t * e;
          })(t, n) +
          (function (t, e) {
            return t * t * t * e;
          })(t, r)
        );
      }
      zo.prototype.isCatmullRomCurve3 = !0;
      class Bo extends To {
        constructor(t = new Et(), e = new Et(), i = new Et(), n = new Et()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i),
            (this.v3 = n);
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.v0,
            r = this.v1,
            s = this.v2,
            a = this.v3;
          return i.set(Oo(t, n.x, r.x, s.x, a.x), Oo(t, n.y, r.y, s.y, a.y)), i;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      Bo.prototype.isCubicBezierCurve = !0;
      class Fo extends To {
        constructor(t = new Jt(), e = new Jt(), i = new Jt(), n = new Jt()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i),
            (this.v3 = n);
        }
        getPoint(t, e = new Jt()) {
          const i = e,
            n = this.v0,
            r = this.v1,
            s = this.v2,
            a = this.v3;
          return (
            i.set(
              Oo(t, n.x, r.x, s.x, a.x),
              Oo(t, n.y, r.y, s.y, a.y),
              Oo(t, n.z, r.z, s.z, a.z)
            ),
            i
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      Fo.prototype.isCubicBezierCurve3 = !0;
      class Ho extends To {
        constructor(t = new Et(), e = new Et()) {
          super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
        }
        getPoint(t, e = new Et()) {
          const i = e;
          return (
            1 === t
              ? i.copy(this.v2)
              : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(t).add(this.v1)),
            i
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e) {
          const i = e || new Et();
          return i.copy(this.v2).sub(this.v1).normalize(), i;
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      Ho.prototype.isLineCurve = !0;
      class Uo extends To {
        constructor(t = new Jt(), e = new Jt()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new Jt()) {
          const i = e;
          return (
            1 === t
              ? i.copy(this.v2)
              : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(t).add(this.v1)),
            i
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      class ko extends To {
        constructor(t = new Et(), e = new Et(), i = new Et()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i);
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.v0,
            r = this.v1,
            s = this.v2;
          return i.set(No(t, n.x, r.x, s.x), No(t, n.y, r.y, s.y)), i;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      ko.prototype.isQuadraticBezierCurve = !0;
      class Go extends To {
        constructor(t = new Jt(), e = new Jt(), i = new Jt()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i);
        }
        getPoint(t, e = new Jt()) {
          const i = e,
            n = this.v0,
            r = this.v1,
            s = this.v2;
          return (
            i.set(
              No(t, n.x, r.x, s.x),
              No(t, n.y, r.y, s.y),
              No(t, n.z, r.z, s.z)
            ),
            i
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      Go.prototype.isQuadraticBezierCurve3 = !0;
      class Vo extends To {
        constructor(t = []) {
          super(), (this.type = "SplineCurve"), (this.points = t);
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.points,
            r = (n.length - 1) * t,
            s = Math.floor(r),
            a = r - s,
            o = n[0 === s ? s : s - 1],
            l = n[s],
            h = n[s > n.length - 2 ? n.length - 1 : s + 1],
            c = n[s > n.length - 3 ? n.length - 1 : s + 2];
          return i.set(Do(a, o.x, l.x, h.x, c.x), Do(a, o.y, l.y, h.y, c.y)), i;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e];
            t.points.push(i.toArray());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(new Et().fromArray(i));
          }
          return this;
        }
      }
      Vo.prototype.isSplineCurve = !0;
      var Wo = Object.freeze({
        __proto__: null,
        ArcCurve: Ao,
        CatmullRomCurve3: zo,
        CubicBezierCurve: Bo,
        CubicBezierCurve3: Fo,
        EllipseCurve: Eo,
        LineCurve: Ho,
        LineCurve3: Uo,
        QuadraticBezierCurve: ko,
        QuadraticBezierCurve3: Go,
        SplineCurve: Vo,
      });
      class jo extends To {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(t) {
          this.curves.push(t);
        }
        closePath() {
          const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          t.equals(e) || this.curves.push(new Ho(e, t));
        }
        getPoint(t, e) {
          const i = t * this.getLength(),
            n = this.getCurveLengths();
          let r = 0;
          for (; r < n.length; ) {
            if (n[r] >= i) {
              const t = n[r] - i,
                s = this.curves[r],
                a = s.getLength(),
                o = 0 === a ? 0 : 1 - t / a;
              return s.getPointAt(o, e);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const t = this.getCurveLengths();
          return t[t.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const t = [];
          let e = 0;
          for (let i = 0, n = this.curves.length; i < n; i++)
            (e += this.curves[i].getLength()), t.push(e);
          return (this.cacheLengths = t), t;
        }
        getSpacedPoints(t = 40) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return this.autoClose && e.push(e[0]), e;
        }
        getPoints(t = 12) {
          const e = [];
          let i;
          for (let n = 0, r = this.curves; n < r.length; n++) {
            const s = r[n],
              a =
                s && s.isEllipseCurve
                  ? 2 * t
                  : s && (s.isLineCurve || s.isLineCurve3)
                  ? 1
                  : s && s.isSplineCurve
                  ? t * s.points.length
                  : t,
              o = s.getPoints(a);
            for (let t = 0; t < o.length; t++) {
              const n = o[t];
              (i && i.equals(n)) || (e.push(n), (i = n));
            }
          }
          return (
            this.autoClose &&
              e.length > 1 &&
              !e[e.length - 1].equals(e[0]) &&
              e.push(e[0]),
            e
          );
        }
        copy(t) {
          super.copy(t), (this.curves = []);
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e];
            this.curves.push(i.clone());
          }
          return (this.autoClose = t.autoClose), this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.autoClose = this.autoClose), (t.curves = []);
          for (let e = 0, i = this.curves.length; e < i; e++) {
            const i = this.curves[e];
            t.curves.push(i.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e];
            this.curves.push(new Wo[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class qo extends jo {
        constructor(t) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new Et()),
            t && this.setFromPoints(t);
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this;
        }
        lineTo(t, e) {
          const i = new Ho(this.currentPoint.clone(), new Et(t, e));
          return this.curves.push(i), this.currentPoint.set(t, e), this;
        }
        quadraticCurveTo(t, e, i, n) {
          const r = new ko(
            this.currentPoint.clone(),
            new Et(t, e),
            new Et(i, n)
          );
          return this.curves.push(r), this.currentPoint.set(i, n), this;
        }
        bezierCurveTo(t, e, i, n, r, s) {
          const a = new Bo(
            this.currentPoint.clone(),
            new Et(t, e),
            new Et(i, n),
            new Et(r, s)
          );
          return this.curves.push(a), this.currentPoint.set(r, s), this;
        }
        splineThru(t) {
          const e = [this.currentPoint.clone()].concat(t),
            i = new Vo(e);
          return (
            this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
          );
        }
        arc(t, e, i, n, r, s) {
          const a = this.currentPoint.x,
            o = this.currentPoint.y;
          return this.absarc(t + a, e + o, i, n, r, s), this;
        }
        absarc(t, e, i, n, r, s) {
          return this.absellipse(t, e, i, i, n, r, s), this;
        }
        ellipse(t, e, i, n, r, s, a, o) {
          const l = this.currentPoint.x,
            h = this.currentPoint.y;
          return this.absellipse(t + l, e + h, i, n, r, s, a, o), this;
        }
        absellipse(t, e, i, n, r, s, a, o) {
          const l = new Eo(t, e, i, n, r, s, a, o);
          if (this.curves.length > 0) {
            const t = l.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
          }
          this.curves.push(l);
          const h = l.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.currentPoint = this.currentPoint.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          );
        }
      }
      class Xo extends qo {
        constructor(t) {
          super(t),
            (this.uuid = xt()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(t) {
          const e = [];
          for (let i = 0, n = this.holes.length; i < n; i++)
            e[i] = this.holes[i].getPoints(t);
          return e;
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        }
        copy(t) {
          super.copy(t), (this.holes = []);
          for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.uuid = this.uuid), (t.holes = []);
          for (let e = 0, i = this.holes.length; e < i; e++) {
            const i = this.holes[e];
            t.holes.push(i.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
          for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e];
            this.holes.push(new qo().fromJSON(i));
          }
          return this;
        }
      }
      function Yo(t, e, i, n, r) {
        let s, a;
        if (
          r ===
          (function (t, e, i, n) {
            let r = 0;
            for (let s = e, a = i - n; s < i; s += n)
              (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
            return r;
          })(t, e, i, n) >
            0
        )
          for (s = e; s < i; s += n) a = fl(s, t[s], t[s + 1], a);
        else for (s = i - n; s >= e; s -= n) a = fl(s, t[s], t[s + 1], a);
        return a && hl(a, a.next) && (gl(a), (a = a.next)), a;
      }
      function Jo(t, e) {
        if (!t) return t;
        e || (e = t);
        let i,
          n = t;
        do {
          if (
            ((i = !1),
            n.steiner || (!hl(n, n.next) && 0 !== ll(n.prev, n, n.next)))
          )
            n = n.next;
          else {
            if ((gl(n), (n = e = n.prev), n === n.next)) break;
            i = !0;
          }
        } while (i || n !== e);
        return e;
      }
      function Zo(t, e, i, n, r, s, a) {
        if (!t) return;
        !a &&
          s &&
          (function (t, e, i, n) {
            let r = t;
            do {
              null === r.z && (r.z = rl(r.x, r.y, e, i, n)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== t);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (t) {
                let e,
                  i,
                  n,
                  r,
                  s,
                  a,
                  o,
                  l,
                  h = 1;
                do {
                  for (i = t, t = null, s = null, a = 0; i; ) {
                    for (
                      a++, n = i, o = 0, e = 0;
                      e < h && (o++, (n = n.nextZ), n);
                      e++
                    );
                    for (l = h; o > 0 || (l > 0 && n); )
                      0 !== o && (0 === l || !n || i.z <= n.z)
                        ? ((r = i), (i = i.nextZ), o--)
                        : ((r = n), (n = n.nextZ), l--),
                        s ? (s.nextZ = r) : (t = r),
                        (r.prevZ = s),
                        (s = r);
                    i = n;
                  }
                  (s.nextZ = null), (h *= 2);
                } while (a > 1);
              })(r);
          })(t, n, r, s);
        let o,
          l,
          h = t;
        for (; t.prev !== t.next; )
          if (((o = t.prev), (l = t.next), s ? Qo(t, n, r, s) : Ko(t)))
            e.push(o.i / i),
              e.push(t.i / i),
              e.push(l.i / i),
              gl(t),
              (t = l.next),
              (h = l.next);
          else if ((t = l) === h) {
            a
              ? 1 === a
                ? Zo((t = $o(Jo(t), e, i)), e, i, n, r, s, 2)
                : 2 === a && tl(t, e, i, n, r, s)
              : Zo(Jo(t), e, i, n, r, s, 1);
            break;
          }
      }
      function Ko(t) {
        const e = t.prev,
          i = t,
          n = t.next;
        if (ll(e, i, n) >= 0) return !1;
        let r = t.next.next;
        for (; r !== t.prev; ) {
          if (
            al(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
            ll(r.prev, r, r.next) >= 0
          )
            return !1;
          r = r.next;
        }
        return !0;
      }
      function Qo(t, e, i, n) {
        const r = t.prev,
          s = t,
          a = t.next;
        if (ll(r, s, a) >= 0) return !1;
        const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,
          l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,
          h = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,
          c = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,
          u = rl(o, l, e, i, n),
          d = rl(h, c, e, i, n);
        let p = t.prevZ,
          m = t.nextZ;
        for (; p && p.z >= u && m && m.z <= d; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            al(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
            ll(p.prev, p, p.next) >= 0
          )
            return !1;
          if (
            ((p = p.prevZ),
            m !== t.prev &&
              m !== t.next &&
              al(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
              ll(m.prev, m, m.next) >= 0)
          )
            return !1;
          m = m.nextZ;
        }
        for (; p && p.z >= u; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            al(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
            ll(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.prevZ;
        }
        for (; m && m.z <= d; ) {
          if (
            m !== t.prev &&
            m !== t.next &&
            al(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
            ll(m.prev, m, m.next) >= 0
          )
            return !1;
          m = m.nextZ;
        }
        return !0;
      }
      function $o(t, e, i) {
        let n = t;
        do {
          const r = n.prev,
            s = n.next.next;
          !hl(r, s) &&
            cl(r, n, n.next, s) &&
            pl(r, s) &&
            pl(s, r) &&
            (e.push(r.i / i),
            e.push(n.i / i),
            e.push(s.i / i),
            gl(n),
            gl(n.next),
            (n = t = s)),
            (n = n.next);
        } while (n !== t);
        return Jo(n);
      }
      function tl(t, e, i, n, r, s) {
        let a = t;
        do {
          let t = a.next.next;
          for (; t !== a.prev; ) {
            if (a.i !== t.i && ol(a, t)) {
              let o = ml(a, t);
              return (
                (a = Jo(a, a.next)),
                (o = Jo(o, o.next)),
                Zo(a, e, i, n, r, s),
                void Zo(o, e, i, n, r, s)
              );
            }
            t = t.next;
          }
          a = a.next;
        } while (a !== t);
      }
      function el(t, e) {
        return t.x - e.x;
      }
      function il(t, e) {
        if (
          ((e = (function (t, e) {
            let i = e;
            const n = t.x,
              r = t.y;
            let s,
              a = -1 / 0;
            do {
              if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                const t =
                  i.x + ((r - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                if (t <= n && t > a) {
                  if (((a = t), t === n)) {
                    if (r === i.y) return i;
                    if (r === i.next.y) return i.next;
                  }
                  s = i.x < i.next.x ? i : i.next;
                }
              }
              i = i.next;
            } while (i !== e);
            if (!s) return null;
            if (n === a) return s;
            const o = s,
              l = s.x,
              h = s.y;
            let c,
              u = 1 / 0;
            i = s;
            do {
              n >= i.x &&
                i.x >= l &&
                n !== i.x &&
                al(r < h ? n : a, r, l, h, r < h ? a : n, r, i.x, i.y) &&
                ((c = Math.abs(r - i.y) / (n - i.x)),
                pl(i, t) &&
                  (c < u ||
                    (c === u && (i.x > s.x || (i.x === s.x && nl(s, i))))) &&
                  ((s = i), (u = c))),
                (i = i.next);
            } while (i !== o);
            return s;
          })(t, e)),
          e)
        ) {
          const i = ml(e, t);
          Jo(e, e.next), Jo(i, i.next);
        }
      }
      function nl(t, e) {
        return ll(t.prev, t, e.prev) < 0 && ll(e.next, t, t.next) < 0;
      }
      function rl(t, e, i, n, r) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) <<
            1)
        );
      }
      function sl(t) {
        let e = t,
          i = t;
        do {
          (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
        } while (e !== t);
        return i;
      }
      function al(t, e, i, n, r, s, a, o) {
        return (
          (r - a) * (e - o) - (t - a) * (s - o) >= 0 &&
          (t - a) * (n - o) - (i - a) * (e - o) >= 0 &&
          (i - a) * (s - o) - (r - a) * (n - o) >= 0
        );
      }
      function ol(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let i = t;
            do {
              if (
                i.i !== t.i &&
                i.next.i !== t.i &&
                i.i !== e.i &&
                i.next.i !== e.i &&
                cl(i, i.next, t, e)
              )
                return !0;
              i = i.next;
            } while (i !== t);
            return !1;
          })(t, e) &&
          ((pl(t, e) &&
            pl(e, t) &&
            (function (t, e) {
              let i = t,
                n = !1;
              const r = (t.x + e.x) / 2,
                s = (t.y + e.y) / 2;
              do {
                i.y > s != i.next.y > s &&
                  i.next.y !== i.y &&
                  r < ((i.next.x - i.x) * (s - i.y)) / (i.next.y - i.y) + i.x &&
                  (n = !n),
                  (i = i.next);
              } while (i !== t);
              return n;
            })(t, e) &&
            (ll(t.prev, t, e.prev) || ll(t, e.prev, e))) ||
            (hl(t, e) &&
              ll(t.prev, t, t.next) > 0 &&
              ll(e.prev, e, e.next) > 0))
        );
      }
      function ll(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
      }
      function hl(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function cl(t, e, i, n) {
        const r = dl(ll(t, e, i)),
          s = dl(ll(t, e, n)),
          a = dl(ll(i, n, t)),
          o = dl(ll(i, n, e));
        return (
          (r !== s && a !== o) ||
          !(0 !== r || !ul(t, i, e)) ||
          !(0 !== s || !ul(t, n, e)) ||
          !(0 !== a || !ul(i, t, n)) ||
          !(0 !== o || !ul(i, e, n))
        );
      }
      function ul(t, e, i) {
        return (
          e.x <= Math.max(t.x, i.x) &&
          e.x >= Math.min(t.x, i.x) &&
          e.y <= Math.max(t.y, i.y) &&
          e.y >= Math.min(t.y, i.y)
        );
      }
      function dl(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function pl(t, e) {
        return ll(t.prev, t, t.next) < 0
          ? ll(t, e, t.next) >= 0 && ll(t, t.prev, e) >= 0
          : ll(t, e, t.prev) < 0 || ll(t, t.next, e) < 0;
      }
      function ml(t, e) {
        const i = new yl(t.i, t.x, t.y),
          n = new yl(e.i, e.x, e.y),
          r = t.next,
          s = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (i.next = r),
          (r.prev = i),
          (n.next = i),
          (i.prev = n),
          (s.next = n),
          (n.prev = s),
          n
        );
      }
      function fl(t, e, i, n) {
        const r = new yl(t, e, i);
        return (
          n
            ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function gl(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function yl(t, e, i) {
        (this.i = t),
          (this.x = e),
          (this.y = i),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      class xl {
        static area(t) {
          const e = t.length;
          let i = 0;
          for (let n = e - 1, r = 0; r < e; n = r++)
            i += t[n].x * t[r].y - t[r].x * t[n].y;
          return 0.5 * i;
        }
        static isClockWise(t) {
          return xl.area(t) < 0;
        }
        static triangulateShape(t, e) {
          const i = [],
            n = [],
            r = [];
          vl(t), _l(i, t);
          let s = t.length;
          e.forEach(vl);
          for (let t = 0; t < e.length; t++)
            n.push(s), (s += e[t].length), _l(i, e[t]);
          const a = (function (t, e, i = 2) {
            const n = e && e.length,
              r = n ? e[0] * i : t.length;
            let s = Yo(t, 0, r, i, !0);
            const a = [];
            if (!s || s.next === s.prev) return a;
            let o, l, h, c, u, d, p;
            if (
              (n &&
                (s = (function (t, e, i, n) {
                  const r = [];
                  let s, a, o, l, h;
                  for (s = 0, a = e.length; s < a; s++)
                    (o = e[s] * n),
                      (l = s < a - 1 ? e[s + 1] * n : t.length),
                      (h = Yo(t, o, l, n, !1)),
                      h === h.next && (h.steiner = !0),
                      r.push(sl(h));
                  for (r.sort(el), s = 0; s < r.length; s++)
                    il(r[s], i), (i = Jo(i, i.next));
                  return i;
                })(t, e, s, i)),
              t.length > 80 * i)
            ) {
              (o = h = t[0]), (l = c = t[1]);
              for (let e = i; e < r; e += i)
                (u = t[e]),
                  (d = t[e + 1]),
                  u < o && (o = u),
                  d < l && (l = d),
                  u > h && (h = u),
                  d > c && (c = d);
              (p = Math.max(h - o, c - l)), (p = 0 !== p ? 1 / p : 0);
            }
            return Zo(s, a, i, o, l, p), a;
          })(i, n);
          for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
          return r;
        }
      }
      function vl(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop();
      }
      function _l(t, e) {
        for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
      }
      class bl extends Ii {
        constructor(
          t = new Xo([
            new Et(0.5, 0.5),
            new Et(-0.5, 0.5),
            new Et(-0.5, -0.5),
            new Et(0.5, -0.5),
          ]),
          e = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t]);
          const i = this,
            n = [],
            r = [];
          for (let e = 0, i = t.length; e < i; e++) s(t[e]);
          function s(t) {
            const s = [],
              a = void 0 !== e.curveSegments ? e.curveSegments : 12,
              o = void 0 !== e.steps ? e.steps : 1;
            let l = void 0 !== e.depth ? e.depth : 1,
              h = void 0 === e.bevelEnabled || e.bevelEnabled,
              c = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
              u = void 0 !== e.bevelSize ? e.bevelSize : c - 0.1,
              d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
              p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
            const m = e.extrudePath,
              f = void 0 !== e.UVGenerator ? e.UVGenerator : Ml;
            void 0 !== e.amount &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (l = e.amount));
            let g,
              y,
              x,
              v,
              _,
              b = !1;
            m &&
              ((g = m.getSpacedPoints(o)),
              (b = !0),
              (h = !1),
              (y = m.computeFrenetFrames(o, !1)),
              (x = new Jt()),
              (v = new Jt()),
              (_ = new Jt())),
              h || ((p = 0), (c = 0), (u = 0), (d = 0));
            const M = t.extractPoints(a);
            let w = M.shape;
            const S = M.holes;
            if (!xl.isClockWise(w)) {
              w = w.reverse();
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                xl.isClockWise(e) && (S[t] = e.reverse());
              }
            }
            const T = xl.triangulateShape(w, S),
              E = w;
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t];
              w = w.concat(e);
            }
            function A(t, e, i) {
              return (
                e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(i).add(t)
              );
            }
            const R = w.length,
              L = T.length;
            function C(t, e, i) {
              let n, r, s;
              const a = t.x - e.x,
                o = t.y - e.y,
                l = i.x - t.x,
                h = i.y - t.y,
                c = a * a + o * o,
                u = a * h - o * l;
              if (Math.abs(u) > Number.EPSILON) {
                const u = Math.sqrt(c),
                  d = Math.sqrt(l * l + h * h),
                  p = e.x - o / u,
                  m = e.y + a / u,
                  f =
                    ((i.x - h / d - p) * h - (i.y + l / d - m) * l) /
                    (a * h - o * l);
                (n = p + a * f - t.x), (r = m + o * f - t.y);
                const g = n * n + r * r;
                if (g <= 2) return new Et(n, r);
                s = Math.sqrt(g / 2);
              } else {
                let t = !1;
                a > Number.EPSILON
                  ? l > Number.EPSILON && (t = !0)
                  : a < -Number.EPSILON
                  ? l < -Number.EPSILON && (t = !0)
                  : Math.sign(o) === Math.sign(h) && (t = !0),
                  t
                    ? ((n = -o), (r = a), (s = Math.sqrt(c)))
                    : ((n = a), (r = o), (s = Math.sqrt(c / 2)));
              }
              return new Et(n / s, r / s);
            }
            const P = [];
            for (
              let t = 0, e = E.length, i = e - 1, n = t + 1;
              t < e;
              t++, i++, n++
            )
              i === e && (i = 0),
                n === e && (n = 0),
                (P[t] = C(E[t], E[i], E[n]));
            const I = [];
            let z,
              D = P.concat();
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t];
              z = [];
              for (
                let t = 0, i = e.length, n = i - 1, r = t + 1;
                t < i;
                t++, n++, r++
              )
                n === i && (n = 0),
                  r === i && (r = 0),
                  (z[t] = C(e[t], e[n], e[r]));
              I.push(z), (D = D.concat(z));
            }
            for (let t = 0; t < p; t++) {
              const e = t / p,
                i = c * Math.cos((e * Math.PI) / 2),
                n = u * Math.sin((e * Math.PI) / 2) + d;
              for (let t = 0, e = E.length; t < e; t++) {
                const e = A(E[t], P[t], n);
                B(e.x, e.y, -i);
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                z = I[t];
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = A(e[t], z[t], n);
                  B(r.x, r.y, -i);
                }
              }
            }
            const N = u + d;
            for (let t = 0; t < R; t++) {
              const e = h ? A(w[t], D[t], N) : w[t];
              b
                ? (v.copy(y.normals[0]).multiplyScalar(e.x),
                  x.copy(y.binormals[0]).multiplyScalar(e.y),
                  _.copy(g[0]).add(v).add(x),
                  B(_.x, _.y, _.z))
                : B(e.x, e.y, 0);
            }
            for (let t = 1; t <= o; t++)
              for (let e = 0; e < R; e++) {
                const i = h ? A(w[e], D[e], N) : w[e];
                b
                  ? (v.copy(y.normals[t]).multiplyScalar(i.x),
                    x.copy(y.binormals[t]).multiplyScalar(i.y),
                    _.copy(g[t]).add(v).add(x),
                    B(_.x, _.y, _.z))
                  : B(i.x, i.y, (l / o) * t);
              }
            for (let t = p - 1; t >= 0; t--) {
              const e = t / p,
                i = c * Math.cos((e * Math.PI) / 2),
                n = u * Math.sin((e * Math.PI) / 2) + d;
              for (let t = 0, e = E.length; t < e; t++) {
                const e = A(E[t], P[t], n);
                B(e.x, e.y, l + i);
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                z = I[t];
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = A(e[t], z[t], n);
                  b
                    ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + i)
                    : B(r.x, r.y, l + i);
                }
              }
            }
            function O(t, e) {
              let i = t.length;
              for (; --i >= 0; ) {
                const n = i;
                let r = i - 1;
                r < 0 && (r = t.length - 1);
                for (let t = 0, i = o + 2 * p; t < i; t++) {
                  const i = R * t,
                    s = R * (t + 1);
                  H(e + n + i, e + r + i, e + r + s, e + n + s);
                }
              }
            }
            function B(t, e, i) {
              s.push(t), s.push(e), s.push(i);
            }
            function F(t, e, r) {
              U(t), U(e), U(r);
              const s = n.length / 3,
                a = f.generateTopUV(i, n, s - 3, s - 2, s - 1);
              k(a[0]), k(a[1]), k(a[2]);
            }
            function H(t, e, r, s) {
              U(t), U(e), U(s), U(e), U(r), U(s);
              const a = n.length / 3,
                o = f.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
              k(o[0]), k(o[1]), k(o[3]), k(o[1]), k(o[2]), k(o[3]);
            }
            function U(t) {
              n.push(s[3 * t + 0]), n.push(s[3 * t + 1]), n.push(s[3 * t + 2]);
            }
            function k(t) {
              r.push(t.x), r.push(t.y);
            }
            !(function () {
              const t = n.length / 3;
              if (h) {
                let t = 0,
                  e = R * t;
                for (let t = 0; t < L; t++) {
                  const i = T[t];
                  F(i[2] + e, i[1] + e, i[0] + e);
                }
                (t = o + 2 * p), (e = R * t);
                for (let t = 0; t < L; t++) {
                  const i = T[t];
                  F(i[0] + e, i[1] + e, i[2] + e);
                }
              } else {
                for (let t = 0; t < L; t++) {
                  const e = T[t];
                  F(e[2], e[1], e[0]);
                }
                for (let t = 0; t < L; t++) {
                  const e = T[t];
                  F(e[0] + R * o, e[1] + R * o, e[2] + R * o);
                }
              }
              i.addGroup(t, n.length / 3 - t, 0);
            })(),
              (function () {
                const t = n.length / 3;
                let e = 0;
                O(E, e), (e += E.length);
                for (let t = 0, i = S.length; t < i; t++) {
                  const i = S[t];
                  O(i, e), (e += i.length);
                }
                i.addGroup(t, n.length / 3 - t, 1);
              })();
          }
          this.setAttribute("position", new wi(n, 3)),
            this.setAttribute("uv", new wi(r, 2)),
            this.computeVertexNormals();
        }
        toJSON() {
          const t = super.toJSON();
          return (function (t, e, i) {
            if (((i.shapes = []), Array.isArray(t)))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                i.shapes.push(n.uuid);
              }
            else i.shapes.push(t.uuid);
            return (
              void 0 !== e.extrudePath &&
                (i.options.extrudePath = e.extrudePath.toJSON()),
              i
            );
          })(this.parameters.shapes, this.parameters.options, t);
        }
        static fromJSON(t, e) {
          const i = [];
          for (let n = 0, r = t.shapes.length; n < r; n++) {
            const r = e[t.shapes[n]];
            i.push(r);
          }
          const n = t.options.extrudePath;
          return (
            void 0 !== n &&
              (t.options.extrudePath = new Wo[n.type]().fromJSON(n)),
            new bl(i, t.options)
          );
        }
      }
      const Ml = {
        generateTopUV: function (t, e, i, n, r) {
          const s = e[3 * i],
            a = e[3 * i + 1],
            o = e[3 * n],
            l = e[3 * n + 1],
            h = e[3 * r],
            c = e[3 * r + 1];
          return [new Et(s, a), new Et(o, l), new Et(h, c)];
        },
        generateSideWallUV: function (t, e, i, n, r, s) {
          const a = e[3 * i],
            o = e[3 * i + 1],
            l = e[3 * i + 2],
            h = e[3 * n],
            c = e[3 * n + 1],
            u = e[3 * n + 2],
            d = e[3 * r],
            p = e[3 * r + 1],
            m = e[3 * r + 2],
            f = e[3 * s],
            g = e[3 * s + 1],
            y = e[3 * s + 2];
          return Math.abs(o - c) < Math.abs(a - h)
            ? [
                new Et(a, 1 - l),
                new Et(h, 1 - u),
                new Et(d, 1 - m),
                new Et(f, 1 - y),
              ]
            : [
                new Et(o, 1 - l),
                new Et(c, 1 - u),
                new Et(p, 1 - m),
                new Et(g, 1 - y),
              ];
        },
      };
      class wl extends xo {
        constructor(t = 1, e = 0) {
          const i = (1 + Math.sqrt(5)) / 2;
          super(
            [
              -1,
              i,
              0,
              1,
              i,
              0,
              -1,
              -i,
              0,
              1,
              -i,
              0,
              0,
              -1,
              i,
              0,
              1,
              i,
              0,
              -1,
              -i,
              0,
              1,
              -i,
              i,
              0,
              -1,
              i,
              0,
              1,
              -i,
              0,
              -1,
              -i,
              0,
              1,
            ],
            [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ],
            t,
            e
          ),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new wl(t.radius, t.detail);
        }
      }
      class Sl extends Ii {
        constructor(
          t = [new Et(0, 0.5), new Et(0.5, 0), new Et(0, -0.5)],
          e = 12,
          i = 0,
          n = 2 * Math.PI
        ) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: t,
              segments: e,
              phiStart: i,
              phiLength: n,
            }),
            (e = Math.floor(e)),
            (n = vt(n, 0, 2 * Math.PI));
          const r = [],
            s = [],
            a = [],
            o = [],
            l = [],
            h = 1 / e,
            c = new Jt(),
            u = new Et(),
            d = new Jt(),
            p = new Jt(),
            m = new Jt();
          let f = 0,
            g = 0;
          for (let e = 0; e <= t.length - 1; e++)
            switch (e) {
              case 0:
                (f = t[e + 1].x - t[e].x),
                  (g = t[e + 1].y - t[e].y),
                  (d.x = 1 * g),
                  (d.y = -f),
                  (d.z = 0 * g),
                  m.copy(d),
                  d.normalize(),
                  o.push(d.x, d.y, d.z);
                break;
              case t.length - 1:
                o.push(m.x, m.y, m.z);
                break;
              default:
                (f = t[e + 1].x - t[e].x),
                  (g = t[e + 1].y - t[e].y),
                  (d.x = 1 * g),
                  (d.y = -f),
                  (d.z = 0 * g),
                  p.copy(d),
                  (d.x += m.x),
                  (d.y += m.y),
                  (d.z += m.z),
                  d.normalize(),
                  o.push(d.x, d.y, d.z),
                  m.copy(p);
            }
          for (let r = 0; r <= e; r++) {
            const d = i + r * h * n,
              p = Math.sin(d),
              m = Math.cos(d);
            for (let i = 0; i <= t.length - 1; i++) {
              (c.x = t[i].x * p),
                (c.y = t[i].y),
                (c.z = t[i].x * m),
                s.push(c.x, c.y, c.z),
                (u.x = r / e),
                (u.y = i / (t.length - 1)),
                a.push(u.x, u.y);
              const n = o[3 * i + 0] * p,
                h = o[3 * i + 1],
                d = o[3 * i + 0] * m;
              l.push(n, h, d);
            }
          }
          for (let i = 0; i < e; i++)
            for (let e = 0; e < t.length - 1; e++) {
              const n = e + i * t.length,
                s = n,
                a = n + t.length,
                o = n + t.length + 1,
                l = n + 1;
              r.push(s, a, l), r.push(o, l, a);
            }
          this.setIndex(r),
            this.setAttribute("position", new wi(s, 3)),
            this.setAttribute("uv", new wi(a, 2)),
            this.setAttribute("normal", new wi(l, 3));
        }
        static fromJSON(t) {
          return new Sl(t.points, t.segments, t.phiStart, t.phiLength);
        }
      }
      class Tl extends xo {
        constructor(t = 1, e = 0) {
          super(
            [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ],
            t,
            e
          ),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Tl(t.radius, t.detail);
        }
      }
      class El extends Ii {
        constructor(t = 0.5, e = 1, i = 8, n = 1, r = 0, s = 2 * Math.PI) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: t,
              outerRadius: e,
              thetaSegments: i,
              phiSegments: n,
              thetaStart: r,
              thetaLength: s,
            }),
            (i = Math.max(3, i));
          const a = [],
            o = [],
            l = [],
            h = [];
          let c = t;
          const u = (e - t) / (n = Math.max(1, n)),
            d = new Jt(),
            p = new Et();
          for (let t = 0; t <= n; t++) {
            for (let t = 0; t <= i; t++) {
              const n = r + (t / i) * s;
              (d.x = c * Math.cos(n)),
                (d.y = c * Math.sin(n)),
                o.push(d.x, d.y, d.z),
                l.push(0, 0, 1),
                (p.x = (d.x / e + 1) / 2),
                (p.y = (d.y / e + 1) / 2),
                h.push(p.x, p.y);
            }
            c += u;
          }
          for (let t = 0; t < n; t++) {
            const e = t * (i + 1);
            for (let t = 0; t < i; t++) {
              const n = t + e,
                r = n,
                s = n + i + 1,
                o = n + i + 2,
                l = n + 1;
              a.push(r, s, l), a.push(s, o, l);
            }
          }
          this.setIndex(a),
            this.setAttribute("position", new wi(o, 3)),
            this.setAttribute("normal", new wi(l, 3)),
            this.setAttribute("uv", new wi(h, 2));
        }
        static fromJSON(t) {
          return new El(
            t.innerRadius,
            t.outerRadius,
            t.thetaSegments,
            t.phiSegments,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Al extends Ii {
        constructor(
          t = new Xo([new Et(0, 0.5), new Et(-0.5, -0.5), new Et(0.5, -0.5)]),
          e = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: t, curveSegments: e });
          const i = [],
            n = [],
            r = [],
            s = [];
          let a = 0,
            o = 0;
          if (!1 === Array.isArray(t)) l(t);
          else
            for (let e = 0; e < t.length; e++)
              l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
          function l(t) {
            const a = n.length / 3,
              l = t.extractPoints(e);
            let h = l.shape;
            const c = l.holes;
            !1 === xl.isClockWise(h) && (h = h.reverse());
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              !0 === xl.isClockWise(e) && (c[t] = e.reverse());
            }
            const u = xl.triangulateShape(h, c);
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              h = h.concat(e);
            }
            for (let t = 0, e = h.length; t < e; t++) {
              const e = h[t];
              n.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);
            }
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t],
                n = e[0] + a,
                r = e[1] + a,
                s = e[2] + a;
              i.push(n, r, s), (o += 3);
            }
          }
          this.setIndex(i),
            this.setAttribute("position", new wi(n, 3)),
            this.setAttribute("normal", new wi(r, 3)),
            this.setAttribute("uv", new wi(s, 2));
        }
        toJSON() {
          const t = super.toJSON();
          return (function (t, e) {
            if (((e.shapes = []), Array.isArray(t)))
              for (let i = 0, n = t.length; i < n; i++) {
                const n = t[i];
                e.shapes.push(n.uuid);
              }
            else e.shapes.push(t.uuid);
            return e;
          })(this.parameters.shapes, t);
        }
        static fromJSON(t, e) {
          const i = [];
          for (let n = 0, r = t.shapes.length; n < r; n++) {
            const r = e[t.shapes[n]];
            i.push(r);
          }
          return new Al(i, t.curveSegments);
        }
      }
      class Rl extends Ii {
        constructor(
          t = 1,
          e = 32,
          i = 16,
          n = 0,
          r = 2 * Math.PI,
          s = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: t,
              widthSegments: e,
              heightSegments: i,
              phiStart: n,
              phiLength: r,
              thetaStart: s,
              thetaLength: a,
            }),
            (e = Math.max(3, Math.floor(e))),
            (i = Math.max(2, Math.floor(i)));
          const o = Math.min(s + a, Math.PI);
          let l = 0;
          const h = [],
            c = new Jt(),
            u = new Jt(),
            d = [],
            p = [],
            m = [],
            f = [];
          for (let d = 0; d <= i; d++) {
            const g = [],
              y = d / i;
            let x = 0;
            0 == d && 0 == s
              ? (x = 0.5 / e)
              : d == i && o == Math.PI && (x = -0.5 / e);
            for (let i = 0; i <= e; i++) {
              const o = i / e;
              (c.x = -t * Math.cos(n + o * r) * Math.sin(s + y * a)),
                (c.y = t * Math.cos(s + y * a)),
                (c.z = t * Math.sin(n + o * r) * Math.sin(s + y * a)),
                p.push(c.x, c.y, c.z),
                u.copy(c).normalize(),
                m.push(u.x, u.y, u.z),
                f.push(o + x, 1 - y),
                g.push(l++);
            }
            h.push(g);
          }
          for (let t = 0; t < i; t++)
            for (let n = 0; n < e; n++) {
              const e = h[t][n + 1],
                r = h[t][n],
                a = h[t + 1][n],
                l = h[t + 1][n + 1];
              (0 !== t || s > 0) && d.push(e, r, l),
                (t !== i - 1 || o < Math.PI) && d.push(r, a, l);
            }
          this.setIndex(d),
            this.setAttribute("position", new wi(p, 3)),
            this.setAttribute("normal", new wi(m, 3)),
            this.setAttribute("uv", new wi(f, 2));
        }
        static fromJSON(t) {
          return new Rl(
            t.radius,
            t.widthSegments,
            t.heightSegments,
            t.phiStart,
            t.phiLength,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Ll extends xo {
        constructor(t = 1, e = 0) {
          super(
            [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
            t,
            e
          ),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Ll(t.radius, t.detail);
        }
      }
      class Cl extends Ii {
        constructor(t = 1, e = 0.4, i = 8, n = 6, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              radialSegments: i,
              tubularSegments: n,
              arc: r,
            }),
            (i = Math.floor(i)),
            (n = Math.floor(n));
          const s = [],
            a = [],
            o = [],
            l = [],
            h = new Jt(),
            c = new Jt(),
            u = new Jt();
          for (let s = 0; s <= i; s++)
            for (let d = 0; d <= n; d++) {
              const p = (d / n) * r,
                m = (s / i) * Math.PI * 2;
              (c.x = (t + e * Math.cos(m)) * Math.cos(p)),
                (c.y = (t + e * Math.cos(m)) * Math.sin(p)),
                (c.z = e * Math.sin(m)),
                a.push(c.x, c.y, c.z),
                (h.x = t * Math.cos(p)),
                (h.y = t * Math.sin(p)),
                u.subVectors(c, h).normalize(),
                o.push(u.x, u.y, u.z),
                l.push(d / n),
                l.push(s / i);
            }
          for (let t = 1; t <= i; t++)
            for (let e = 1; e <= n; e++) {
              const i = (n + 1) * t + e - 1,
                r = (n + 1) * (t - 1) + e - 1,
                a = (n + 1) * (t - 1) + e,
                o = (n + 1) * t + e;
              s.push(i, r, o), s.push(r, a, o);
            }
          this.setIndex(s),
            this.setAttribute("position", new wi(a, 3)),
            this.setAttribute("normal", new wi(o, 3)),
            this.setAttribute("uv", new wi(l, 2));
        }
        static fromJSON(t) {
          return new Cl(
            t.radius,
            t.tube,
            t.radialSegments,
            t.tubularSegments,
            t.arc
          );
        }
      }
      class Pl extends Ii {
        constructor(t = 1, e = 0.4, i = 64, n = 8, r = 2, s = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              tubularSegments: i,
              radialSegments: n,
              p: r,
              q: s,
            }),
            (i = Math.floor(i)),
            (n = Math.floor(n));
          const a = [],
            o = [],
            l = [],
            h = [],
            c = new Jt(),
            u = new Jt(),
            d = new Jt(),
            p = new Jt(),
            m = new Jt(),
            f = new Jt(),
            g = new Jt();
          for (let a = 0; a <= i; ++a) {
            const x = (a / i) * r * Math.PI * 2;
            y(x, r, s, t, d),
              y(x + 0.01, r, s, t, p),
              f.subVectors(p, d),
              g.addVectors(p, d),
              m.crossVectors(f, g),
              g.crossVectors(m, f),
              m.normalize(),
              g.normalize();
            for (let t = 0; t <= n; ++t) {
              const r = (t / n) * Math.PI * 2,
                s = -e * Math.cos(r),
                p = e * Math.sin(r);
              (c.x = d.x + (s * g.x + p * m.x)),
                (c.y = d.y + (s * g.y + p * m.y)),
                (c.z = d.z + (s * g.z + p * m.z)),
                o.push(c.x, c.y, c.z),
                u.subVectors(c, d).normalize(),
                l.push(u.x, u.y, u.z),
                h.push(a / i),
                h.push(t / n);
            }
          }
          for (let t = 1; t <= i; t++)
            for (let e = 1; e <= n; e++) {
              const i = (n + 1) * (t - 1) + (e - 1),
                r = (n + 1) * t + (e - 1),
                s = (n + 1) * t + e,
                o = (n + 1) * (t - 1) + e;
              a.push(i, r, o), a.push(r, s, o);
            }
          function y(t, e, i, n, r) {
            const s = Math.cos(t),
              a = Math.sin(t),
              o = (i / e) * t,
              l = Math.cos(o);
            (r.x = n * (2 + l) * 0.5 * s),
              (r.y = n * (2 + l) * a * 0.5),
              (r.z = n * Math.sin(o) * 0.5);
          }
          this.setIndex(a),
            this.setAttribute("position", new wi(o, 3)),
            this.setAttribute("normal", new wi(l, 3)),
            this.setAttribute("uv", new wi(h, 2));
        }
        static fromJSON(t) {
          return new Pl(
            t.radius,
            t.tube,
            t.tubularSegments,
            t.radialSegments,
            t.p,
            t.q
          );
        }
      }
      class Il extends Ii {
        constructor(
          t = new Go(new Jt(-1, -1, 0), new Jt(-1, 1, 0), new Jt(1, 1, 0)),
          e = 64,
          i = 1,
          n = 8,
          r = !1
        ) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: t,
              tubularSegments: e,
              radius: i,
              radialSegments: n,
              closed: r,
            });
          const s = t.computeFrenetFrames(e, r);
          (this.tangents = s.tangents),
            (this.normals = s.normals),
            (this.binormals = s.binormals);
          const a = new Jt(),
            o = new Jt(),
            l = new Et();
          let h = new Jt();
          const c = [],
            u = [],
            d = [],
            p = [];
          function m(r) {
            h = t.getPointAt(r / e, h);
            const l = s.normals[r],
              d = s.binormals[r];
            for (let t = 0; t <= n; t++) {
              const e = (t / n) * Math.PI * 2,
                r = Math.sin(e),
                s = -Math.cos(e);
              (o.x = s * l.x + r * d.x),
                (o.y = s * l.y + r * d.y),
                (o.z = s * l.z + r * d.z),
                o.normalize(),
                u.push(o.x, o.y, o.z),
                (a.x = h.x + i * o.x),
                (a.y = h.y + i * o.y),
                (a.z = h.z + i * o.z),
                c.push(a.x, a.y, a.z);
            }
          }
          !(function () {
            for (let t = 0; t < e; t++) m(t);
            m(!1 === r ? e : 0),
              (function () {
                for (let t = 0; t <= e; t++)
                  for (let i = 0; i <= n; i++)
                    (l.x = t / e), (l.y = i / n), d.push(l.x, l.y);
              })(),
              (function () {
                for (let t = 1; t <= e; t++)
                  for (let e = 1; e <= n; e++) {
                    const i = (n + 1) * (t - 1) + (e - 1),
                      r = (n + 1) * t + (e - 1),
                      s = (n + 1) * t + e,
                      a = (n + 1) * (t - 1) + e;
                    p.push(i, r, a), p.push(r, s, a);
                  }
              })();
          })(),
            this.setIndex(p),
            this.setAttribute("position", new wi(c, 3)),
            this.setAttribute("normal", new wi(u, 3)),
            this.setAttribute("uv", new wi(d, 2));
        }
        toJSON() {
          const t = super.toJSON();
          return (t.path = this.parameters.path.toJSON()), t;
        }
        static fromJSON(t) {
          return new Il(
            new Wo[t.path.type]().fromJSON(t.path),
            t.tubularSegments,
            t.radius,
            t.radialSegments,
            t.closed
          );
        }
      }
      class zl extends Ii {
        constructor(t = null) {
          if (
            (super(),
            (this.type = "WireframeGeometry"),
            (this.parameters = { geometry: t }),
            null !== t)
          ) {
            const e = [],
              i = new Set(),
              n = new Jt(),
              r = new Jt();
            if (null !== t.index) {
              const s = t.attributes.position,
                a = t.index;
              let o = t.groups;
              0 === o.length &&
                (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
              for (let t = 0, l = o.length; t < l; ++t) {
                const l = o[t],
                  h = l.start;
                for (let t = h, o = h + l.count; t < o; t += 3)
                  for (let o = 0; o < 3; o++) {
                    const l = a.getX(t + o),
                      h = a.getX(t + ((o + 1) % 3));
                    n.fromBufferAttribute(s, l),
                      r.fromBufferAttribute(s, h),
                      !0 === Dl(n, r, i) &&
                        (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z));
                  }
              }
            } else {
              const s = t.attributes.position;
              for (let t = 0, a = s.count / 3; t < a; t++)
                for (let a = 0; a < 3; a++) {
                  const o = 3 * t + a,
                    l = 3 * t + ((a + 1) % 3);
                  n.fromBufferAttribute(s, o),
                    r.fromBufferAttribute(s, l),
                    !0 === Dl(n, r, i) &&
                      (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z));
                }
            }
            this.setAttribute("position", new wi(e, 3));
          }
        }
      }
      function Dl(t, e, i) {
        const n = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
          r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
        return !0 !== i.has(n) && !0 !== i.has(r) && (i.add(n, r), !0);
      }
      var Nl = Object.freeze({
        __proto__: null,
        BoxGeometry: Qi,
        BoxBufferGeometry: Qi,
        CircleGeometry: fo,
        CircleBufferGeometry: fo,
        ConeGeometry: yo,
        ConeBufferGeometry: yo,
        CylinderGeometry: go,
        CylinderBufferGeometry: go,
        DodecahedronGeometry: vo,
        DodecahedronBufferGeometry: vo,
        EdgesGeometry: So,
        ExtrudeGeometry: bl,
        ExtrudeBufferGeometry: bl,
        IcosahedronGeometry: wl,
        IcosahedronBufferGeometry: wl,
        LatheGeometry: Sl,
        LatheBufferGeometry: Sl,
        OctahedronGeometry: Tl,
        OctahedronBufferGeometry: Tl,
        PlaneGeometry: vn,
        PlaneBufferGeometry: vn,
        PolyhedronGeometry: xo,
        PolyhedronBufferGeometry: xo,
        RingGeometry: El,
        RingBufferGeometry: El,
        ShapeGeometry: Al,
        ShapeBufferGeometry: Al,
        SphereGeometry: Rl,
        SphereBufferGeometry: Rl,
        TetrahedronGeometry: Ll,
        TetrahedronBufferGeometry: Ll,
        TorusGeometry: Cl,
        TorusBufferGeometry: Cl,
        TorusKnotGeometry: Pl,
        TorusKnotBufferGeometry: Pl,
        TubeGeometry: Il,
        TubeBufferGeometry: Il,
        WireframeGeometry: zl,
      });
      class Ol extends ci {
        constructor(t) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new Ft(0)),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this;
        }
      }
      Ol.prototype.isShadowMaterial = !0;
      class Bl extends ci {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new Ft(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ft(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Et(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      Bl.prototype.isMeshStandardMaterial = !0;
      class Fl extends Bl {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Et(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return vt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.sheenColor = new Ft(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new Ft(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new Ft(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(t);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(t) {
          this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(t) {
          this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(t) {
          this._transmission > 0 != t > 0 && this.version++,
            (this._transmission = t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.ior = t.ior),
            (this.sheen = t.sheen),
            this.sheenColor.copy(t.sheenColor),
            (this.sheenColorMap = t.sheenColorMap),
            (this.sheenRoughness = t.sheenRoughness),
            (this.sheenRoughnessMap = t.sheenRoughnessMap),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationColor.copy(t.attenuationColor),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularColor.copy(t.specularColor),
            (this.specularColorMap = t.specularColorMap),
            this
          );
        }
      }
      Fl.prototype.isMeshPhysicalMaterial = !0;
      class Hl extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new Ft(16777215)),
            (this.specular = new Ft(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ft(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Et(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      Hl.prototype.isMeshPhongMaterial = !0;
      class Ul extends ci {
        constructor(t) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new Ft(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ft(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Et(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.gradientMap = t.gradientMap),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      Ul.prototype.isMeshToonMaterial = !0;
      class kl extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Et(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      kl.prototype.isMeshNormalMaterial = !0;
      class Gl extends ci {
        constructor(t) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new Ft(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ft(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      Gl.prototype.isMeshLambertMaterial = !0;
      class Vl extends ci {
        constructor(t) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new Ft(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Et(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { MATCAP: "" }),
            this.color.copy(t.color),
            (this.matcap = t.matcap),
            (this.map = t.map),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      Vl.prototype.isMeshMatcapMaterial = !0;
      class Wl extends qa {
        constructor(t) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          );
        }
      }
      Wl.prototype.isLineDashedMaterial = !0;
      var jl = Object.freeze({
        __proto__: null,
        ShadowMaterial: Ol,
        SpriteMaterial: ca,
        RawShaderMaterial: Cn,
        ShaderMaterial: nn,
        PointsMaterial: no,
        MeshPhysicalMaterial: Fl,
        MeshStandardMaterial: Bl,
        MeshPhongMaterial: Hl,
        MeshToonMaterial: Ul,
        MeshNormalMaterial: kl,
        MeshLambertMaterial: Gl,
        MeshDepthMaterial: Vs,
        MeshDistanceMaterial: Ws,
        MeshBasicMaterial: ui,
        MeshMatcapMaterial: Vl,
        LineDashedMaterial: Wl,
        LineBasicMaterial: qa,
        Material: ci,
      });
      const ql = {
        arraySlice: function (t, e, i) {
          return ql.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length))
            : t.slice(e, i);
        },
        convertArray: function (t, e, i) {
          return !t || (!i && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          const e = t.length,
            i = new Array(e);
          for (let t = 0; t !== e; ++t) i[t] = t;
          return (
            i.sort(function (e, i) {
              return t[e] - t[i];
            }),
            i
          );
        },
        sortedArray: function (t, e, i) {
          const n = t.length,
            r = new t.constructor(n);
          for (let s = 0, a = 0; a !== n; ++s) {
            const n = i[s] * e;
            for (let i = 0; i !== e; ++i) r[a++] = t[n + i];
          }
          return r;
        },
        flattenJSON: function (t, e, i, n) {
          let r = 1,
            s = t[0];
          for (; void 0 !== s && void 0 === s[n]; ) s = t[r++];
          if (void 0 === s) return;
          let a = s[n];
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                (a = s[n]),
                  void 0 !== a && (e.push(s.time), i.push.apply(i, a)),
                  (s = t[r++]);
              } while (void 0 !== s);
            else if (void 0 !== a.toArray)
              do {
                (a = s[n]),
                  void 0 !== a && (e.push(s.time), a.toArray(i, i.length)),
                  (s = t[r++]);
              } while (void 0 !== s);
            else
              do {
                (a = s[n]),
                  void 0 !== a && (e.push(s.time), i.push(a)),
                  (s = t[r++]);
              } while (void 0 !== s);
        },
        subclip: function (t, e, i, n, r = 30) {
          const s = t.clone();
          s.name = e;
          const a = [];
          for (let t = 0; t < s.tracks.length; ++t) {
            const e = s.tracks[t],
              o = e.getValueSize(),
              l = [],
              h = [];
            for (let t = 0; t < e.times.length; ++t) {
              const s = e.times[t] * r;
              if (!(s < i || s >= n)) {
                l.push(e.times[t]);
                for (let i = 0; i < o; ++i) h.push(e.values[t * o + i]);
              }
            }
            0 !== l.length &&
              ((e.times = ql.convertArray(l, e.times.constructor)),
              (e.values = ql.convertArray(h, e.values.constructor)),
              a.push(e));
          }
          s.tracks = a;
          let o = 1 / 0;
          for (let t = 0; t < s.tracks.length; ++t)
            o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
          for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
          return s.resetDuration(), s;
        },
        makeClipAdditive: function (t, e = 0, i = t, n = 30) {
          n <= 0 && (n = 30);
          const r = i.tracks.length,
            s = e / n;
          for (let e = 0; e < r; ++e) {
            const n = i.tracks[e],
              r = n.ValueTypeName;
            if ("bool" === r || "string" === r) continue;
            const a = t.tracks.find(function (t) {
              return t.name === n.name && t.ValueTypeName === r;
            });
            if (void 0 === a) continue;
            let o = 0;
            const l = n.getValueSize();
            n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (o = l / 3);
            let h = 0;
            const c = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = c / 3);
            const u = n.times.length - 1;
            let d;
            if (s <= n.times[0]) {
              const t = o,
                e = l - o;
              d = ql.arraySlice(n.values, t, e);
            } else if (s >= n.times[u]) {
              const t = u * l + o,
                e = t + l - o;
              d = ql.arraySlice(n.values, t, e);
            } else {
              const t = n.createInterpolant(),
                e = o,
                i = l - o;
              t.evaluate(s), (d = ql.arraySlice(t.resultBuffer, e, i));
            }
            "quaternion" === r &&
              new Yt().fromArray(d).normalize().conjugate().toArray(d);
            const p = a.times.length;
            for (let t = 0; t < p; ++t) {
              const e = t * c + h;
              if ("quaternion" === r)
                Yt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
              else {
                const t = c - 2 * h;
                for (let i = 0; i < t; ++i) a.values[e + i] -= d[i];
              }
            }
          }
          return (t.blendMode = st), t;
        },
      };
      class Xl {
        constructor(t, e, i, n) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
            (this.sampleValues = e),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(t) {
          const e = this.parameterPositions;
          let i = this._cachedIndex,
            n = e[i],
            r = e[i - 1];
          t: {
            e: {
              let s;
              i: {
                n: if (!(t < n)) {
                  for (let s = i + 2; ; ) {
                    if (void 0 === n) {
                      if (t < r) break n;
                      return (
                        (i = e.length),
                        (this._cachedIndex = i),
                        this.afterEnd_(i - 1, t, r)
                      );
                    }
                    if (i === s) break;
                    if (((r = n), (n = e[++i]), t < n)) break e;
                  }
                  s = e.length;
                  break i;
                }
                if (t >= r) break t;
                {
                  const a = e[1];
                  t < a && ((i = 2), (r = a));
                  for (let s = i - 2; ; ) {
                    if (void 0 === r)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, t, n)
                      );
                    if (i === s) break;
                    if (((n = r), (r = e[--i - 1]), t >= r)) break e;
                  }
                  (s = i), (i = 0);
                }
              }
              for (; i < s; ) {
                const n = (i + s) >>> 1;
                t < e[n] ? (s = n) : (i = n + 1);
              }
              if (((n = e[i]), (r = e[i - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
              if (void 0 === n)
                return (
                  (i = e.length),
                  (this._cachedIndex = i),
                  this.afterEnd_(i - 1, r, t)
                );
            }
            (this._cachedIndex = i), this.intervalChanged_(i, r, n);
          }
          return this.interpolate_(i, r, t, n);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            i = this.sampleValues,
            n = this.valueSize,
            r = t * n;
          for (let t = 0; t !== n; ++t) e[t] = i[r + t];
          return e;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      (Xl.prototype.beforeStart_ = Xl.prototype.copySampleValue_),
        (Xl.prototype.afterEnd_ = Xl.prototype.copySampleValue_);
      class Yl extends Xl {
        constructor(t, e, i, n) {
          super(t, e, i, n),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: it, endingEnd: it });
        }
        intervalChanged_(t, e, i) {
          const n = this.parameterPositions;
          let r = t - 2,
            s = t + 1,
            a = n[r],
            o = n[s];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case nt:
                (r = t), (a = 2 * e - i);
                break;
              case rt:
                (r = n.length - 2), (a = e + n[r] - n[r + 1]);
                break;
              default:
                (r = t), (a = i);
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case nt:
                (s = t), (o = 2 * i - e);
                break;
              case rt:
                (s = 1), (o = i + n[1] - n[0]);
                break;
              default:
                (s = t - 1), (o = e);
            }
          const l = 0.5 * (i - e),
            h = this.valueSize;
          (this._weightPrev = l / (e - a)),
            (this._weightNext = l / (o - i)),
            (this._offsetPrev = r * h),
            (this._offsetNext = s * h);
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            l = o - a,
            h = this._offsetPrev,
            c = this._offsetNext,
            u = this._weightPrev,
            d = this._weightNext,
            p = (i - e) / (n - e),
            m = p * p,
            f = m * p,
            g = -u * f + 2 * u * m - u * p,
            y = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
            x = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
            v = d * f - d * m;
          for (let t = 0; t !== a; ++t)
            r[t] = g * s[h + t] + y * s[l + t] + x * s[o + t] + v * s[c + t];
          return r;
        }
      }
      class Jl extends Xl {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            l = o - a,
            h = (i - e) / (n - e),
            c = 1 - h;
          for (let t = 0; t !== a; ++t) r[t] = s[l + t] * c + s[o + t] * h;
          return r;
        }
      }
      class Zl extends Xl {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      }
      class Kl {
        constructor(t, e, i, n) {
          if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e || 0 === e.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + t
            );
          (this.name = t),
            (this.times = ql.convertArray(e, this.TimeBufferType)),
            (this.values = ql.convertArray(i, this.ValueBufferType)),
            this.setInterpolation(n || this.DefaultInterpolation);
        }
        static toJSON(t) {
          const e = t.constructor;
          let i;
          if (e.toJSON !== this.toJSON) i = e.toJSON(t);
          else {
            i = {
              name: t.name,
              times: ql.convertArray(t.times, Array),
              values: ql.convertArray(t.values, Array),
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (i.interpolation = e);
          }
          return (i.type = t.ValueTypeName), i;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new Zl(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
          return new Jl(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
          return new Yl(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case $:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case tt:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case et:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            const e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return $;
            case this.InterpolantFactoryMethodLinear:
              return tt;
            case this.InterpolantFactoryMethodSmooth:
              return et;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
          }
          return this;
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
          }
          return this;
        }
        trim(t, e) {
          const i = this.times,
            n = i.length;
          let r = 0,
            s = n - 1;
          for (; r !== n && i[r] < t; ) ++r;
          for (; -1 !== s && i[s] > e; ) --s;
          if ((++s, 0 !== r || s !== n)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const t = this.getValueSize();
            (this.times = ql.arraySlice(i, r, s)),
              (this.values = ql.arraySlice(this.values, r * t, s * t));
          }
          return this;
        }
        validate() {
          let t = !0;
          const e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          const i = this.times,
            n = this.values,
            r = i.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let s = null;
          for (let e = 0; e !== r; e++) {
            const n = i[e];
            if ("number" == typeof n && isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                e,
                n
              ),
                (t = !1);
              break;
            }
            if (null !== s && s > n) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                e,
                n,
                s
              ),
                (t = !1);
              break;
            }
            s = n;
          }
          if (void 0 !== n && ql.isTypedArray(n))
            for (let e = 0, i = n.length; e !== i; ++e) {
              const i = n[e];
              if (isNaN(i)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  e,
                  i
                ),
                  (t = !1);
                break;
              }
            }
          return t;
        }
        optimize() {
          const t = ql.arraySlice(this.times),
            e = ql.arraySlice(this.values),
            i = this.getValueSize(),
            n = this.getInterpolation() === et,
            r = t.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
            let r = !1;
            const o = t[a];
            if (o !== t[a + 1] && (1 !== a || o !== t[0]))
              if (n) r = !0;
              else {
                const t = a * i,
                  n = t - i,
                  s = t + i;
                for (let a = 0; a !== i; ++a) {
                  const i = e[t + a];
                  if (i !== e[n + a] || i !== e[s + a]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (a !== s) {
                t[s] = t[a];
                const n = a * i,
                  r = s * i;
                for (let t = 0; t !== i; ++t) e[r + t] = e[n + t];
              }
              ++s;
            }
          }
          if (r > 0) {
            t[s] = t[r];
            for (let t = r * i, n = s * i, a = 0; a !== i; ++a)
              e[n + a] = e[t + a];
            ++s;
          }
          return (
            s !== t.length
              ? ((this.times = ql.arraySlice(t, 0, s)),
                (this.values = ql.arraySlice(e, 0, s * i)))
              : ((this.times = t), (this.values = e)),
            this
          );
        }
        clone() {
          const t = ql.arraySlice(this.times, 0),
            e = ql.arraySlice(this.values, 0),
            i = new (0, this.constructor)(this.name, t, e);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      (Kl.prototype.TimeBufferType = Float32Array),
        (Kl.prototype.ValueBufferType = Float32Array),
        (Kl.prototype.DefaultInterpolation = tt);
      class Ql extends Kl {}
      (Ql.prototype.ValueTypeName = "bool"),
        (Ql.prototype.ValueBufferType = Array),
        (Ql.prototype.DefaultInterpolation = $),
        (Ql.prototype.InterpolantFactoryMethodLinear = void 0),
        (Ql.prototype.InterpolantFactoryMethodSmooth = void 0);
      class $l extends Kl {}
      $l.prototype.ValueTypeName = "color";
      class th extends Kl {}
      th.prototype.ValueTypeName = "number";
      class eh extends Xl {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = (i - e) / (n - e);
          let l = t * a;
          for (let t = l + a; l !== t; l += 4)
            Yt.slerpFlat(r, 0, s, l - a, s, l, o);
          return r;
        }
      }
      class ih extends Kl {
        InterpolantFactoryMethodLinear(t) {
          return new eh(this.times, this.values, this.getValueSize(), t);
        }
      }
      (ih.prototype.ValueTypeName = "quaternion"),
        (ih.prototype.DefaultInterpolation = tt),
        (ih.prototype.InterpolantFactoryMethodSmooth = void 0);
      class nh extends Kl {}
      (nh.prototype.ValueTypeName = "string"),
        (nh.prototype.ValueBufferType = Array),
        (nh.prototype.DefaultInterpolation = $),
        (nh.prototype.InterpolantFactoryMethodLinear = void 0),
        (nh.prototype.InterpolantFactoryMethodSmooth = void 0);
      class rh extends Kl {}
      rh.prototype.ValueTypeName = "vector";
      class sh {
        constructor(t, e = -1, i, n = 2500) {
          (this.name = t),
            (this.tracks = i),
            (this.duration = e),
            (this.blendMode = n),
            (this.uuid = xt()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
          const e = [],
            i = t.tracks,
            n = 1 / (t.fps || 1);
          for (let t = 0, r = i.length; t !== r; ++t) e.push(ah(i[t]).scale(n));
          const r = new this(t.name, t.duration, e, t.blendMode);
          return (r.uuid = t.uuid), r;
        }
        static toJSON(t) {
          const e = [],
            i = t.tracks,
            n = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            };
          for (let t = 0, n = i.length; t !== n; ++t) e.push(Kl.toJSON(i[t]));
          return n;
        }
        static CreateFromMorphTargetSequence(t, e, i, n) {
          const r = e.length,
            s = [];
          for (let t = 0; t < r; t++) {
            let a = [],
              o = [];
            a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
            const l = ql.getKeyframeOrder(a);
            (a = ql.sortedArray(a, 1, l)),
              (o = ql.sortedArray(o, 1, l)),
              n || 0 !== a[0] || (a.push(r), o.push(o[0])),
              s.push(
                new th(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(
                  1 / i
                )
              );
          }
          return new this(t, -1, s);
        }
        static findByName(t, e) {
          let i = t;
          if (!Array.isArray(t)) {
            const e = t;
            i = (e.geometry && e.geometry.animations) || e.animations;
          }
          for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, i) {
          const n = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e],
              s = i.name.match(r);
            if (s && s.length > 1) {
              const t = s[1];
              let e = n[t];
              e || (n[t] = e = []), e.push(i);
            }
          }
          const s = [];
          for (const t in n)
            s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
          return s;
        }
        static parseAnimation(t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const i = function (t, e, i, n, r) {
              if (0 !== i.length) {
                const s = [],
                  a = [];
                ql.flattenJSON(i, s, a, n),
                  0 !== s.length && r.push(new t(e, s, a));
              }
            },
            n = [],
            r = t.name || "default",
            s = t.fps || 30,
            a = t.blendMode;
          let o = t.length || -1;
          const l = t.hierarchy || [];
          for (let t = 0; t < l.length; t++) {
            const r = l[t].keys;
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const t = {};
                let e;
                for (e = 0; e < r.length; e++)
                  if (r[e].morphTargets)
                    for (let i = 0; i < r[e].morphTargets.length; i++)
                      t[r[e].morphTargets[i]] = -1;
                for (const i in t) {
                  const t = [],
                    s = [];
                  for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                    const n = r[e];
                    t.push(n.time), s.push(n.morphTarget === i ? 1 : 0);
                  }
                  n.push(new th(".morphTargetInfluence[" + i + "]", t, s));
                }
                o = t.length * (s || 1);
              } else {
                const s = ".bones[" + e[t].name + "]";
                i(rh, s + ".position", r, "pos", n),
                  i(ih, s + ".quaternion", r, "rot", n),
                  i(rh, s + ".scale", r, "scl", n);
              }
          }
          return 0 === n.length ? null : new this(r, o, n, a);
        }
        resetDuration() {
          let t = 0;
          for (let e = 0, i = this.tracks.length; e !== i; ++e) {
            const i = this.tracks[e];
            t = Math.max(t, i.times[i.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        }
        validate() {
          let t = !0;
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        }
        clone() {
          const t = [];
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new this.constructor(
            this.name,
            this.duration,
            t,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function ah(t) {
        if (void 0 === t.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = (function (t) {
          switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return th;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return rh;
            case "color":
              return $l;
            case "quaternion":
              return ih;
            case "bool":
            case "boolean":
              return Ql;
            case "string":
              return nh;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
        })(t.type);
        if (void 0 === t.times) {
          const e = [],
            i = [];
          ql.flattenJSON(t.keys, e, i, "value"), (t.times = e), (t.values = i);
        }
        return void 0 !== e.parse
          ? e.parse(t)
          : new e(t.name, t.times, t.values, t.interpolation);
      }
      const oh = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e);
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t];
        },
        remove: function (t) {
          delete this.files[t];
        },
        clear: function () {
          this.files = {};
        },
      };
      class lh {
        constructor(t, e, i) {
          const n = this;
          let r,
            s = !1,
            a = 0,
            o = 0;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = i),
            (this.itemStart = function (t) {
              o++,
                !1 === s && void 0 !== n.onStart && n.onStart(t, a, o),
                (s = !0);
            }),
            (this.itemEnd = function (t) {
              a++,
                void 0 !== n.onProgress && n.onProgress(t, a, o),
                a === o && ((s = !1), void 0 !== n.onLoad && n.onLoad());
            }),
            (this.itemError = function (t) {
              void 0 !== n.onError && n.onError(t);
            }),
            (this.resolveURL = function (t) {
              return r ? r(t) : t;
            }),
            (this.setURLModifier = function (t) {
              return (r = t), this;
            }),
            (this.addHandler = function (t, e) {
              return l.push(t, e), this;
            }),
            (this.removeHandler = function (t) {
              const e = l.indexOf(t);
              return -1 !== e && l.splice(e, 2), this;
            }),
            (this.getHandler = function (t) {
              for (let e = 0, i = l.length; e < i; e += 2) {
                const i = l[e],
                  n = l[e + 1];
                if ((i.global && (i.lastIndex = 0), i.test(t))) return n;
              }
              return null;
            });
        }
      }
      const hh = new lh();
      class ch {
        constructor(t) {
          (this.manager = void 0 !== t ? t : hh),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(t, e) {
          const i = this;
          return new Promise(function (n, r) {
            i.load(t, n, e, r);
          });
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this;
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this;
        }
        setPath(t) {
          return (this.path = t), this;
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this;
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this;
        }
      }
      const uh = {};
      class dh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = oh.get(t);
          if (void 0 !== r)
            return (
              this.manager.itemStart(t),
              setTimeout(() => {
                e && e(r), this.manager.itemEnd(t);
              }, 0),
              r
            );
          if (void 0 !== uh[t])
            return void uh[t].push({ onLoad: e, onProgress: i, onError: n });
          (uh[t] = []), uh[t].push({ onLoad: e, onProgress: i, onError: n });
          const s = new Request(t, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            o = this.responseType;
          fetch(s)
            .then((e) => {
              if (200 === e.status || 0 === e.status) {
                if (
                  (0 === e.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" == typeof ReadableStream ||
                    void 0 === e.body.getReader)
                )
                  return e;
                const i = uh[t],
                  n = e.body.getReader(),
                  r = e.headers.get("Content-Length"),
                  s = r ? parseInt(r) : 0,
                  a = 0 !== s;
                let o = 0;
                const l = new ReadableStream({
                  start(t) {
                    !(function e() {
                      n.read().then(({ done: n, value: r }) => {
                        if (n) t.close();
                        else {
                          o += r.byteLength;
                          const n = new ProgressEvent("progress", {
                            lengthComputable: a,
                            loaded: o,
                            total: s,
                          });
                          for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t];
                            e.onProgress && e.onProgress(n);
                          }
                          t.enqueue(r), e();
                        }
                      });
                    })();
                  },
                });
                return new Response(l);
              }
              throw Error(
                `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
              );
            })
            .then((t) => {
              switch (o) {
                case "arraybuffer":
                  return t.arrayBuffer();
                case "blob":
                  return t.blob();
                case "document":
                  return t
                    .text()
                    .then((t) => new DOMParser().parseFromString(t, a));
                case "json":
                  return t.json();
                default:
                  if (void 0 === a) return t.text();
                  {
                    const e = /charset="?([^;"\s]*)"?/i.exec(a),
                      i = e && e[1] ? e[1].toLowerCase() : void 0,
                      n = new TextDecoder(i);
                    return t.arrayBuffer().then((t) => n.decode(t));
                  }
              }
            })
            .then((e) => {
              oh.add(t, e);
              const i = uh[t];
              delete uh[t];
              for (let t = 0, n = i.length; t < n; t++) {
                const n = i[t];
                n.onLoad && n.onLoad(e);
              }
            })
            .catch((e) => {
              const i = uh[t];
              if (void 0 === i) throw (this.manager.itemError(t), e);
              delete uh[t];
              for (let t = 0, n = i.length; t < n; t++) {
                const n = i[t];
                n.onError && n.onError(e);
              }
              this.manager.itemError(t);
            })
            .finally(() => {
              this.manager.itemEnd(t);
            }),
            this.manager.itemStart(t);
        }
        setResponseType(t) {
          return (this.responseType = t), this;
        }
        setMimeType(t) {
          return (this.mimeType = t), this;
        }
      }
      class ph extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            s = oh.get(t);
          if (void 0 !== s)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(s), r.manager.itemEnd(t);
              }, 0),
              s
            );
          const a = Pt("img");
          function o() {
            h(), oh.add(t, this), e && e(this), r.manager.itemEnd(t);
          }
          function l(e) {
            h(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }
          function h() {
            a.removeEventListener("load", o, !1),
              a.removeEventListener("error", l, !1);
          }
          return (
            a.addEventListener("load", o, !1),
            a.addEventListener("error", l, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (a.src = t),
            a
          );
        }
      }
      class mh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = new ln(),
            s = new ph(this.manager);
          s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
          let a = 0;
          function o(i) {
            s.load(
              t[i],
              function (t) {
                (r.images[i] = t),
                  a++,
                  6 === a && ((r.needsUpdate = !0), e && e(r));
              },
              void 0,
              n
            );
          }
          for (let e = 0; e < t.length; ++e) o(e);
          return r;
        }
      }
      class fh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = this,
            s = new Oa(),
            a = new dh(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(
              t,
              function (t) {
                const i = r.parse(t);
                i &&
                  (void 0 !== i.image
                    ? (s.image = i.image)
                    : void 0 !== i.data &&
                      ((s.image.width = i.width),
                      (s.image.height = i.height),
                      (s.image.data = i.data)),
                  (s.wrapS = void 0 !== i.wrapS ? i.wrapS : u),
                  (s.wrapT = void 0 !== i.wrapT ? i.wrapT : u),
                  (s.magFilter = void 0 !== i.magFilter ? i.magFilter : g),
                  (s.minFilter = void 0 !== i.minFilter ? i.minFilter : g),
                  (s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                  void 0 !== i.encoding && (s.encoding = i.encoding),
                  void 0 !== i.flipY && (s.flipY = i.flipY),
                  void 0 !== i.format && (s.format = i.format),
                  void 0 !== i.type && (s.type = i.type),
                  void 0 !== i.mipmaps &&
                    ((s.mipmaps = i.mipmaps), (s.minFilter = x)),
                  1 === i.mipmapCount && (s.minFilter = g),
                  void 0 !== i.generateMipmaps &&
                    (s.generateMipmaps = i.generateMipmaps),
                  (s.needsUpdate = !0),
                  e && e(s, i));
              },
              i,
              n
            ),
            s
          );
        }
      }
      class gh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = new Gt(),
            s = new ph(this.manager);
          return (
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(
              t,
              function (t) {
                (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
              },
              i,
              n
            ),
            r
          );
        }
      }
      class yh extends Ke {
        constructor(t, e = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new Ft(t)),
            (this.intensity = e);
        }
        dispose() {}
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        }
      }
      yh.prototype.isLight = !0;
      class xh extends yh {
        constructor(t, e, i) {
          super(t, i),
            (this.type = "HemisphereLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new Ft(e));
        }
        copy(t) {
          return (
            yh.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        }
      }
      xh.prototype.isHemisphereLight = !0;
      const vh = new Ee(),
        _h = new Jt(),
        bh = new Jt();
      class Mh {
        constructor(t) {
          (this.camera = t),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new Et(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Ee()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new gn()),
            (this._frameExtents = new Et(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Wt(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera,
            i = this.matrix;
          _h.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(_h),
            bh.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(bh),
            e.updateMatrixWorld(),
            vh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(vh),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(e.projectionMatrix),
            i.multiply(e.matrixWorldInverse);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      }
      class wh extends Mh {
        constructor() {
          super(new sn(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(t) {
          const e = this.camera,
            i = 2 * yt * t.angle * this.focus,
            n = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (i === e.fov && n === e.aspect && r === e.far) ||
            ((e.fov = i),
            (e.aspect = n),
            (e.far = r),
            e.updateProjectionMatrix()),
            super.updateMatrices(t);
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this;
        }
      }
      wh.prototype.isSpotLightShadow = !0;
      class Sh extends yh {
        constructor(t, e, i = 0, n = Math.PI / 3, r = 0, s = 1) {
          super(t, e),
            (this.type = "SpotLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ke()),
            (this.distance = i),
            (this.angle = n),
            (this.penumbra = r),
            (this.decay = s),
            (this.shadow = new wh());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      Sh.prototype.isSpotLight = !0;
      const Th = new Ee(),
        Eh = new Jt(),
        Ah = new Jt();
      class Rh extends Mh {
        constructor() {
          super(new sn(90, 1, 0.5, 500)),
            (this._frameExtents = new Et(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Wt(2, 1, 1, 1),
              new Wt(0, 1, 1, 1),
              new Wt(3, 1, 1, 1),
              new Wt(1, 1, 1, 1),
              new Wt(3, 0, 1, 1),
              new Wt(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new Jt(1, 0, 0),
              new Jt(-1, 0, 0),
              new Jt(0, 0, 1),
              new Jt(0, 0, -1),
              new Jt(0, 1, 0),
              new Jt(0, -1, 0),
            ]),
            (this._cubeUps = [
              new Jt(0, 1, 0),
              new Jt(0, 1, 0),
              new Jt(0, 1, 0),
              new Jt(0, 1, 0),
              new Jt(0, 0, 1),
              new Jt(0, 0, -1),
            ]);
        }
        updateMatrices(t, e = 0) {
          const i = this.camera,
            n = this.matrix,
            r = t.distance || i.far;
          r !== i.far && ((i.far = r), i.updateProjectionMatrix()),
            Eh.setFromMatrixPosition(t.matrixWorld),
            i.position.copy(Eh),
            Ah.copy(i.position),
            Ah.add(this._cubeDirections[e]),
            i.up.copy(this._cubeUps[e]),
            i.lookAt(Ah),
            i.updateMatrixWorld(),
            n.makeTranslation(-Eh.x, -Eh.y, -Eh.z),
            Th.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Th);
        }
      }
      Rh.prototype.isPointLightShadow = !0;
      class Lh extends yh {
        constructor(t, e, i = 0, n = 1) {
          super(t, e),
            (this.type = "PointLight"),
            (this.distance = i),
            (this.decay = n),
            (this.shadow = new Rh());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      Lh.prototype.isPointLight = !0;
      class Ch extends Mh {
        constructor() {
          super(new Ln(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Ch.prototype.isDirectionalLightShadow = !0;
      class Ph extends yh {
        constructor(t, e) {
          super(t, e),
            (this.type = "DirectionalLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ke()),
            (this.shadow = new Ch());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      Ph.prototype.isDirectionalLight = !0;
      class Ih extends yh {
        constructor(t, e) {
          super(t, e), (this.type = "AmbientLight");
        }
      }
      Ih.prototype.isAmbientLight = !0;
      class zh extends yh {
        constructor(t, e, i = 10, n = 10) {
          super(t, e),
            (this.type = "RectAreaLight"),
            (this.width = i),
            (this.height = n);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(t) {
          this.intensity = t / (this.width * this.height * Math.PI);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        }
      }
      zh.prototype.isRectAreaLight = !0;
      class Dh {
        constructor() {
          this.coefficients = [];
          for (let t = 0; t < 9; t++) this.coefficients.push(new Jt());
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        }
        getAt(t, e) {
          const i = t.x,
            n = t.y,
            r = t.z,
            s = this.coefficients;
          return (
            e.copy(s[0]).multiplyScalar(0.282095),
            e.addScaledVector(s[1], 0.488603 * n),
            e.addScaledVector(s[2], 0.488603 * r),
            e.addScaledVector(s[3], 0.488603 * i),
            e.addScaledVector(s[4], i * n * 1.092548),
            e.addScaledVector(s[5], n * r * 1.092548),
            e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
            e.addScaledVector(s[7], i * r * 1.092548),
            e.addScaledVector(s[8], 0.546274 * (i * i - n * n)),
            e
          );
        }
        getIrradianceAt(t, e) {
          const i = t.x,
            n = t.y,
            r = t.z,
            s = this.coefficients;
          return (
            e.copy(s[0]).multiplyScalar(0.886227),
            e.addScaledVector(s[1], 1.023328 * n),
            e.addScaledVector(s[2], 1.023328 * r),
            e.addScaledVector(s[3], 1.023328 * i),
            e.addScaledVector(s[4], 0.858086 * i * n),
            e.addScaledVector(s[5], 0.858086 * n * r),
            e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
            e.addScaledVector(s[7], 0.858086 * i * r),
            e.addScaledVector(s[8], 0.429043 * (i * i - n * n)),
            e
          );
        }
        add(t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        }
        addScaledSH(t, e) {
          for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(t.coefficients[i], e);
          return this;
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        }
        lerp(t, e) {
          for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(t.coefficients[i], e);
          return this;
        }
        equals(t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        }
        copy(t) {
          return this.set(t.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t, e = 0) {
          const i = this.coefficients;
          for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.coefficients;
          for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
          return t;
        }
        static getBasisAt(t, e) {
          const i = t.x,
            n = t.y,
            r = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * n),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * i),
            (e[4] = 1.092548 * i * n),
            (e[5] = 1.092548 * n * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * i * r),
            (e[8] = 0.546274 * (i * i - n * n));
        }
      }
      Dh.prototype.isSphericalHarmonics3 = !0;
      class Nh extends yh {
        constructor(t = new Dh(), e = 1) {
          super(void 0, e), (this.sh = t);
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this;
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (e.object.sh = this.sh.toArray()), e;
        }
      }
      Nh.prototype.isLightProbe = !0;
      class Oh extends ch {
        constructor(t) {
          super(t), (this.textures = {});
        }
        load(t, e, i, n) {
          const r = this,
            s = new dh(r.manager);
          s.setPath(r.path),
            s.setRequestHeader(r.requestHeader),
            s.setWithCredentials(r.withCredentials),
            s.load(
              t,
              function (i) {
                try {
                  e(r.parse(JSON.parse(i)));
                } catch (e) {
                  n ? n(e) : console.error(e), r.manager.itemError(t);
                }
              },
              i,
              n
            );
        }
        parse(t) {
          const e = this.textures;
          function i(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          const n = new jl[t.type]();
          if (
            (void 0 !== t.uuid && (n.uuid = t.uuid),
            void 0 !== t.name && (n.name = t.name),
            void 0 !== t.color && void 0 !== n.color && n.color.setHex(t.color),
            void 0 !== t.roughness && (n.roughness = t.roughness),
            void 0 !== t.metalness && (n.metalness = t.metalness),
            void 0 !== t.sheen && (n.sheen = t.sheen),
            void 0 !== t.sheenColor &&
              (n.sheenColor = new Ft().setHex(t.sheenColor)),
            void 0 !== t.sheenRoughness &&
              (n.sheenRoughness = t.sheenRoughness),
            void 0 !== t.emissive &&
              void 0 !== n.emissive &&
              n.emissive.setHex(t.emissive),
            void 0 !== t.specular &&
              void 0 !== n.specular &&
              n.specular.setHex(t.specular),
            void 0 !== t.specularIntensity &&
              (n.specularIntensity = t.specularIntensity),
            void 0 !== t.specularColor &&
              void 0 !== n.specularColor &&
              n.specularColor.setHex(t.specularColor),
            void 0 !== t.shininess && (n.shininess = t.shininess),
            void 0 !== t.clearcoat && (n.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (n.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.transmission && (n.transmission = t.transmission),
            void 0 !== t.thickness && (n.thickness = t.thickness),
            void 0 !== t.attenuationDistance &&
              (n.attenuationDistance = t.attenuationDistance),
            void 0 !== t.attenuationColor &&
              void 0 !== n.attenuationColor &&
              n.attenuationColor.setHex(t.attenuationColor),
            void 0 !== t.fog && (n.fog = t.fog),
            void 0 !== t.flatShading && (n.flatShading = t.flatShading),
            void 0 !== t.blending && (n.blending = t.blending),
            void 0 !== t.combine && (n.combine = t.combine),
            void 0 !== t.side && (n.side = t.side),
            void 0 !== t.shadowSide && (n.shadowSide = t.shadowSide),
            void 0 !== t.opacity && (n.opacity = t.opacity),
            void 0 !== t.transparent && (n.transparent = t.transparent),
            void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (n.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (n.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (n.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (n.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (n.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (n.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (n.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (n.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (n.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (n.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (n.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (n.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (n.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (n.rotation = t.rotation),
            1 !== t.linewidth && (n.linewidth = t.linewidth),
            void 0 !== t.dashSize && (n.dashSize = t.dashSize),
            void 0 !== t.gapSize && (n.gapSize = t.gapSize),
            void 0 !== t.scale && (n.scale = t.scale),
            void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (n.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (n.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.dithering && (n.dithering = t.dithering),
            void 0 !== t.alphaToCoverage &&
              (n.alphaToCoverage = t.alphaToCoverage),
            void 0 !== t.premultipliedAlpha &&
              (n.premultipliedAlpha = t.premultipliedAlpha),
            void 0 !== t.visible && (n.visible = t.visible),
            void 0 !== t.toneMapped && (n.toneMapped = t.toneMapped),
            void 0 !== t.userData && (n.userData = t.userData),
            void 0 !== t.vertexColors &&
              ("number" == typeof t.vertexColors
                ? (n.vertexColors = t.vertexColors > 0)
                : (n.vertexColors = t.vertexColors)),
            void 0 !== t.uniforms)
          )
            for (const e in t.uniforms) {
              const r = t.uniforms[e];
              switch (((n.uniforms[e] = {}), r.type)) {
                case "t":
                  n.uniforms[e].value = i(r.value);
                  break;
                case "c":
                  n.uniforms[e].value = new Ft().setHex(r.value);
                  break;
                case "v2":
                  n.uniforms[e].value = new Et().fromArray(r.value);
                  break;
                case "v3":
                  n.uniforms[e].value = new Jt().fromArray(r.value);
                  break;
                case "v4":
                  n.uniforms[e].value = new Wt().fromArray(r.value);
                  break;
                case "m3":
                  n.uniforms[e].value = new At().fromArray(r.value);
                  break;
                case "m4":
                  n.uniforms[e].value = new Ee().fromArray(r.value);
                  break;
                default:
                  n.uniforms[e].value = r.value;
              }
            }
          if (
            (void 0 !== t.defines && (n.defines = t.defines),
            void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (n.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (const e in t.extensions) n.extensions[e] = t.extensions[e];
          if (
            (void 0 !== t.shading && (n.flatShading = 1 === t.shading),
            void 0 !== t.size && (n.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (n.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (n.map = i(t.map)),
            void 0 !== t.matcap && (n.matcap = i(t.matcap)),
            void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap)),
            void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)),
            void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)),
            void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            let e = t.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]),
              (n.normalScale = new Et().fromArray(e));
          }
          return (
            void 0 !== t.displacementMap &&
              (n.displacementMap = i(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (n.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (n.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)),
            void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)),
            void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (n.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)),
            void 0 !== t.specularIntensityMap &&
              (n.specularIntensityMap = i(t.specularIntensityMap)),
            void 0 !== t.specularColorMap &&
              (n.specularColorMap = i(t.specularColorMap)),
            void 0 !== t.envMap && (n.envMap = i(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (n.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (n.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (n.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (n.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)),
            void 0 !== t.clearcoatMap && (n.clearcoatMap = i(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap &&
              (n.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap &&
              (n.clearcoatNormalMap = i(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (n.clearcoatNormalScale = new Et().fromArray(
                t.clearcoatNormalScale
              )),
            void 0 !== t.transmissionMap &&
              (n.transmissionMap = i(t.transmissionMap)),
            void 0 !== t.thicknessMap && (n.thicknessMap = i(t.thicknessMap)),
            void 0 !== t.sheenColorMap &&
              (n.sheenColorMap = i(t.sheenColorMap)),
            void 0 !== t.sheenRoughnessMap &&
              (n.sheenRoughnessMap = i(t.sheenRoughnessMap)),
            n
          );
        }
        setTextures(t) {
          return (this.textures = t), this;
        }
      }
      class Bh {
        static decodeText(t) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(t);
          let e = "";
          for (let i = 0, n = t.length; i < n; i++)
            e += String.fromCharCode(t[i]);
          try {
            return decodeURIComponent(escape(e));
          } catch (t) {
            return e;
          }
        }
        static extractUrlBase(t) {
          const e = t.lastIndexOf("/");
          return -1 === e ? "./" : t.substr(0, e + 1);
        }
        static resolveURL(t, e) {
          return "string" != typeof t || "" === t
            ? ""
            : (/^https?:\/\//i.test(e) &&
                /^\//.test(t) &&
                (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(t) ||
              /^data:.*,.*$/i.test(t) ||
              /^blob:.*$/i.test(t)
                ? t
                : e + t);
        }
      }
      class Fh extends Ii {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = super.toJSON(this);
          return (
            (t.instanceCount = this.instanceCount),
            (t.isInstancedBufferGeometry = !0),
            t
          );
        }
      }
      Fh.prototype.isInstancedBufferGeometry = !0;
      class Hh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = this,
            s = new dh(r.manager);
          s.setPath(r.path),
            s.setRequestHeader(r.requestHeader),
            s.setWithCredentials(r.withCredentials),
            s.load(
              t,
              function (i) {
                try {
                  e(r.parse(JSON.parse(i)));
                } catch (e) {
                  n ? n(e) : console.error(e), r.manager.itemError(t);
                }
              },
              i,
              n
            );
        }
        parse(t) {
          const e = {},
            i = {};
          function n(t, n) {
            if (void 0 !== e[n]) return e[n];
            const r = t.interleavedBuffers[n],
              s = (function (t, e) {
                if (void 0 !== i[e]) return i[e];
                const n = t.arrayBuffers[e],
                  r = new Uint32Array(n).buffer;
                return (i[e] = r), r;
              })(t, r.buffer),
              a = Ct(r.type, s),
              o = new oa(a, r.stride);
            return (o.uuid = r.uuid), (e[n] = o), o;
          }
          const r = t.isInstancedBufferGeometry ? new Fh() : new Ii(),
            s = t.data.index;
          if (void 0 !== s) {
            const t = Ct(s.type, s.array);
            r.setIndex(new mi(t, 1));
          }
          const a = t.data.attributes;
          for (const e in a) {
            const i = a[e];
            let s;
            if (i.isInterleavedBufferAttribute) {
              const e = n(t.data, i.data);
              s = new ha(e, i.itemSize, i.offset, i.normalized);
            } else {
              const t = Ct(i.type, i.array);
              s = new (i.isInstancedBufferAttribute ? Ua : mi)(
                t,
                i.itemSize,
                i.normalized
              );
            }
            void 0 !== i.name && (s.name = i.name),
              void 0 !== i.usage && s.setUsage(i.usage),
              void 0 !== i.updateRange &&
                ((s.updateRange.offset = i.updateRange.offset),
                (s.updateRange.count = i.updateRange.count)),
              r.setAttribute(e, s);
          }
          const o = t.data.morphAttributes;
          if (o)
            for (const e in o) {
              const i = o[e],
                s = [];
              for (let e = 0, r = i.length; e < r; e++) {
                const r = i[e];
                let a;
                if (r.isInterleavedBufferAttribute) {
                  const e = n(t.data, r.data);
                  a = new ha(e, r.itemSize, r.offset, r.normalized);
                } else {
                  const t = Ct(r.type, r.array);
                  a = new mi(t, r.itemSize, r.normalized);
                }
                void 0 !== r.name && (a.name = r.name), s.push(a);
              }
              r.morphAttributes[e] = s;
            }
          t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
          const l = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== l)
            for (let t = 0, e = l.length; t !== e; ++t) {
              const e = l[t];
              r.addGroup(e.start, e.count, e.materialIndex);
            }
          const h = t.data.boundingSphere;
          if (void 0 !== h) {
            const t = new Jt();
            void 0 !== h.center && t.fromArray(h.center),
              (r.boundingSphere = new ye(t, h.radius));
          }
          return (
            t.name && (r.name = t.name),
            t.userData && (r.userData = t.userData),
            r
          );
        }
      }
      const Uh = {
          UVMapping: n,
          CubeReflectionMapping: r,
          CubeRefractionMapping: s,
          EquirectangularReflectionMapping: a,
          EquirectangularRefractionMapping: o,
          CubeUVReflectionMapping: l,
          CubeUVRefractionMapping: h,
        },
        kh = {
          RepeatWrapping: c,
          ClampToEdgeWrapping: u,
          MirroredRepeatWrapping: d,
        },
        Gh = {
          NearestFilter: p,
          NearestMipmapNearestFilter: m,
          NearestMipmapLinearFilter: f,
          LinearFilter: g,
          LinearMipmapNearestFilter: y,
          LinearMipmapLinearFilter: x,
        };
      class Vh extends ch {
        constructor(t) {
          super(t),
            "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(t) {
          return (this.options = t), this;
        }
        load(t, e, i, n) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            s = oh.get(t);
          if (void 0 !== s)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(s), r.manager.itemEnd(t);
              }, 0),
              s
            );
          const a = {};
          (a.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(t, a)
              .then(function (t) {
                return t.blob();
              })
              .then(function (t) {
                return createImageBitmap(
                  t,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (i) {
                oh.add(t, i), e && e(i), r.manager.itemEnd(t);
              })
              .catch(function (e) {
                n && n(e), r.manager.itemError(t), r.manager.itemEnd(t);
              }),
            r.manager.itemStart(t);
        }
      }
      let Wh;
      Vh.prototype.isImageBitmapLoader = !0;
      const jh = {
        getContext: function () {
          return (
            void 0 === Wh &&
              (Wh = new (window.AudioContext || window.webkitAudioContext)()),
            Wh
          );
        },
        setContext: function (t) {
          Wh = t;
        },
      };
      class qh extends ch {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = this,
            s = new dh(this.manager);
          s.setResponseType("arraybuffer"),
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              t,
              function (i) {
                try {
                  const t = i.slice(0);
                  jh.getContext().decodeAudioData(t, function (t) {
                    e(t);
                  });
                } catch (e) {
                  n ? n(e) : console.error(e), r.manager.itemError(t);
                }
              },
              i,
              n
            );
        }
      }
      class Xh extends Nh {
        constructor(t, e, i = 1) {
          super(void 0, i);
          const n = new Ft().set(t),
            r = new Ft().set(e),
            s = new Jt(n.r, n.g, n.b),
            a = new Jt(r.r, r.g, r.b),
            o = Math.sqrt(Math.PI),
            l = o * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
            this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
        }
      }
      Xh.prototype.isHemisphereLightProbe = !0;
      class Yh extends Nh {
        constructor(t, e = 1) {
          super(void 0, e);
          const i = new Ft().set(t);
          this.sh.coefficients[0]
            .set(i.r, i.g, i.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Yh.prototype.isAmbientLightProbe = !0;
      const Jh = new Ee(),
        Zh = new Ee(),
        Kh = new Ee();
      class Qh {
        constructor(t = !0) {
          (this.autoStart = t),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = $h()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e = $h();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        }
      }
      function $h() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const tc = new Jt(),
        ec = new Yt(),
        ic = new Jt(),
        nc = new Jt();
      class rc extends Ke {
        constructor(t) {
          super(),
            (this.type = "Audio"),
            (this.listener = t),
            (this.context = t.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(t.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        }
        setMediaElementSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        }
        setBuffer(t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(t = 0) {
          if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + t;
          const e = this.context.createBufferSource();
          return (
            (e.buffer = this.buffer),
            (e.loop = this.loop),
            (e.loopStart = this.loopStart),
            (e.loopEnd = this.loopEnd),
            (e.onended = this.onEnded.bind(this)),
            e.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = e),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t) {
          return (
            t || (t = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = t.slice()), this.connect())
              : (this.filters = t.slice()),
            this
          );
        }
        setDetune(t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t) {
          return this.setFilters(t ? [t] : []);
        }
        setPlaybackRate(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t) {
          return (this.loopStart = t), this;
        }
        setLoopEnd(t) {
          return (this.loopEnd = t), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
      }
      const sc = new Jt(),
        ac = new Yt(),
        oc = new Jt(),
        lc = new Jt();
      class hc {
        constructor(t, e = 2048) {
          (this.analyser = t.context.createAnalyser()),
            (this.analyser.fftSize = e),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            t.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t = 0;
          const e = this.getFrequencyData();
          for (let i = 0; i < e.length; i++) t += e[i];
          return t / e.length;
        }
      }
      class cc {
        constructor(t, e, i) {
          let n, r, s;
          switch (((this.binding = t), (this.valueSize = i), e)) {
            case "quaternion":
              (n = this._slerp),
                (r = this._slerpAdditive),
                (s = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * i)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (n = this._select),
                (r = this._select),
                (s = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * i));
              break;
            default:
              (n = this._lerp),
                (r = this._lerpAdditive),
                (s = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * i));
          }
          (this._mixBufferRegion = n),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = s),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(t, e) {
          const i = this.buffer,
            n = this.valueSize,
            r = t * n + n;
          let s = this.cumulativeWeight;
          if (0 === s) {
            for (let t = 0; t !== n; ++t) i[r + t] = i[t];
            s = e;
          } else {
            s += e;
            const t = e / s;
            this._mixBufferRegion(i, r, 0, t, n);
          }
          this.cumulativeWeight = s;
        }
        accumulateAdditive(t) {
          const e = this.buffer,
            i = this.valueSize,
            n = i * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, n, 0, t, i),
            (this.cumulativeWeightAdditive += t);
        }
        apply(t) {
          const e = this.valueSize,
            i = this.buffer,
            n = t * e + e,
            r = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const t = e * this._origIndex;
            this._mixBufferRegion(i, n, t, 1 - r, e);
          }
          s > 0 &&
            this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
          for (let t = e, r = e + e; t !== r; ++t)
            if (i[t] !== i[t + e]) {
              a.setValue(i, n);
              break;
            }
        }
        saveOriginalState() {
          const t = this.binding,
            e = this.buffer,
            i = this.valueSize,
            n = i * this._origIndex;
          t.getValue(e, n);
          for (let t = i, r = n; t !== r; ++t) e[t] = e[n + (t % i)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
          for (let i = t; i < e; i++) this.buffer[i] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++)
            this.buffer[e + i] = this.buffer[t + i];
        }
        _select(t, e, i, n, r) {
          if (n >= 0.5) for (let n = 0; n !== r; ++n) t[e + n] = t[i + n];
        }
        _slerp(t, e, i, n) {
          Yt.slerpFlat(t, e, t, e, t, i, n);
        }
        _slerpAdditive(t, e, i, n, r) {
          const s = this._workIndex * r;
          Yt.multiplyQuaternionsFlat(t, s, t, e, t, i),
            Yt.slerpFlat(t, e, t, e, t, s, n);
        }
        _lerp(t, e, i, n, r) {
          const s = 1 - n;
          for (let a = 0; a !== r; ++a) {
            const r = e + a;
            t[r] = t[r] * s + t[i + a] * n;
          }
        }
        _lerpAdditive(t, e, i, n, r) {
          for (let s = 0; s !== r; ++s) {
            const r = e + s;
            t[r] = t[r] + t[i + s] * n;
          }
        }
      }
      const uc = new RegExp("[\\[\\]\\.:\\/]", "g"),
        dc = "[^\\[\\]\\.:\\/]",
        pc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        mc = /((?:WC+[\/:])*)/.source.replace("WC", dc),
        fc = /(WCOD+)?/.source.replace("WCOD", pc),
        gc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", dc),
        yc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", dc),
        xc = new RegExp("^" + mc + fc + gc + yc + "$"),
        vc = ["material", "materials", "bones"];
      class _c {
        constructor(t, e, i) {
          (this.path = e),
            (this.parsedPath = i || _c.parseTrackName(e)),
            (this.node = _c.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(t, e, i) {
          return t && t.isAnimationObjectGroup
            ? new _c.Composite(t, e, i)
            : new _c(t, e, i);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(uc, "");
        }
        static parseTrackName(t) {
          const e = xc.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const i = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (void 0 !== n && -1 !== n) {
            const t = i.nodeName.substring(n + 1);
            -1 !== vc.indexOf(t) &&
              ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = t));
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return i;
        }
        static findNode(t, e) {
          if (
            !e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            const i = t.skeleton.getBoneByName(e);
            if (void 0 !== i) return i;
          }
          if (t.children) {
            const i = function (t) {
                for (let n = 0; n < t.length; n++) {
                  const r = t[n];
                  if (r.name === e || r.uuid === e) return r;
                  const s = i(r.children);
                  if (s) return s;
                }
                return null;
              },
              n = i(t.children);
            if (n) return n;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node;
          const e = this.parsedPath,
            i = e.objectName,
            n = e.propertyName;
          let r = e.propertyIndex;
          if (
            (t ||
              ((t = _c.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
          if (i) {
            let n = e.objectIndex;
            switch (i) {
              case "materials":
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === n) {
                    n = e;
                    break;
                  }
                break;
              default:
                if (void 0 === t[i])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                t = t[i];
            }
            if (void 0 !== n) {
              if (void 0 === t[n])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
              t = t[n];
            }
          }
          const s = t[n];
          if (void 0 === s) {
            const i = e.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                i +
                "." +
                n +
                " but it wasn't found.",
              t
            );
          }
          let a = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === n) {
              if (!t.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!t.geometry.isBufferGeometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
              if (!t.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r]);
            }
            (o = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((o = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((o = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = n);
          (this.getValue = this.GetterByBindingType[o]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (_c.Composite = class {
        constructor(t, e, i) {
          const n = i || _c.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, n));
        }
        getValue(t, e) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_,
            n = this._bindings[i];
          void 0 !== n && n.getValue(t, e);
        }
        setValue(t, e) {
          const i = this._bindings;
          for (
            let n = this._targetGroup.nCachedObjects_, r = i.length;
            n !== r;
            ++n
          )
            i[n].setValue(t, e);
        }
        bind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, i = t.length;
            e !== i;
            ++e
          )
            t[e].bind();
        }
        unbind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, i = t.length;
            e !== i;
            ++e
          )
            t[e].unbind();
        }
      }),
        (_c.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (_c.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (_c.prototype.GetterByBindingType = [
          _c.prototype._getValue_direct,
          _c.prototype._getValue_array,
          _c.prototype._getValue_arrayElement,
          _c.prototype._getValue_toArray,
        ]),
        (_c.prototype.SetterByBindingTypeAndVersioning = [
          [
            _c.prototype._setValue_direct,
            _c.prototype._setValue_direct_setNeedsUpdate,
            _c.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            _c.prototype._setValue_array,
            _c.prototype._setValue_array_setNeedsUpdate,
            _c.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            _c.prototype._setValue_arrayElement,
            _c.prototype._setValue_arrayElement_setNeedsUpdate,
            _c.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            _c.prototype._setValue_fromArray,
            _c.prototype._setValue_fromArray_setNeedsUpdate,
            _c.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class bc {
        constructor() {
          (this.uuid = xt()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const t = {};
          this._indicesByUUID = t;
          for (let e = 0, i = arguments.length; e !== i; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const e = this;
          this.stats = {
            objects: {
              get total() {
                return e._objects.length;
              },
              get inUse() {
                return this.total - e.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return e._bindings.length;
            },
          };
        }
        add() {
          const t = this._objects,
            e = this._indicesByUUID,
            i = this._paths,
            n = this._parsedPaths,
            r = this._bindings,
            s = r.length;
          let a,
            o = t.length,
            l = this.nCachedObjects_;
          for (let h = 0, c = arguments.length; h !== c; ++h) {
            const c = arguments[h],
              u = c.uuid;
            let d = e[u];
            if (void 0 === d) {
              (d = o++), (e[u] = d), t.push(c);
              for (let t = 0, e = s; t !== e; ++t)
                r[t].push(new _c(c, i[t], n[t]));
            } else if (d < l) {
              a = t[d];
              const o = --l,
                h = t[o];
              (e[h.uuid] = d), (t[d] = h), (e[u] = o), (t[o] = c);
              for (let t = 0, e = s; t !== e; ++t) {
                const e = r[t],
                  s = e[o];
                let a = e[d];
                (e[d] = s),
                  void 0 === a && (a = new _c(c, i[t], n[t])),
                  (e[o] = a);
              }
            } else
              t[d] !== a &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = l;
        }
        remove() {
          const t = this._objects,
            e = this._indicesByUUID,
            i = this._bindings,
            n = i.length;
          let r = this.nCachedObjects_;
          for (let s = 0, a = arguments.length; s !== a; ++s) {
            const a = arguments[s],
              o = a.uuid,
              l = e[o];
            if (void 0 !== l && l >= r) {
              const s = r++,
                h = t[s];
              (e[h.uuid] = l), (t[l] = h), (e[o] = s), (t[s] = a);
              for (let t = 0, e = n; t !== e; ++t) {
                const e = i[t],
                  n = e[s],
                  r = e[l];
                (e[l] = n), (e[s] = r);
              }
            }
          }
          this.nCachedObjects_ = r;
        }
        uncache() {
          const t = this._objects,
            e = this._indicesByUUID,
            i = this._bindings,
            n = i.length;
          let r = this.nCachedObjects_,
            s = t.length;
          for (let a = 0, o = arguments.length; a !== o; ++a) {
            const o = arguments[a].uuid,
              l = e[o];
            if (void 0 !== l)
              if ((delete e[o], l < r)) {
                const a = --r,
                  o = t[a],
                  h = --s,
                  c = t[h];
                (e[o.uuid] = l),
                  (t[l] = o),
                  (e[c.uuid] = a),
                  (t[a] = c),
                  t.pop();
                for (let t = 0, e = n; t !== e; ++t) {
                  const e = i[t],
                    n = e[a],
                    r = e[h];
                  (e[l] = n), (e[a] = r), e.pop();
                }
              } else {
                const r = --s,
                  a = t[r];
                r > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();
                for (let t = 0, e = n; t !== e; ++t) {
                  const e = i[t];
                  (e[l] = e[r]), e.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        }
        subscribe_(t, e) {
          const i = this._bindingsIndicesByPath;
          let n = i[t];
          const r = this._bindings;
          if (void 0 !== n) return r[n];
          const s = this._paths,
            a = this._parsedPaths,
            o = this._objects,
            l = o.length,
            h = this.nCachedObjects_,
            c = new Array(l);
          (n = r.length), (i[t] = n), s.push(t), a.push(e), r.push(c);
          for (let i = h, n = o.length; i !== n; ++i) {
            const n = o[i];
            c[i] = new _c(n, t, e);
          }
          return c;
        }
        unsubscribe_(t) {
          const e = this._bindingsIndicesByPath,
            i = e[t];
          if (void 0 !== i) {
            const n = this._paths,
              r = this._parsedPaths,
              s = this._bindings,
              a = s.length - 1,
              o = s[a];
            (e[t[a]] = i),
              (s[i] = o),
              s.pop(),
              (r[i] = r[a]),
              r.pop(),
              (n[i] = n[a]),
              n.pop();
          }
        }
      }
      bc.prototype.isAnimationObjectGroup = !0;
      class Mc {
        constructor(t, e, i = null, n = e.blendMode) {
          (this._mixer = t),
            (this._clip = e),
            (this._localRoot = i),
            (this.blendMode = n);
          const r = e.tracks,
            s = r.length,
            a = new Array(s),
            o = { endingStart: it, endingEnd: it };
          for (let t = 0; t !== s; ++t) {
            const e = r[t].createInterpolant(null);
            (a[t] = e), (e.settings = o);
          }
          (this._interpolantSettings = o),
            (this._interpolants = a),
            (this._propertyBindings = new Array(s)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = 2201),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t) {
          return (this._startTime = t), this;
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        }
        setEffectiveWeight(t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, i) {
          if ((t.fadeOut(e), this.fadeIn(e), i)) {
            const i = this._clip.duration,
              n = t._clip.duration,
              r = n / i,
              s = i / n;
            t.warp(1, r, e), this.warp(s, 1, e);
          }
          return this;
        }
        crossFadeTo(t, e, i) {
          return t.crossFadeFrom(this, e, i);
        }
        stopFading() {
          const t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        setEffectiveTimeScale(t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        }
        syncWith(t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, i) {
          const n = this._mixer,
            r = n.time,
            s = this.timeScale;
          let a = this._timeScaleInterpolant;
          null === a &&
            ((a = n._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const o = a.parameterPositions,
            l = a.sampleValues;
          return (
            (o[0] = r), (o[1] = r + i), (l[0] = t / s), (l[1] = e / s), this
          );
        }
        stopWarping() {
          const t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t, e, i, n) {
          if (!this.enabled) return void this._updateWeight(t);
          const r = this._startTime;
          if (null !== r) {
            const n = (t - r) * i;
            if (n < 0 || 0 === i) return;
            (this._startTime = null), (e = i * n);
          }
          e *= this._updateTimeScale(t);
          const s = this._updateTime(e),
            a = this._updateWeight(t);
          if (a > 0) {
            const t = this._interpolants,
              e = this._propertyBindings;
            if (this.blendMode === st)
              for (let i = 0, n = t.length; i !== n; ++i)
                t[i].evaluate(s), e[i].accumulateAdditive(a);
            else
              for (let i = 0, r = t.length; i !== r; ++i)
                t[i].evaluate(s), e[i].accumulate(n, a);
          }
        }
        _updateWeight(t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            const i = this._weightInterpolant;
            if (null !== i) {
              const n = i.evaluate(t)[0];
              (e *= n),
                t > i.parameterPositions[1] &&
                  (this.stopFading(), 0 === n && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        }
        _updateTimeScale(t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            const i = this._timeScaleInterpolant;
            null !== i &&
              ((e *= i.evaluate(t)[0]),
              t > i.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e)));
          }
          return (this._effectiveTimeScale = e), e;
        }
        _updateTime(t) {
          const e = this._clip.duration,
            i = this.loop;
          let n = this.time + t,
            r = this._loopCount;
          const s = 2202 === i;
          if (0 === t) return -1 === r ? n : s && 1 == (1 & r) ? e - n : n;
          if (2200 === i) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (n >= e) n = e;
              else {
                if (!(n < 0)) {
                  this.time = n;
                  break t;
                }
                n = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = n),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                  : this._setEndings(0 === this.repetitions, !0, s)),
              n >= e || n < 0)
            ) {
              const i = Math.floor(n / e);
              (n -= e * i), (r += Math.abs(i));
              const a = this.repetitions - r;
              if (a <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (n = t > 0 ? e : 0),
                  (this.time = n),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === a) {
                  const e = t < 0;
                  this._setEndings(e, !e, s);
                } else this._setEndings(!1, !1, s);
                (this._loopCount = r),
                  (this.time = n),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: i,
                  });
              }
            } else this.time = n;
            if (s && 1 == (1 & r)) return e - n;
          }
          return n;
        }
        _setEndings(t, e, i) {
          const n = this._interpolantSettings;
          i
            ? ((n.endingStart = nt), (n.endingEnd = nt))
            : ((n.endingStart = t ? (this.zeroSlopeAtStart ? nt : it) : rt),
              (n.endingEnd = e ? (this.zeroSlopeAtEnd ? nt : it) : rt));
        }
        _scheduleFading(t, e, i) {
          const n = this._mixer,
            r = n.time;
          let s = this._weightInterpolant;
          null === s &&
            ((s = n._lendControlInterpolant()), (this._weightInterpolant = s));
          const a = s.parameterPositions,
            o = s.sampleValues;
          return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = i), this;
        }
      }
      class wc extends pt {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(t, e) {
          const i = t._localRoot || this._root,
            n = t._clip.tracks,
            r = n.length,
            s = t._propertyBindings,
            a = t._interpolants,
            o = i.uuid,
            l = this._bindingsByRootAndName;
          let h = l[o];
          void 0 === h && ((h = {}), (l[o] = h));
          for (let t = 0; t !== r; ++t) {
            const r = n[t],
              l = r.name;
            let c = h[l];
            if (void 0 !== c) ++c.referenceCount, (s[t] = c);
            else {
              if (((c = s[t]), void 0 !== c)) {
                null === c._cacheIndex &&
                  (++c.referenceCount, this._addInactiveBinding(c, o, l));
                continue;
              }
              const n = e && e._propertyBindings[t].binding.parsedPath;
              (c = new cc(
                _c.create(i, l, n),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++c.referenceCount,
                this._addInactiveBinding(c, o, l),
                (s[t] = c);
            }
            a[t].resultBuffer = c.buffer;
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                i = t._clip.uuid,
                n = this._actionsByClip[i];
              this._bindAction(t, n && n.knownActions[0]),
                this._addInactiveAction(t, i, e);
            }
            const e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
              const i = e[t];
              0 == i.useCount++ &&
                (this._lendBinding(i), i.saveOriginalState());
            }
            this._lendAction(t);
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
              const i = e[t];
              0 == --i.useCount &&
                (i.restoreOriginalState(), this._takeBackBinding(i));
            }
            this._takeBackAction(t);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(t) {
          const e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, i) {
          const n = this._actions,
            r = this._actionsByClip;
          let s = r[e];
          if (void 0 === s)
            (s = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = s);
          else {
            const e = s.knownActions;
            (t._byClipCacheIndex = e.length), e.push(t);
          }
          (t._cacheIndex = n.length), n.push(t), (s.actionByRoot[i] = t);
        }
        _removeInactiveAction(t) {
          const e = this._actions,
            i = e[e.length - 1],
            n = t._cacheIndex;
          (i._cacheIndex = n), (e[n] = i), e.pop(), (t._cacheIndex = null);
          const r = t._clip.uuid,
            s = this._actionsByClip,
            a = s[r],
            o = a.knownActions,
            l = o[o.length - 1],
            h = t._byClipCacheIndex;
          (l._byClipCacheIndex = h),
            (o[h] = l),
            o.pop(),
            (t._byClipCacheIndex = null),
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
            this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == --i.referenceCount && this._removeInactiveBinding(i);
          }
        }
        _lendAction(t) {
          const e = this._actions,
            i = t._cacheIndex,
            n = this._nActiveActions++,
            r = e[n];
          (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
        }
        _takeBackAction(t) {
          const e = this._actions,
            i = t._cacheIndex,
            n = --this._nActiveActions,
            r = e[n];
          (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
        }
        _addInactiveBinding(t, e, i) {
          const n = this._bindingsByRootAndName,
            r = this._bindings;
          let s = n[e];
          void 0 === s && ((s = {}), (n[e] = s)),
            (s[i] = t),
            (t._cacheIndex = r.length),
            r.push(t);
        }
        _removeInactiveBinding(t) {
          const e = this._bindings,
            i = t.binding,
            n = i.rootNode.uuid,
            r = i.path,
            s = this._bindingsByRootAndName,
            a = s[n],
            o = e[e.length - 1],
            l = t._cacheIndex;
          (o._cacheIndex = l),
            (e[l] = o),
            e.pop(),
            delete a[r],
            0 === Object.keys(a).length && delete s[n];
        }
        _lendBinding(t) {
          const e = this._bindings,
            i = t._cacheIndex,
            n = this._nActiveBindings++,
            r = e[n];
          (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
        }
        _takeBackBinding(t) {
          const e = this._bindings,
            i = t._cacheIndex,
            n = --this._nActiveBindings,
            r = e[n];
          (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++;
          let i = t[e];
          return (
            void 0 === i &&
              ((i = new Jl(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (i.__cacheIndex = e),
              (t[e] = i)),
            i
          );
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants,
            i = t.__cacheIndex,
            n = --this._nActiveControlInterpolants,
            r = e[n];
          (t.__cacheIndex = n), (e[n] = t), (r.__cacheIndex = i), (e[i] = r);
        }
        clipAction(t, e, i) {
          const n = e || this._root,
            r = n.uuid;
          let s = "string" == typeof t ? sh.findByName(n, t) : t;
          const a = null !== s ? s.uuid : t,
            o = this._actionsByClip[a];
          let l = null;
          if (
            (void 0 === i && (i = null !== s ? s.blendMode : 2500),
            void 0 !== o)
          ) {
            const t = o.actionByRoot[r];
            if (void 0 !== t && t.blendMode === i) return t;
            (l = o.knownActions[0]), null === s && (s = l._clip);
          }
          if (null === s) return null;
          const h = new Mc(this, s, e, i);
          return this._bindAction(h, l), this._addInactiveAction(h, a, r), h;
        }
        existingAction(t, e) {
          const i = e || this._root,
            n = i.uuid,
            r = "string" == typeof t ? sh.findByName(i, t) : t,
            s = r ? r.uuid : t,
            a = this._actionsByClip[s];
          return (void 0 !== a && a.actionByRoot[n]) || null;
        }
        stopAllAction() {
          const t = this._actions;
          for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
          return this;
        }
        update(t) {
          t *= this.timeScale;
          const e = this._actions,
            i = this._nActiveActions,
            n = (this.time += t),
            r = Math.sign(t),
            s = (this._accuIndex ^= 1);
          for (let a = 0; a !== i; ++a) e[a]._update(n, t, r, s);
          const a = this._bindings,
            o = this._nActiveBindings;
          for (let t = 0; t !== o; ++t) a[t].apply(s);
          return this;
        }
        setTime(t) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(t);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t) {
          const e = this._actions,
            i = t.uuid,
            n = this._actionsByClip,
            r = n[i];
          if (void 0 !== r) {
            const t = r.knownActions;
            for (let i = 0, n = t.length; i !== n; ++i) {
              const n = t[i];
              this._deactivateAction(n);
              const r = n._cacheIndex,
                s = e[e.length - 1];
              (n._cacheIndex = null),
                (n._byClipCacheIndex = null),
                (s._cacheIndex = r),
                (e[r] = s),
                e.pop(),
                this._removeInactiveBindingsForAction(n);
            }
            delete n[i];
          }
        }
        uncacheRoot(t) {
          const e = t.uuid,
            i = this._actionsByClip;
          for (const t in i) {
            const n = i[t].actionByRoot[e];
            void 0 !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          }
          const n = this._bindingsByRootAndName[e];
          if (void 0 !== n)
            for (const t in n) {
              const e = n[t];
              e.restoreOriginalState(), this._removeInactiveBinding(e);
            }
        }
        uncacheAction(t, e) {
          const i = this.existingAction(t, e);
          null !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
      }
      wc.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Sc {
        constructor(t) {
          "string" == typeof t &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (t = arguments[1])),
            (this.value = t);
        }
        clone() {
          return new Sc(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      class Tc extends oa {
        constructor(t, e, i = 1) {
          super(t, e), (this.meshPerAttribute = i);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        clone(t) {
          const e = super.clone(t);
          return (e.meshPerAttribute = this.meshPerAttribute), e;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          );
        }
      }
      Tc.prototype.isInstancedInterleavedBuffer = !0;
      class Ec {
        constructor(t, e, i, n, r) {
          (this.buffer = t),
            (this.type = e),
            (this.itemSize = i),
            (this.elementSize = n),
            (this.count = r),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setBuffer(t) {
          return (this.buffer = t), this;
        }
        setType(t, e) {
          return (this.type = t), (this.elementSize = e), this;
        }
        setItemSize(t) {
          return (this.itemSize = t), this;
        }
        setCount(t) {
          return (this.count = t), this;
        }
      }
      function Ac(t, e) {
        return t.distance - e.distance;
      }
      function Rc(t, e, i, n) {
        if ((t.layers.test(e.layers) && t.raycast(e, i), !0 === n)) {
          const n = t.children;
          for (let t = 0, r = n.length; t < r; t++) Rc(n[t], e, i, !0);
        }
      }
      Ec.prototype.isGLBufferAttribute = !0;
      const Lc = new Et();
      class Cc {
        constructor(t = new Et(1 / 0, 1 / 0), e = new Et(-1 / 0, -1 / 0)) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const i = Lc.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return Lc.copy(t).clamp(this.min, this.max).sub(t).length();
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      Cc.prototype.isBox2 = !0;
      const Pc = new Jt(),
        Ic = new Jt();
      class zc {
        constructor(t = new Jt(), e = new Jt()) {
          (this.start = t), (this.end = e);
        }
        set(t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        }
        copy(t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        }
        getCenter(t) {
          return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t) {
          return t.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, e) {
          return this.delta(e).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(t, e) {
          Pc.subVectors(t, this.start), Ic.subVectors(this.end, this.start);
          const i = Ic.dot(Ic);
          let n = Ic.dot(Pc) / i;
          return e && (n = vt(n, 0, 1)), n;
        }
        closestPointToPoint(t, e, i) {
          const n = this.closestPointToPointParameter(t, e);
          return this.delta(i).multiplyScalar(n).add(this.start);
        }
        applyMatrix4(t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        }
        equals(t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Dc = new Jt(),
        Nc = new Jt(),
        Oc = new Ee(),
        Bc = new Ee();
      class Fc extends eo {
        constructor(t) {
          const e = Hc(t),
            i = new Ii(),
            n = [],
            r = [],
            s = new Ft(0, 0, 1),
            a = new Ft(0, 1, 0);
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.parent &&
              i.parent.isBone &&
              (n.push(0, 0, 0),
              n.push(0, 0, 0),
              r.push(s.r, s.g, s.b),
              r.push(a.r, a.g, a.b));
          }
          i.setAttribute("position", new wi(n, 3)),
            i.setAttribute("color", new wi(r, 3)),
            super(
              i,
              new qa({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              })
            ),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(t) {
          const e = this.bones,
            i = this.geometry,
            n = i.getAttribute("position");
          Bc.copy(this.root.matrixWorld).invert();
          for (let t = 0, i = 0; t < e.length; t++) {
            const r = e[t];
            r.parent &&
              r.parent.isBone &&
              (Oc.multiplyMatrices(Bc, r.matrixWorld),
              Nc.setFromMatrixPosition(Oc),
              n.setXYZ(i, Nc.x, Nc.y, Nc.z),
              Oc.multiplyMatrices(Bc, r.parent.matrixWorld),
              Nc.setFromMatrixPosition(Oc),
              n.setXYZ(i + 1, Nc.x, Nc.y, Nc.z),
              (i += 2));
          }
          (i.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(t);
        }
      }
      function Hc(t) {
        const e = [];
        t && t.isBone && e.push(t);
        for (let i = 0; i < t.children.length; i++)
          e.push.apply(e, Hc(t.children[i]));
        return e;
      }
      const Uc = new Jt(),
        kc = new Ft(),
        Gc = new Ft();
      class Vc extends eo {
        constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
          (i = new Ft(i)), (n = new Ft(n));
          const r = e / 2,
            s = t / e,
            a = t / 2,
            o = [],
            l = [];
          for (let t = 0, h = 0, c = -a; t <= e; t++, c += s) {
            o.push(-a, 0, c, a, 0, c), o.push(c, 0, -a, c, 0, a);
            const e = t === r ? i : n;
            e.toArray(l, h),
              (h += 3),
              e.toArray(l, h),
              (h += 3),
              e.toArray(l, h),
              (h += 3),
              e.toArray(l, h),
              (h += 3);
          }
          const h = new Ii();
          h.setAttribute("position", new wi(o, 3)),
            h.setAttribute("color", new wi(l, 3)),
            super(h, new qa({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "GridHelper");
        }
      }
      const Wc = new Jt(),
        jc = new Jt(),
        qc = new Jt(),
        Xc = new Jt(),
        Yc = new rn();
      function Jc(t, e, i, n, r, s, a) {
        Xc.set(r, s, a).unproject(n);
        const o = e[t];
        if (void 0 !== o) {
          const t = i.getAttribute("position");
          for (let e = 0, i = o.length; e < i; e++)
            t.setXYZ(o[e], Xc.x, Xc.y, Xc.z);
        }
      }
      const Zc = new Qt();
      class Kc extends eo {
        constructor(t, e = 16776960) {
          const i = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            n = new Float32Array(24),
            r = new Ii();
          r.setIndex(new mi(i, 1)),
            r.setAttribute("position", new mi(n, 3)),
            super(r, new qa({ color: e, toneMapped: !1 })),
            (this.object = t),
            (this.type = "BoxHelper"),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        update(t) {
          if (
            (void 0 !== t &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            void 0 !== this.object && Zc.setFromObject(this.object),
            Zc.isEmpty())
          )
            return;
          const e = Zc.min,
            i = Zc.max,
            n = this.geometry.attributes.position,
            r = n.array;
          (r[0] = i.x),
            (r[1] = i.y),
            (r[2] = i.z),
            (r[3] = e.x),
            (r[4] = i.y),
            (r[5] = i.z),
            (r[6] = e.x),
            (r[7] = e.y),
            (r[8] = i.z),
            (r[9] = i.x),
            (r[10] = e.y),
            (r[11] = i.z),
            (r[12] = i.x),
            (r[13] = i.y),
            (r[14] = e.z),
            (r[15] = e.x),
            (r[16] = i.y),
            (r[17] = e.z),
            (r[18] = e.x),
            (r[19] = e.y),
            (r[20] = e.z),
            (r[21] = i.x),
            (r[22] = e.y),
            (r[23] = e.z),
            (n.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
        setFromObject(t) {
          return (this.object = t), this.update(), this;
        }
        copy(t) {
          return (
            eo.prototype.copy.call(this, t), (this.object = t.object), this
          );
        }
      }
      const Qc = new Jt();
      let $c, tu;
      class eu extends eo {
        constructor(t = 1) {
          const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            i = new Ii();
          i.setAttribute("position", new wi(e, 3)),
            i.setAttribute(
              "color",
              new wi(
                [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                3
              )
            ),
            super(i, new qa({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "AxesHelper");
        }
        setColors(t, e, i) {
          const n = new Ft(),
            r = this.geometry.attributes.color.array;
          return (
            n.set(t),
            n.toArray(r, 0),
            n.toArray(r, 3),
            n.set(e),
            n.toArray(r, 6),
            n.toArray(r, 9),
            n.set(i),
            n.toArray(r, 12),
            n.toArray(r, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      const iu = new Float32Array(1),
        nu = new Int32Array(iu.buffer);
      (To.create = function (t, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (t.prototype = Object.create(To.prototype)),
          (t.prototype.constructor = t),
          (t.prototype.getPoint = e),
          t
        );
      }),
        (qo.prototype.fromPoints = function (t) {
          return (
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
            this.setFromPoints(t)
          );
        }),
        (Vc.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (Fc.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        (ch.prototype.extractUrlBase = function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            Bh.extractUrlBase(t)
          );
        }),
        (ch.Handlers = {
          add: function () {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function () {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          },
        }),
        (Cc.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (Cc.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (Cc.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (Cc.prototype.size = function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (Qt.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (Qt.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (Qt.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (Qt.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (Qt.prototype.size = function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (ye.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Sphere: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (gn.prototype.setFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
            ),
            this.setFromProjectionMatrix(t)
          );
        }),
        (zc.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (At.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (At.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (At.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        }),
        (At.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (At.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        }),
        (At.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (Ee.prototype.extractPosition = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        }),
        (Ee.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (Ee.prototype.getPosition = function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new Jt().setFromMatrixColumn(this, 3)
          );
        }),
        (Ee.prototype.setRotationFromQuaternion = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        }),
        (Ee.prototype.multiplyToArray = function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        }),
        (Ee.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Ee.prototype.multiplyVector4 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Ee.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        }),
        (Ee.prototype.rotateAxis = function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        }),
        (Ee.prototype.crossVector = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Ee.prototype.translate = function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        }),
        (Ee.prototype.rotateX = function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        }),
        (Ee.prototype.rotateY = function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        }),
        (Ee.prototype.rotateZ = function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        }),
        (Ee.prototype.rotateByAxis = function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        }),
        (Ee.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Ee.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        }),
        (Ee.prototype.makeFrustum = function (t, e, i, n, r, s) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, n, i, r, s)
          );
        }),
        (Ee.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (pn.prototype.isIntersectionLine = function (t) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(t)
          );
        }),
        (Yt.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            ),
            t.applyQuaternion(this)
          );
        }),
        (Yt.prototype.inverse = function () {
          return (
            console.warn(
              "THREE.Quaternion: .inverse() has been renamed to invert()."
            ),
            this.invert()
          );
        }),
        (Te.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (Te.prototype.isIntersectionPlane = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        }),
        (Te.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (li.prototype.area = function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        }),
        (li.prototype.barycoordFromPoint = function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        }),
        (li.prototype.midpoint = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        }),
        (li.prototypenormal = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        }),
        (li.prototype.plane = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        }),
        (li.barycoordFromPoint = function (t, e, i, n, r) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            li.getBarycoord(t, e, i, n, r)
          );
        }),
        (li.normal = function (t, e, i, n) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            li.getNormal(t, e, i, n)
          );
        }),
        (Xo.prototype.extractAllPoints = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        }),
        (Xo.prototype.extrude = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new bl(this, t)
          );
        }),
        (Xo.prototype.makeGeometry = function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new Al(this, t)
          );
        }),
        (Et.prototype.fromAttribute = function (t, e, i) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, i)
          );
        }),
        (Et.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        (Et.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (Jt.prototype.setEulerFromRotationMatrix = function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        }),
        (Jt.prototype.setEulerFromQuaternion = function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        }),
        (Jt.prototype.getPositionFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        }),
        (Jt.prototype.getScaleFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        }),
        (Jt.prototype.getColumnFromMatrix = function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        }),
        (Jt.prototype.applyProjection = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        }),
        (Jt.prototype.fromAttribute = function (t, e, i) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, i)
          );
        }),
        (Jt.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        (Jt.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (Wt.prototype.fromAttribute = function (t, e, i) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, i)
          );
        }),
        (Wt.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (Ke.prototype.getChildByName = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        }),
        (Ke.prototype.renderDepth = function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        }),
        (Ke.prototype.translate = function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        }),
        (Ke.prototype.getWorldRotation = function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        }),
        (Ke.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties(Ke.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (t) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = t);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        (Zi.prototype.setDrawMode = function () {
          console.error(
            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        }),
        Object.defineProperties(Zi.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                0
              );
            },
            set: function () {
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
              );
            },
          },
        }),
        (Da.prototype.initBones = function () {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }),
        (sn.prototype.setLens = function (t, e) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t);
        }),
        Object.defineProperties(yh.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = t);
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = t);
            },
          },
          shadowCameraRight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = t);
            },
          },
          shadowCameraTop: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = t);
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = t);
            },
          },
          shadowCameraNear: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = t);
            },
          },
          shadowCameraFar: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = t);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (t) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = t);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = t);
            },
          },
          shadowMapHeight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = t);
            },
          },
        }),
        Object.defineProperties(mi.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === ct
              );
            },
            set: function () {
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
                this.setUsage(ct);
            },
          },
        }),
        (mi.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? ct : ht),
            this
          );
        }),
        (mi.prototype.copyIndicesArray = function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        }),
        (mi.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        (Ii.prototype.addIndex = function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        }),
        (Ii.prototype.addAttribute = function (t, e) {
          return (
            console.warn(
              "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? "index" === t
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.setAttribute(t, new mi(arguments[1], arguments[2])))
          );
        }),
        (Ii.prototype.addDrawCall = function (t, e, i) {
          void 0 !== i &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        }),
        (Ii.prototype.clearDrawCalls = function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        }),
        (Ii.prototype.computeOffsets = function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        }),
        (Ii.prototype.removeAttribute = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
            ),
            this.deleteAttribute(t)
          );
        }),
        (Ii.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties(Ii.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        (oa.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? ct : ht),
            this
          );
        }),
        (oa.prototype.setArray = function () {
          console.error(
            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        (bl.prototype.getArrays = function () {
          console.error(
            "THREE.ExtrudeGeometry: .getArrays() has been removed."
          );
        }),
        (bl.prototype.addShapeList = function () {
          console.error(
            "THREE.ExtrudeGeometry: .addShapeList() has been removed."
          );
        }),
        (bl.prototype.addShape = function () {
          console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
        }),
        (aa.prototype.dispose = function () {
          console.error("THREE.Scene: .dispose() has been removed.");
        }),
        (Sc.prototype.onUpdate = function () {
          return (
            console.warn(
              "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
            ),
            this
          );
        }),
        Object.defineProperties(ci.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          overdraw: {
            get: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new Ft()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = 1 === t);
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
                (this.stencilFuncMask = t);
            },
          },
          vertexTangents: {
            get: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
            set: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
          },
        }),
        Object.defineProperties(nn.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (t) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = t);
            },
          },
        }),
        (ia.prototype.clearTarget = function (t, e, i, n) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, i, n);
        }),
        (ia.prototype.animate = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        }),
        (ia.prototype.getCurrentRenderTarget = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        }),
        (ia.prototype.getMaxAnisotropy = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        }),
        (ia.prototype.getPrecision = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        }),
        (ia.prototype.resetGLState = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        }),
        (ia.prototype.supportsFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        }),
        (ia.prototype.supportsHalfFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        }),
        (ia.prototype.supportsStandardDerivatives = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        }),
        (ia.prototype.supportsCompressedTextureS3TC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        }),
        (ia.prototype.supportsCompressedTexturePVRTC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        }),
        (ia.prototype.supportsBlendMinMax = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        }),
        (ia.prototype.supportsVertexTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        }),
        (ia.prototype.supportsInstancedArrays = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        }),
        (ia.prototype.enableScissorTest = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        }),
        (ia.prototype.initMaterial = function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        }),
        (ia.prototype.addPrePlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        }),
        (ia.prototype.addPostPlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        }),
        (ia.prototype.updateShadowMap = function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        }),
        (ia.prototype.setFaceCulling = function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        }),
        (ia.prototype.allocTextureUnit = function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        }),
        (ia.prototype.setTexture = function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        }),
        (ia.prototype.setTexture2D = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        }),
        (ia.prototype.setTextureCube = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        }),
        (ia.prototype.getActiveMipMapLevel = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        }),
        Object.defineProperties(ia.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = t);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = t);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
              );
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
              );
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              );
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
                (this.outputEncoding = !0 === t ? ot : at);
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              );
            },
          },
          gammaFactor: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaFactor has been removed."
                ),
                2
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              );
            },
          },
        }),
        Object.defineProperties(js.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(jt.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = t);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = t);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = t);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = t);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = t);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = t);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = t);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = t);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = t);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = t);
            },
          },
        }),
        (rc.prototype.load = function (t) {
          console.warn(
            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
          );
          const e = this;
          return (
            new qh().load(t, function (t) {
              e.setBuffer(t);
            }),
            this
          );
        }),
        (hc.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (on.prototype.updateCubeMap = function (t, e) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(t, e)
          );
        }),
        (on.prototype.clear = function (t, e, i, n) {
          return (
            console.warn(
              "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
            ),
            this.renderTarget.clear(t, e, i, n)
          );
        }),
        (Ut.crossOrigin = void 0),
        (Ut.loadTexture = function (t, e, i, n) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          const r = new gh();
          r.setCrossOrigin(this.crossOrigin);
          const s = r.load(t, i, void 0, n);
          return e && (s.mapping = e), s;
        }),
        (Ut.loadTextureCube = function (t, e, i, n) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          const r = new mh();
          r.setCrossOrigin(this.crossOrigin);
          const s = r.load(t, i, void 0, n);
          return e && (s.mapping = e), s;
        }),
        (Ut.loadCompressedTexture = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        }),
        (Ut.loadCompressedTextureCube = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        });
      const ru = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
      };
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: e } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = e)),
        (t.ACESFilmicToneMapping = 4),
        (t.AddEquation = i),
        (t.AddOperation = 2),
        (t.AdditiveAnimationBlendMode = st),
        (t.AdditiveBlending = 2),
        (t.AlphaFormat = 1021),
        (t.AlwaysDepth = 1),
        (t.AlwaysStencilFunc = 519),
        (t.AmbientLight = Ih),
        (t.AmbientLightProbe = Yh),
        (t.AnimationClip = sh),
        (t.AnimationLoader = class extends ch {
          constructor(t) {
            super(t);
          }
          load(t, e, i, n) {
            const r = this,
              s = new dh(this.manager);
            s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (i) {
                  try {
                    e(r.parse(JSON.parse(i)));
                  } catch (e) {
                    n ? n(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                i,
                n
              );
          }
          parse(t) {
            const e = [];
            for (let i = 0; i < t.length; i++) {
              const n = sh.parse(t[i]);
              e.push(n);
            }
            return e;
          }
        }),
        (t.AnimationMixer = wc),
        (t.AnimationObjectGroup = bc),
        (t.AnimationUtils = ql),
        (t.ArcCurve = Ao),
        (t.ArrayCamera = Js),
        (t.ArrowHelper = class extends Ke {
          constructor(
            t = new Jt(0, 0, 1),
            e = new Jt(0, 0, 0),
            i = 1,
            n = 16776960,
            r = 0.2 * i,
            s = 0.2 * r
          ) {
            super(),
              (this.type = "ArrowHelper"),
              void 0 === $c &&
                (($c = new Ii()),
                $c.setAttribute("position", new wi([0, 0, 0, 0, 1, 0], 3)),
                (tu = new go(0, 0.5, 1, 5, 1)),
                tu.translate(0, -0.5, 0)),
              this.position.copy(e),
              (this.line = new Qa($c, new qa({ color: n, toneMapped: !1 }))),
              (this.line.matrixAutoUpdate = !1),
              this.add(this.line),
              (this.cone = new Zi(tu, new ui({ color: n, toneMapped: !1 }))),
              (this.cone.matrixAutoUpdate = !1),
              this.add(this.cone),
              this.setDirection(t),
              this.setLength(i, r, s);
          }
          setDirection(t) {
            if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
            else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
            else {
              Qc.set(t.z, 0, -t.x).normalize();
              const e = Math.acos(t.y);
              this.quaternion.setFromAxisAngle(Qc, e);
            }
          }
          setLength(t, e = 0.2 * t, i = 0.2 * e) {
            this.line.scale.set(1, Math.max(1e-4, t - e), 1),
              this.line.updateMatrix(),
              this.cone.scale.set(i, e, i),
              (this.cone.position.y = t),
              this.cone.updateMatrix();
          }
          setColor(t) {
            this.line.material.color.set(t), this.cone.material.color.set(t);
          }
          copy(t) {
            return (
              super.copy(t, !1),
              this.line.copy(t.line),
              this.cone.copy(t.cone),
              this
            );
          }
        }),
        (t.Audio = rc),
        (t.AudioAnalyser = hc),
        (t.AudioContext = jh),
        (t.AudioListener = class extends Ke {
          constructor() {
            super(),
              (this.type = "AudioListener"),
              (this.context = jh.getContext()),
              (this.gain = this.context.createGain()),
              this.gain.connect(this.context.destination),
              (this.filter = null),
              (this.timeDelta = 0),
              (this._clock = new Qh());
          }
          getInput() {
            return this.gain;
          }
          removeFilter() {
            return (
              null !== this.filter &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            );
          }
          getFilter() {
            return this.filter;
          }
          setFilter(t) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = t),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            );
          }
          getMasterVolume() {
            return this.gain.gain.value;
          }
          setMasterVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t);
            const e = this.context.listener,
              i = this.up;
            if (
              ((this.timeDelta = this._clock.getDelta()),
              this.matrixWorld.decompose(tc, ec, ic),
              nc.set(0, 0, -1).applyQuaternion(ec),
              e.positionX)
            ) {
              const t = this.context.currentTime + this.timeDelta;
              e.positionX.linearRampToValueAtTime(tc.x, t),
                e.positionY.linearRampToValueAtTime(tc.y, t),
                e.positionZ.linearRampToValueAtTime(tc.z, t),
                e.forwardX.linearRampToValueAtTime(nc.x, t),
                e.forwardY.linearRampToValueAtTime(nc.y, t),
                e.forwardZ.linearRampToValueAtTime(nc.z, t),
                e.upX.linearRampToValueAtTime(i.x, t),
                e.upY.linearRampToValueAtTime(i.y, t),
                e.upZ.linearRampToValueAtTime(i.z, t);
            } else
              e.setPosition(tc.x, tc.y, tc.z),
                e.setOrientation(nc.x, nc.y, nc.z, i.x, i.y, i.z);
          }
        }),
        (t.AudioLoader = qh),
        (t.AxesHelper = eu),
        (t.AxisHelper = function (t) {
          return (
            console.warn(
              "THREE.AxisHelper has been renamed to THREE.AxesHelper."
            ),
            new eu(t)
          );
        }),
        (t.BackSide = 1),
        (t.BasicDepthPacking = 3200),
        (t.BasicShadowMap = 0),
        (t.BinaryTextureLoader = function (t) {
          return (
            console.warn(
              "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
            ),
            new fh(t)
          );
        }),
        (t.Bone = Na),
        (t.BooleanKeyframeTrack = Ql),
        (t.BoundingBoxHelper = function (t, e) {
          return (
            console.warn(
              "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
            ),
            new Kc(t, e)
          );
        }),
        (t.Box2 = Cc),
        (t.Box3 = Qt),
        (t.Box3Helper = class extends eo {
          constructor(t, e = 16776960) {
            const i = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              n = new Ii();
            n.setIndex(new mi(i, 1)),
              n.setAttribute(
                "position",
                new wi(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3
                )
              ),
              super(n, new qa({ color: e, toneMapped: !1 })),
              (this.box = t),
              (this.type = "Box3Helper"),
              this.geometry.computeBoundingSphere();
          }
          updateMatrixWorld(t) {
            const e = this.box;
            e.isEmpty() ||
              (e.getCenter(this.position),
              e.getSize(this.scale),
              this.scale.multiplyScalar(0.5),
              super.updateMatrixWorld(t));
          }
        }),
        (t.BoxBufferGeometry = Qi),
        (t.BoxGeometry = Qi),
        (t.BoxHelper = Kc),
        (t.BufferAttribute = mi),
        (t.BufferGeometry = Ii),
        (t.BufferGeometryLoader = Hh),
        (t.ByteType = 1010),
        (t.Cache = oh),
        (t.Camera = rn),
        (t.CameraHelper = class extends eo {
          constructor(t) {
            const e = new Ii(),
              i = new qa({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              n = [],
              r = [],
              s = {},
              a = new Ft(16755200),
              o = new Ft(16711680),
              l = new Ft(43775),
              h = new Ft(16777215),
              c = new Ft(3355443);
            function u(t, e, i) {
              d(t, i), d(e, i);
            }
            function d(t, e) {
              n.push(0, 0, 0),
                r.push(e.r, e.g, e.b),
                void 0 === s[t] && (s[t] = []),
                s[t].push(n.length / 3 - 1);
            }
            u("n1", "n2", a),
              u("n2", "n4", a),
              u("n4", "n3", a),
              u("n3", "n1", a),
              u("f1", "f2", a),
              u("f2", "f4", a),
              u("f4", "f3", a),
              u("f3", "f1", a),
              u("n1", "f1", a),
              u("n2", "f2", a),
              u("n3", "f3", a),
              u("n4", "f4", a),
              u("p", "n1", o),
              u("p", "n2", o),
              u("p", "n3", o),
              u("p", "n4", o),
              u("u1", "u2", l),
              u("u2", "u3", l),
              u("u3", "u1", l),
              u("c", "t", h),
              u("p", "c", c),
              u("cn1", "cn2", c),
              u("cn3", "cn4", c),
              u("cf1", "cf2", c),
              u("cf3", "cf4", c),
              e.setAttribute("position", new wi(n, 3)),
              e.setAttribute("color", new wi(r, 3)),
              super(e, i),
              (this.type = "CameraHelper"),
              (this.camera = t),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = s),
              this.update();
          }
          update() {
            const t = this.geometry,
              e = this.pointMap;
            Yc.projectionMatrixInverse.copy(
              this.camera.projectionMatrixInverse
            ),
              Jc("c", e, t, Yc, 0, 0, -1),
              Jc("t", e, t, Yc, 0, 0, 1),
              Jc("n1", e, t, Yc, -1, -1, -1),
              Jc("n2", e, t, Yc, 1, -1, -1),
              Jc("n3", e, t, Yc, -1, 1, -1),
              Jc("n4", e, t, Yc, 1, 1, -1),
              Jc("f1", e, t, Yc, -1, -1, 1),
              Jc("f2", e, t, Yc, 1, -1, 1),
              Jc("f3", e, t, Yc, -1, 1, 1),
              Jc("f4", e, t, Yc, 1, 1, 1),
              Jc("u1", e, t, Yc, 0.7, 1.1, -1),
              Jc("u2", e, t, Yc, -0.7, 1.1, -1),
              Jc("u3", e, t, Yc, 0, 2, -1),
              Jc("cf1", e, t, Yc, -1, 0, 1),
              Jc("cf2", e, t, Yc, 1, 0, 1),
              Jc("cf3", e, t, Yc, 0, -1, 1),
              Jc("cf4", e, t, Yc, 0, 1, 1),
              Jc("cn1", e, t, Yc, -1, 0, -1),
              Jc("cn2", e, t, Yc, 1, 0, -1),
              Jc("cn3", e, t, Yc, 0, -1, -1),
              Jc("cn4", e, t, Yc, 0, 1, -1),
              (t.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }),
        (t.CanvasRenderer = function () {
          console.error("THREE.CanvasRenderer has been removed");
        }),
        (t.CanvasTexture = mo),
        (t.CatmullRomCurve3 = zo),
        (t.CineonToneMapping = 3),
        (t.CircleBufferGeometry = fo),
        (t.CircleGeometry = fo),
        (t.ClampToEdgeWrapping = u),
        (t.Clock = Qh),
        (t.Color = Ft),
        (t.ColorKeyframeTrack = $l),
        (t.CompressedTexture = po),
        (t.CompressedTextureLoader = class extends ch {
          constructor(t) {
            super(t);
          }
          load(t, e, i, n) {
            const r = this,
              s = [],
              a = new po(),
              o = new dh(this.manager);
            o.setPath(this.path),
              o.setResponseType("arraybuffer"),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(r.withCredentials);
            let l = 0;
            function h(h) {
              o.load(
                t[h],
                function (t) {
                  const i = r.parse(t, !0);
                  (s[h] = {
                    width: i.width,
                    height: i.height,
                    format: i.format,
                    mipmaps: i.mipmaps,
                  }),
                    (l += 1),
                    6 === l &&
                      (1 === i.mipmapCount && (a.minFilter = g),
                      (a.image = s),
                      (a.format = i.format),
                      (a.needsUpdate = !0),
                      e && e(a));
                },
                i,
                n
              );
            }
            if (Array.isArray(t))
              for (let e = 0, i = t.length; e < i; ++e) h(e);
            else
              o.load(
                t,
                function (t) {
                  const i = r.parse(t, !0);
                  if (i.isCubemap) {
                    const t = i.mipmaps.length / i.mipmapCount;
                    for (let e = 0; e < t; e++) {
                      s[e] = { mipmaps: [] };
                      for (let t = 0; t < i.mipmapCount; t++)
                        s[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]),
                          (s[e].format = i.format),
                          (s[e].width = i.width),
                          (s[e].height = i.height);
                    }
                    a.image = s;
                  } else
                    (a.image.width = i.width),
                      (a.image.height = i.height),
                      (a.mipmaps = i.mipmaps);
                  1 === i.mipmapCount && (a.minFilter = g),
                    (a.format = i.format),
                    (a.needsUpdate = !0),
                    e && e(a);
                },
                i,
                n
              );
            return a;
          }
        }),
        (t.ConeBufferGeometry = yo),
        (t.ConeGeometry = yo),
        (t.CubeCamera = on),
        (t.CubeReflectionMapping = r),
        (t.CubeRefractionMapping = s),
        (t.CubeTexture = ln),
        (t.CubeTextureLoader = mh),
        (t.CubeUVReflectionMapping = l),
        (t.CubeUVRefractionMapping = h),
        (t.CubicBezierCurve = Bo),
        (t.CubicBezierCurve3 = Fo),
        (t.CubicInterpolant = Yl),
        (t.CullFaceBack = 1),
        (t.CullFaceFront = 2),
        (t.CullFaceFrontBack = 3),
        (t.CullFaceNone = 0),
        (t.Curve = To),
        (t.CurvePath = jo),
        (t.CustomBlending = 5),
        (t.CustomToneMapping = 5),
        (t.CylinderBufferGeometry = go),
        (t.CylinderGeometry = go),
        (t.Cylindrical = class {
          constructor(t = 1, e = 0, i = 0) {
            return (this.radius = t), (this.theta = e), (this.y = i), this;
          }
          set(t, e, i) {
            return (this.radius = t), (this.theta = e), (this.y = i), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, i) {
            return (
              (this.radius = Math.sqrt(t * t + i * i)),
              (this.theta = Math.atan2(t, i)),
              (this.y = e),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }),
        (t.DataTexture = Oa),
        (t.DataTexture2DArray = $n),
        (t.DataTexture3D = sr),
        (t.DataTextureLoader = fh),
        (t.DataUtils = class {
          static toHalfFloat(t) {
            t > 65504 &&
              (console.warn(
                "THREE.DataUtils.toHalfFloat(): value exceeds 65504."
              ),
              (t = 65504)),
              (iu[0] = t);
            const e = nu[0];
            let i = (e >> 16) & 32768,
              n = (e >> 12) & 2047;
            const r = (e >> 23) & 255;
            return r < 103
              ? i
              : r > 142
              ? ((i |= 31744), (i |= (255 == r ? 0 : 1) && 8388607 & e), i)
              : r < 113
              ? ((n |= 2048),
                (i |= (n >> (114 - r)) + ((n >> (113 - r)) & 1)),
                i)
              : ((i |= ((r - 112) << 10) | (n >> 1)), (i += 1 & n), i);
          }
        }),
        (t.DecrementStencilOp = 7683),
        (t.DecrementWrapStencilOp = 34056),
        (t.DefaultLoadingManager = hh),
        (t.DepthFormat = E),
        (t.DepthStencilFormat = A),
        (t.DepthTexture = $s),
        (t.DirectionalLight = Ph),
        (t.DirectionalLightHelper = class extends Ke {
          constructor(t, e, i) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = i),
              void 0 === e && (e = 1);
            let n = new Ii();
            n.setAttribute(
              "position",
              new wi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
            );
            const r = new qa({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new Qa(n, r)),
              this.add(this.lightPlane),
              (n = new Ii()),
              n.setAttribute("position", new wi([0, 0, 0, 0, 0, 1], 3)),
              (this.targetLine = new Qa(n, r)),
              this.add(this.targetLine),
              this.update();
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose();
          }
          update() {
            Wc.setFromMatrixPosition(this.light.matrixWorld),
              jc.setFromMatrixPosition(this.light.target.matrixWorld),
              qc.subVectors(jc, Wc),
              this.lightPlane.lookAt(jc),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(jc),
              (this.targetLine.scale.z = qc.length());
          }
        }),
        (t.DiscreteInterpolant = Zl),
        (t.DodecahedronBufferGeometry = vo),
        (t.DodecahedronGeometry = vo),
        (t.DoubleSide = 2),
        (t.DstAlphaFactor = 206),
        (t.DstColorFactor = 208),
        (t.DynamicBufferAttribute = function (t, e) {
          return (
            console.warn(
              "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
            ),
            new mi(t, e).setUsage(ct)
          );
        }),
        (t.DynamicCopyUsage = 35050),
        (t.DynamicDrawUsage = ct),
        (t.DynamicReadUsage = 35049),
        (t.EdgesGeometry = So),
        (t.EdgesHelper = function (t, e) {
          return (
            console.warn(
              "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
            ),
            new eo(
              new So(t.geometry),
              new qa({ color: void 0 !== e ? e : 16777215 })
            )
          );
        }),
        (t.EllipseCurve = Eo),
        (t.EqualDepth = 4),
        (t.EqualStencilFunc = 514),
        (t.EquirectangularReflectionMapping = a),
        (t.EquirectangularRefractionMapping = o),
        (t.Euler = Oe),
        (t.EventDispatcher = pt),
        (t.ExtrudeBufferGeometry = bl),
        (t.ExtrudeGeometry = bl),
        (t.FaceColors = 1),
        (t.FileLoader = dh),
        (t.FlatShading = 1),
        (t.Float16BufferAttribute = Mi),
        (t.Float32Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
            ),
            new wi(t, e)
          );
        }),
        (t.Float32BufferAttribute = wi),
        (t.Float64Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
            ),
            new Si(t, e)
          );
        }),
        (t.Float64BufferAttribute = Si),
        (t.FloatType = M),
        (t.Fog = sa),
        (t.FogExp2 = ra),
        (t.Font = function () {
          console.error(
            "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js"
          );
        }),
        (t.FontLoader = function () {
          console.error(
            "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js"
          );
        }),
        (t.FramebufferTexture = uo),
        (t.FrontSide = 0),
        (t.Frustum = gn),
        (t.GLBufferAttribute = Ec),
        (t.GLSL1 = "100"),
        (t.GLSL3 = ut),
        (t.GreaterDepth = 6),
        (t.GreaterEqualDepth = 5),
        (t.GreaterEqualStencilFunc = 518),
        (t.GreaterStencilFunc = 516),
        (t.GridHelper = Vc),
        (t.Group = Zs),
        (t.HalfFloatType = w),
        (t.HemisphereLight = xh),
        (t.HemisphereLightHelper = class extends Ke {
          constructor(t, e, i) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = i);
            const n = new Tl(e);
            n.rotateY(0.5 * Math.PI),
              (this.material = new ui({
                wireframe: !0,
                fog: !1,
                toneMapped: !1,
              })),
              void 0 === this.color && (this.material.vertexColors = !0);
            const r = n.getAttribute("position"),
              s = new Float32Array(3 * r.count);
            n.setAttribute("color", new mi(s, 3)),
              this.add(new Zi(n, this.material)),
              this.update();
          }
          dispose() {
            this.children[0].geometry.dispose(),
              this.children[0].material.dispose();
          }
          update() {
            const t = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
              const e = t.geometry.getAttribute("color");
              kc.copy(this.light.color), Gc.copy(this.light.groundColor);
              for (let t = 0, i = e.count; t < i; t++) {
                const n = t < i / 2 ? kc : Gc;
                e.setXYZ(t, n.r, n.g, n.b);
              }
              e.needsUpdate = !0;
            }
            t.lookAt(Uc.setFromMatrixPosition(this.light.matrixWorld).negate());
          }
        }),
        (t.HemisphereLightProbe = Xh),
        (t.IcosahedronBufferGeometry = wl),
        (t.IcosahedronGeometry = wl),
        (t.ImageBitmapLoader = Vh),
        (t.ImageLoader = ph),
        (t.ImageUtils = Ut),
        (t.ImmediateRenderObject = function () {
          console.error("THREE.ImmediateRenderObject has been removed.");
        }),
        (t.IncrementStencilOp = 7682),
        (t.IncrementWrapStencilOp = 34055),
        (t.InstancedBufferAttribute = Ua),
        (t.InstancedBufferGeometry = Fh),
        (t.InstancedInterleavedBuffer = Tc),
        (t.InstancedMesh = ja),
        (t.Int16Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
            ),
            new xi(t, e)
          );
        }),
        (t.Int16BufferAttribute = xi),
        (t.Int32Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
            ),
            new _i(t, e)
          );
        }),
        (t.Int32BufferAttribute = _i),
        (t.Int8Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
            ),
            new fi(t, e)
          );
        }),
        (t.Int8BufferAttribute = fi),
        (t.IntType = 1013),
        (t.InterleavedBuffer = oa),
        (t.InterleavedBufferAttribute = ha),
        (t.Interpolant = Xl),
        (t.InterpolateDiscrete = $),
        (t.InterpolateLinear = tt),
        (t.InterpolateSmooth = et),
        (t.InvertStencilOp = 5386),
        (t.JSONLoader = function () {
          console.error("THREE.JSONLoader has been removed.");
        }),
        (t.KeepStencilOp = lt),
        (t.KeyframeTrack = Kl),
        (t.LOD = Ra),
        (t.LatheBufferGeometry = Sl),
        (t.LatheGeometry = Sl),
        (t.Layers = Be),
        (t.LensFlare = function () {
          console.error(
            "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
          );
        }),
        (t.LessDepth = 2),
        (t.LessEqualDepth = 3),
        (t.LessEqualStencilFunc = 515),
        (t.LessStencilFunc = 513),
        (t.Light = yh),
        (t.LightProbe = Nh),
        (t.Line = Qa),
        (t.Line3 = zc),
        (t.LineBasicMaterial = qa),
        (t.LineCurve = Ho),
        (t.LineCurve3 = Uo),
        (t.LineDashedMaterial = Wl),
        (t.LineLoop = io),
        (t.LinePieces = 1),
        (t.LineSegments = eo),
        (t.LineStrip = 0),
        (t.LinearEncoding = at),
        (t.LinearFilter = g),
        (t.LinearInterpolant = Jl),
        (t.LinearMipMapLinearFilter = 1008),
        (t.LinearMipMapNearestFilter = 1007),
        (t.LinearMipmapLinearFilter = x),
        (t.LinearMipmapNearestFilter = y),
        (t.LinearToneMapping = 1),
        (t.Loader = ch),
        (t.LoaderUtils = Bh),
        (t.LoadingManager = lh),
        (t.LoopOnce = 2200),
        (t.LoopPingPong = 2202),
        (t.LoopRepeat = 2201),
        (t.LuminanceAlphaFormat = 1025),
        (t.LuminanceFormat = 1024),
        (t.MOUSE = {
          LEFT: 0,
          MIDDLE: 1,
          RIGHT: 2,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
        }),
        (t.Material = ci),
        (t.MaterialLoader = Oh),
        (t.Math = Tt),
        (t.MathUtils = Tt),
        (t.Matrix3 = At),
        (t.Matrix4 = Ee),
        (t.MaxEquation = 104),
        (t.Mesh = Zi),
        (t.MeshBasicMaterial = ui),
        (t.MeshDepthMaterial = Vs),
        (t.MeshDistanceMaterial = Ws),
        (t.MeshFaceMaterial = function (t) {
          return (
            console.warn(
              "THREE.MeshFaceMaterial has been removed. Use an Array instead."
            ),
            t
          );
        }),
        (t.MeshLambertMaterial = Gl),
        (t.MeshMatcapMaterial = Vl),
        (t.MeshNormalMaterial = kl),
        (t.MeshPhongMaterial = Hl),
        (t.MeshPhysicalMaterial = Fl),
        (t.MeshStandardMaterial = Bl),
        (t.MeshToonMaterial = Ul),
        (t.MinEquation = 103),
        (t.MirroredRepeatWrapping = d),
        (t.MixOperation = 1),
        (t.MultiMaterial = function (t = []) {
          return (
            console.warn(
              "THREE.MultiMaterial has been removed. Use an Array instead."
            ),
            (t.isMultiMaterial = !0),
            (t.materials = t),
            (t.clone = function () {
              return t.slice();
            }),
            t
          );
        }),
        (t.MultiplyBlending = 4),
        (t.MultiplyOperation = 0),
        (t.NearestFilter = p),
        (t.NearestMipMapLinearFilter = 1005),
        (t.NearestMipMapNearestFilter = 1004),
        (t.NearestMipmapLinearFilter = f),
        (t.NearestMipmapNearestFilter = m),
        (t.NeverDepth = 0),
        (t.NeverStencilFunc = 512),
        (t.NoBlending = 0),
        (t.NoColors = 0),
        (t.NoToneMapping = 0),
        (t.NormalAnimationBlendMode = 2500),
        (t.NormalBlending = 1),
        (t.NotEqualDepth = 7),
        (t.NotEqualStencilFunc = 517),
        (t.NumberKeyframeTrack = th),
        (t.Object3D = Ke),
        (t.ObjectLoader = class extends ch {
          constructor(t) {
            super(t);
          }
          load(t, e, i, n) {
            const r = this,
              s = "" === this.path ? Bh.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || s;
            const a = new dh(this.manager);
            a.setPath(this.path),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(this.withCredentials),
              a.load(
                t,
                function (i) {
                  let s = null;
                  try {
                    s = JSON.parse(i);
                  } catch (e) {
                    return (
                      void 0 !== n && n(e),
                      void console.error(
                        "THREE:ObjectLoader: Can't parse " + t + ".",
                        e.message
                      )
                    );
                  }
                  const a = s.metadata;
                  void 0 !== a &&
                  void 0 !== a.type &&
                  "geometry" !== a.type.toLowerCase()
                    ? r.parse(s, e)
                    : console.error("THREE.ObjectLoader: Can't load " + t);
                },
                i,
                n
              );
          }
          async loadAsync(t, e) {
            const i = "" === this.path ? Bh.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || i;
            const n = new dh(this.manager);
            n.setPath(this.path),
              n.setRequestHeader(this.requestHeader),
              n.setWithCredentials(this.withCredentials);
            const r = await n.loadAsync(t, e),
              s = JSON.parse(r),
              a = s.metadata;
            if (
              void 0 === a ||
              void 0 === a.type ||
              "geometry" === a.type.toLowerCase()
            )
              throw new Error("THREE.ObjectLoader: Can't load " + t);
            return await this.parseAsync(s);
          }
          parse(t, e) {
            const i = this.parseAnimations(t.animations),
              n = this.parseShapes(t.shapes),
              r = this.parseGeometries(t.geometries, n),
              s = this.parseImages(t.images, function () {
                void 0 !== e && e(l);
              }),
              a = this.parseTextures(t.textures, s),
              o = this.parseMaterials(t.materials, a),
              l = this.parseObject(t.object, r, o, a, i),
              h = this.parseSkeletons(t.skeletons, l);
            if ((this.bindSkeletons(l, h), void 0 !== e)) {
              let t = !1;
              for (const e in s)
                if (s[e] instanceof HTMLImageElement) {
                  t = !0;
                  break;
                }
              !1 === t && e(l);
            }
            return l;
          }
          async parseAsync(t) {
            const e = this.parseAnimations(t.animations),
              i = this.parseShapes(t.shapes),
              n = this.parseGeometries(t.geometries, i),
              r = await this.parseImagesAsync(t.images),
              s = this.parseTextures(t.textures, r),
              a = this.parseMaterials(t.materials, s),
              o = this.parseObject(t.object, n, a, s, e),
              l = this.parseSkeletons(t.skeletons, o);
            return this.bindSkeletons(o, l), o;
          }
          parseShapes(t) {
            const e = {};
            if (void 0 !== t)
              for (let i = 0, n = t.length; i < n; i++) {
                const n = new Xo().fromJSON(t[i]);
                e[n.uuid] = n;
              }
            return e;
          }
          parseSkeletons(t, e) {
            const i = {},
              n = {};
            if (
              (e.traverse(function (t) {
                t.isBone && (n[t.uuid] = t);
              }),
              void 0 !== t)
            )
              for (let e = 0, r = t.length; e < r; e++) {
                const r = new Ha().fromJSON(t[e], n);
                i[r.uuid] = r;
              }
            return i;
          }
          parseGeometries(t, e) {
            const i = {};
            if (void 0 !== t) {
              const n = new Hh();
              for (let r = 0, s = t.length; r < s; r++) {
                let s;
                const a = t[r];
                switch (a.type) {
                  case "BufferGeometry":
                  case "InstancedBufferGeometry":
                    s = n.parse(a);
                    break;
                  case "Geometry":
                    console.error(
                      "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                    );
                    break;
                  default:
                    a.type in Nl
                      ? (s = Nl[a.type].fromJSON(a, e))
                      : console.warn(
                          `THREE.ObjectLoader: Unsupported geometry type "${a.type}"`
                        );
                }
                (s.uuid = a.uuid),
                  void 0 !== a.name && (s.name = a.name),
                  !0 === s.isBufferGeometry &&
                    void 0 !== a.userData &&
                    (s.userData = a.userData),
                  (i[a.uuid] = s);
              }
            }
            return i;
          }
          parseMaterials(t, e) {
            const i = {},
              n = {};
            if (void 0 !== t) {
              const r = new Oh();
              r.setTextures(e);
              for (let e = 0, s = t.length; e < s; e++) {
                const s = t[e];
                if ("MultiMaterial" === s.type) {
                  const t = [];
                  for (let e = 0; e < s.materials.length; e++) {
                    const n = s.materials[e];
                    void 0 === i[n.uuid] && (i[n.uuid] = r.parse(n)),
                      t.push(i[n.uuid]);
                  }
                  n[s.uuid] = t;
                } else
                  void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)),
                    (n[s.uuid] = i[s.uuid]);
              }
            }
            return n;
          }
          parseAnimations(t) {
            const e = {};
            if (void 0 !== t)
              for (let i = 0; i < t.length; i++) {
                const n = t[i],
                  r = sh.parse(n);
                e[r.uuid] = r;
              }
            return e;
          }
          parseImages(t, e) {
            const i = this,
              n = {};
            let r;
            function s(t) {
              if ("string" == typeof t) {
                const e = t;
                return (function (t) {
                  return (
                    i.manager.itemStart(t),
                    r.load(
                      t,
                      function () {
                        i.manager.itemEnd(t);
                      },
                      void 0,
                      function () {
                        i.manager.itemError(t), i.manager.itemEnd(t);
                      }
                    )
                  );
                })(
                  /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : i.resourcePath + e
                );
              }
              return t.data
                ? { data: Ct(t.type, t.data), width: t.width, height: t.height }
                : null;
            }
            if (void 0 !== t && t.length > 0) {
              const i = new lh(e);
              (r = new ph(i)), r.setCrossOrigin(this.crossOrigin);
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e],
                  r = i.url;
                if (Array.isArray(r)) {
                  n[i.uuid] = [];
                  for (let t = 0, e = r.length; t < e; t++) {
                    const e = s(r[t]);
                    null !== e &&
                      (e instanceof HTMLImageElement
                        ? n[i.uuid].push(e)
                        : n[i.uuid].push(new Oa(e.data, e.width, e.height)));
                  }
                } else {
                  const t = s(i.url);
                  null !== t && (n[i.uuid] = t);
                }
              }
            }
            return n;
          }
          async parseImagesAsync(t) {
            const e = this,
              i = {};
            let n;
            async function r(t) {
              if ("string" == typeof t) {
                const i = t,
                  r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i)
                    ? i
                    : e.resourcePath + i;
                return await n.loadAsync(r);
              }
              return t.data
                ? { data: Ct(t.type, t.data), width: t.width, height: t.height }
                : null;
            }
            if (void 0 !== t && t.length > 0) {
              (n = new ph(this.manager)), n.setCrossOrigin(this.crossOrigin);
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e],
                  s = n.url;
                if (Array.isArray(s)) {
                  i[n.uuid] = [];
                  for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t],
                      a = await r(e);
                    null !== a &&
                      (a instanceof HTMLImageElement
                        ? i[n.uuid].push(a)
                        : i[n.uuid].push(new Oa(a.data, a.width, a.height)));
                  }
                } else {
                  const t = await r(n.url);
                  null !== t && (i[n.uuid] = t);
                }
              }
            }
            return i;
          }
          parseTextures(t, e) {
            function i(t, e) {
              return "number" == typeof t
                ? t
                : (console.warn(
                    "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                    t
                  ),
                  e[t]);
            }
            const n = {};
            if (void 0 !== t)
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r];
                let a;
                void 0 === s.image &&
                  console.warn(
                    'THREE.ObjectLoader: No "image" specified for',
                    s.uuid
                  ),
                  void 0 === e[s.image] &&
                    console.warn(
                      "THREE.ObjectLoader: Undefined image",
                      s.image
                    );
                const o = e[s.image];
                Array.isArray(o)
                  ? ((a = new ln(o)), 6 === o.length && (a.needsUpdate = !0))
                  : ((a =
                      o && o.data
                        ? new Oa(o.data, o.width, o.height)
                        : new Gt(o)),
                    o && (a.needsUpdate = !0)),
                  (a.uuid = s.uuid),
                  void 0 !== s.name && (a.name = s.name),
                  void 0 !== s.mapping && (a.mapping = i(s.mapping, Uh)),
                  void 0 !== s.offset && a.offset.fromArray(s.offset),
                  void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
                  void 0 !== s.center && a.center.fromArray(s.center),
                  void 0 !== s.rotation && (a.rotation = s.rotation),
                  void 0 !== s.wrap &&
                    ((a.wrapS = i(s.wrap[0], kh)),
                    (a.wrapT = i(s.wrap[1], kh))),
                  void 0 !== s.format && (a.format = s.format),
                  void 0 !== s.type && (a.type = s.type),
                  void 0 !== s.encoding && (a.encoding = s.encoding),
                  void 0 !== s.minFilter && (a.minFilter = i(s.minFilter, Gh)),
                  void 0 !== s.magFilter && (a.magFilter = i(s.magFilter, Gh)),
                  void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
                  void 0 !== s.flipY && (a.flipY = s.flipY),
                  void 0 !== s.premultiplyAlpha &&
                    (a.premultiplyAlpha = s.premultiplyAlpha),
                  void 0 !== s.unpackAlignment &&
                    (a.unpackAlignment = s.unpackAlignment),
                  void 0 !== s.userData && (a.userData = s.userData),
                  (n[s.uuid] = a);
              }
            return n;
          }
          parseObject(t, e, i, n, r) {
            let s, a, o;
            function l(t) {
              return (
                void 0 === e[t] &&
                  console.warn("THREE.ObjectLoader: Undefined geometry", t),
                e[t]
              );
            }
            function h(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  const e = [];
                  for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    void 0 === i[r] &&
                      console.warn("THREE.ObjectLoader: Undefined material", r),
                      e.push(i[r]);
                  }
                  return e;
                }
                return (
                  void 0 === i[t] &&
                    console.warn("THREE.ObjectLoader: Undefined material", t),
                  i[t]
                );
              }
            }
            function c(t) {
              return (
                void 0 === n[t] &&
                  console.warn("THREE.ObjectLoader: Undefined texture", t),
                n[t]
              );
            }
            switch (t.type) {
              case "Scene":
                (s = new aa()),
                  void 0 !== t.background &&
                    (Number.isInteger(t.background)
                      ? (s.background = new Ft(t.background))
                      : (s.background = c(t.background))),
                  void 0 !== t.environment &&
                    (s.environment = c(t.environment)),
                  void 0 !== t.fog &&
                    ("Fog" === t.fog.type
                      ? (s.fog = new sa(t.fog.color, t.fog.near, t.fog.far))
                      : "FogExp2" === t.fog.type &&
                        (s.fog = new ra(t.fog.color, t.fog.density)));
                break;
              case "PerspectiveCamera":
                (s = new sn(t.fov, t.aspect, t.near, t.far)),
                  void 0 !== t.focus && (s.focus = t.focus),
                  void 0 !== t.zoom && (s.zoom = t.zoom),
                  void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge),
                  void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset),
                  void 0 !== t.view && (s.view = Object.assign({}, t.view));
                break;
              case "OrthographicCamera":
                (s = new Ln(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                  void 0 !== t.zoom && (s.zoom = t.zoom),
                  void 0 !== t.view && (s.view = Object.assign({}, t.view));
                break;
              case "AmbientLight":
                s = new Ih(t.color, t.intensity);
                break;
              case "DirectionalLight":
                s = new Ph(t.color, t.intensity);
                break;
              case "PointLight":
                s = new Lh(t.color, t.intensity, t.distance, t.decay);
                break;
              case "RectAreaLight":
                s = new zh(t.color, t.intensity, t.width, t.height);
                break;
              case "SpotLight":
                s = new Sh(
                  t.color,
                  t.intensity,
                  t.distance,
                  t.angle,
                  t.penumbra,
                  t.decay
                );
                break;
              case "HemisphereLight":
                s = new xh(t.color, t.groundColor, t.intensity);
                break;
              case "LightProbe":
                s = new Nh().fromJSON(t);
                break;
              case "SkinnedMesh":
                (a = l(t.geometry)),
                  (o = h(t.material)),
                  (s = new Da(a, o)),
                  void 0 !== t.bindMode && (s.bindMode = t.bindMode),
                  void 0 !== t.bindMatrix &&
                    s.bindMatrix.fromArray(t.bindMatrix),
                  void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                break;
              case "Mesh":
                (a = l(t.geometry)), (o = h(t.material)), (s = new Zi(a, o));
                break;
              case "InstancedMesh":
                (a = l(t.geometry)), (o = h(t.material));
                const e = t.count,
                  i = t.instanceMatrix,
                  n = t.instanceColor;
                (s = new ja(a, o, e)),
                  (s.instanceMatrix = new Ua(new Float32Array(i.array), 16)),
                  void 0 !== n &&
                    (s.instanceColor = new Ua(
                      new Float32Array(n.array),
                      n.itemSize
                    ));
                break;
              case "LOD":
                s = new Ra();
                break;
              case "Line":
                s = new Qa(l(t.geometry), h(t.material));
                break;
              case "LineLoop":
                s = new io(l(t.geometry), h(t.material));
                break;
              case "LineSegments":
                s = new eo(l(t.geometry), h(t.material));
                break;
              case "PointCloud":
              case "Points":
                s = new lo(l(t.geometry), h(t.material));
                break;
              case "Sprite":
                s = new Sa(h(t.material));
                break;
              case "Group":
                s = new Zs();
                break;
              case "Bone":
                s = new Na();
                break;
              default:
                s = new Ke();
            }
            if (
              ((s.uuid = t.uuid),
              void 0 !== t.name && (s.name = t.name),
              void 0 !== t.matrix
                ? (s.matrix.fromArray(t.matrix),
                  void 0 !== t.matrixAutoUpdate &&
                    (s.matrixAutoUpdate = t.matrixAutoUpdate),
                  s.matrixAutoUpdate &&
                    s.matrix.decompose(s.position, s.quaternion, s.scale))
                : (void 0 !== t.position && s.position.fromArray(t.position),
                  void 0 !== t.rotation && s.rotation.fromArray(t.rotation),
                  void 0 !== t.quaternion &&
                    s.quaternion.fromArray(t.quaternion),
                  void 0 !== t.scale && s.scale.fromArray(t.scale)),
              void 0 !== t.castShadow && (s.castShadow = t.castShadow),
              void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow),
              t.shadow &&
                (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias),
                void 0 !== t.shadow.normalBias &&
                  (s.shadow.normalBias = t.shadow.normalBias),
                void 0 !== t.shadow.radius &&
                  (s.shadow.radius = t.shadow.radius),
                void 0 !== t.shadow.mapSize &&
                  s.shadow.mapSize.fromArray(t.shadow.mapSize),
                void 0 !== t.shadow.camera &&
                  (s.shadow.camera = this.parseObject(t.shadow.camera))),
              void 0 !== t.visible && (s.visible = t.visible),
              void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled),
              void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder),
              void 0 !== t.userData && (s.userData = t.userData),
              void 0 !== t.layers && (s.layers.mask = t.layers),
              void 0 !== t.children)
            ) {
              const a = t.children;
              for (let t = 0; t < a.length; t++)
                s.add(this.parseObject(a[t], e, i, n, r));
            }
            if (void 0 !== t.animations) {
              const e = t.animations;
              for (let t = 0; t < e.length; t++) {
                const i = e[t];
                s.animations.push(r[i]);
              }
            }
            if ("LOD" === t.type) {
              void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
              const e = t.levels;
              for (let t = 0; t < e.length; t++) {
                const i = e[t],
                  n = s.getObjectByProperty("uuid", i.object);
                void 0 !== n && s.addLevel(n, i.distance);
              }
            }
            return s;
          }
          bindSkeletons(t, e) {
            0 !== Object.keys(e).length &&
              t.traverse(function (t) {
                if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                  const i = e[t.skeleton];
                  void 0 === i
                    ? console.warn(
                        "THREE.ObjectLoader: No skeleton found with UUID:",
                        t.skeleton
                      )
                    : t.bind(i, t.bindMatrix);
                }
              });
          }
          setTexturePath(t) {
            return (
              console.warn(
                "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
              ),
              this.setResourcePath(t)
            );
          }
        }),
        (t.ObjectSpaceNormalMap = 1),
        (t.OctahedronBufferGeometry = Tl),
        (t.OctahedronGeometry = Tl),
        (t.OneFactor = 201),
        (t.OneMinusDstAlphaFactor = 207),
        (t.OneMinusDstColorFactor = 209),
        (t.OneMinusSrcAlphaFactor = 205),
        (t.OneMinusSrcColorFactor = 203),
        (t.OrthographicCamera = Ln),
        (t.PCFShadowMap = 1),
        (t.PCFSoftShadowMap = 2),
        (t.PMREMGenerator = Vn),
        (t.ParametricGeometry = function () {
          return (
            console.error(
              "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"
            ),
            new Ii()
          );
        }),
        (t.Particle = function (t) {
          return (
            console.warn("THREE.Particle has been renamed to THREE.Sprite."),
            new Sa(t)
          );
        }),
        (t.ParticleBasicMaterial = function (t) {
          return (
            console.warn(
              "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
            ),
            new no(t)
          );
        }),
        (t.ParticleSystem = function (t, e) {
          return (
            console.warn(
              "THREE.ParticleSystem has been renamed to THREE.Points."
            ),
            new lo(t, e)
          );
        }),
        (t.ParticleSystemMaterial = function (t) {
          return (
            console.warn(
              "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
            ),
            new no(t)
          );
        }),
        (t.Path = qo),
        (t.PerspectiveCamera = sn),
        (t.Plane = pn),
        (t.PlaneBufferGeometry = vn),
        (t.PlaneGeometry = vn),
        (t.PlaneHelper = class extends Qa {
          constructor(t, e = 1, i = 16776960) {
            const n = i,
              r = new Ii();
            r.setAttribute(
              "position",
              new wi(
                [
                  1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                  1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                ],
                3
              )
            ),
              r.computeBoundingSphere(),
              super(r, new qa({ color: n, toneMapped: !1 })),
              (this.type = "PlaneHelper"),
              (this.plane = t),
              (this.size = e);
            const s = new Ii();
            s.setAttribute(
              "position",
              new wi(
                [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                3
              )
            ),
              s.computeBoundingSphere(),
              this.add(
                new Zi(
                  s,
                  new ui({
                    color: n,
                    opacity: 0.2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1,
                  })
                )
              );
          }
          updateMatrixWorld(t) {
            let e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8),
              this.scale.set(0.5 * this.size, 0.5 * this.size, e),
              (this.children[0].material.side = e < 0 ? 1 : 0),
              this.lookAt(this.plane.normal),
              super.updateMatrixWorld(t);
          }
        }),
        (t.PointCloud = function (t, e) {
          return (
            console.warn("THREE.PointCloud has been renamed to THREE.Points."),
            new lo(t, e)
          );
        }),
        (t.PointCloudMaterial = function (t) {
          return (
            console.warn(
              "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
            ),
            new no(t)
          );
        }),
        (t.PointLight = Lh),
        (t.PointLightHelper = class extends Zi {
          constructor(t, e, i) {
            super(
              new Rl(e, 4, 2),
              new ui({ wireframe: !0, fog: !1, toneMapped: !1 })
            ),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.color = i),
              (this.type = "PointLightHelper"),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
          update() {
            void 0 !== this.color
              ? this.material.color.set(this.color)
              : this.material.color.copy(this.light.color);
          }
        }),
        (t.Points = lo),
        (t.PointsMaterial = no),
        (t.PolarGridHelper = class extends eo {
          constructor(t = 10, e = 16, i = 8, n = 64, r = 4473924, s = 8947848) {
            (r = new Ft(r)), (s = new Ft(s));
            const a = [],
              o = [];
            for (let i = 0; i <= e; i++) {
              const n = (i / e) * (2 * Math.PI),
                l = Math.sin(n) * t,
                h = Math.cos(n) * t;
              a.push(0, 0, 0), a.push(l, 0, h);
              const c = 1 & i ? r : s;
              o.push(c.r, c.g, c.b), o.push(c.r, c.g, c.b);
            }
            for (let e = 0; e <= i; e++) {
              const l = 1 & e ? r : s,
                h = t - (t / i) * e;
              for (let t = 0; t < n; t++) {
                let e = (t / n) * (2 * Math.PI),
                  i = Math.sin(e) * h,
                  r = Math.cos(e) * h;
                a.push(i, 0, r),
                  o.push(l.r, l.g, l.b),
                  (e = ((t + 1) / n) * (2 * Math.PI)),
                  (i = Math.sin(e) * h),
                  (r = Math.cos(e) * h),
                  a.push(i, 0, r),
                  o.push(l.r, l.g, l.b);
              }
            }
            const l = new Ii();
            l.setAttribute("position", new wi(a, 3)),
              l.setAttribute("color", new wi(o, 3)),
              super(l, new qa({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "PolarGridHelper");
          }
        }),
        (t.PolyhedronBufferGeometry = xo),
        (t.PolyhedronGeometry = xo),
        (t.PositionalAudio = class extends rc {
          constructor(t) {
            super(t),
              (this.panner = this.context.createPanner()),
              (this.panner.panningModel = "HRTF"),
              this.panner.connect(this.gain);
          }
          getOutput() {
            return this.panner;
          }
          getRefDistance() {
            return this.panner.refDistance;
          }
          setRefDistance(t) {
            return (this.panner.refDistance = t), this;
          }
          getRolloffFactor() {
            return this.panner.rolloffFactor;
          }
          setRolloffFactor(t) {
            return (this.panner.rolloffFactor = t), this;
          }
          getDistanceModel() {
            return this.panner.distanceModel;
          }
          setDistanceModel(t) {
            return (this.panner.distanceModel = t), this;
          }
          getMaxDistance() {
            return this.panner.maxDistance;
          }
          setMaxDistance(t) {
            return (this.panner.maxDistance = t), this;
          }
          setDirectionalCone(t, e, i) {
            return (
              (this.panner.coneInnerAngle = t),
              (this.panner.coneOuterAngle = e),
              (this.panner.coneOuterGain = i),
              this
            );
          }
          updateMatrixWorld(t) {
            if (
              (super.updateMatrixWorld(t),
              !0 === this.hasPlaybackControl && !1 === this.isPlaying)
            )
              return;
            this.matrixWorld.decompose(sc, ac, oc),
              lc.set(0, 0, 1).applyQuaternion(ac);
            const e = this.panner;
            if (e.positionX) {
              const t = this.context.currentTime + this.listener.timeDelta;
              e.positionX.linearRampToValueAtTime(sc.x, t),
                e.positionY.linearRampToValueAtTime(sc.y, t),
                e.positionZ.linearRampToValueAtTime(sc.z, t),
                e.orientationX.linearRampToValueAtTime(lc.x, t),
                e.orientationY.linearRampToValueAtTime(lc.y, t),
                e.orientationZ.linearRampToValueAtTime(lc.z, t);
            } else
              e.setPosition(sc.x, sc.y, sc.z),
                e.setOrientation(lc.x, lc.y, lc.z);
          }
        }),
        (t.PropertyBinding = _c),
        (t.PropertyMixer = cc),
        (t.QuadraticBezierCurve = ko),
        (t.QuadraticBezierCurve3 = Go),
        (t.Quaternion = Yt),
        (t.QuaternionKeyframeTrack = ih),
        (t.QuaternionLinearInterpolant = eh),
        (t.REVISION = e),
        (t.RGBADepthPacking = 3201),
        (t.RGBAFormat = T),
        (t.RGBAIntegerFormat = 1033),
        (t.RGBA_ASTC_10x10_Format = J),
        (t.RGBA_ASTC_10x5_Format = q),
        (t.RGBA_ASTC_10x6_Format = X),
        (t.RGBA_ASTC_10x8_Format = Y),
        (t.RGBA_ASTC_12x10_Format = Z),
        (t.RGBA_ASTC_12x12_Format = K),
        (t.RGBA_ASTC_4x4_Format = F),
        (t.RGBA_ASTC_5x4_Format = H),
        (t.RGBA_ASTC_5x5_Format = U),
        (t.RGBA_ASTC_6x5_Format = k),
        (t.RGBA_ASTC_6x6_Format = G),
        (t.RGBA_ASTC_8x5_Format = V),
        (t.RGBA_ASTC_8x6_Format = W),
        (t.RGBA_ASTC_8x8_Format = j),
        (t.RGBA_BPTC_Format = Q),
        (t.RGBA_ETC2_EAC_Format = B),
        (t.RGBA_PVRTC_2BPPV1_Format = N),
        (t.RGBA_PVRTC_4BPPV1_Format = D),
        (t.RGBA_S3TC_DXT1_Format = L),
        (t.RGBA_S3TC_DXT3_Format = C),
        (t.RGBA_S3TC_DXT5_Format = P),
        (t.RGBFormat = 1022),
        (t.RGB_ETC1_Format = 36196),
        (t.RGB_ETC2_Format = O),
        (t.RGB_PVRTC_2BPPV1_Format = z),
        (t.RGB_PVRTC_4BPPV1_Format = I),
        (t.RGB_S3TC_DXT1_Format = R),
        (t.RGFormat = 1030),
        (t.RGIntegerFormat = 1031),
        (t.RawShaderMaterial = Cn),
        (t.Ray = Te),
        (t.Raycaster = class {
          constructor(t, e, i = 0, n = 1 / 0) {
            (this.ray = new Te(t, e)),
              (this.near = i),
              (this.far = n),
              (this.camera = null),
              (this.layers = new Be()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          set(t, e) {
            this.ray.set(t, e);
          }
          setFromCamera(t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = e))
              : e && e.isOrthographicCamera
              ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(e.matrixWorld),
                (this.camera = e))
              : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + e.type
                );
          }
          intersectObject(t, e = !0, i = []) {
            return Rc(t, this, i, e), i.sort(Ac), i;
          }
          intersectObjects(t, e = !0, i = []) {
            for (let n = 0, r = t.length; n < r; n++) Rc(t[n], this, i, e);
            return i.sort(Ac), i;
          }
        }),
        (t.RectAreaLight = zh),
        (t.RedFormat = 1028),
        (t.RedIntegerFormat = 1029),
        (t.ReinhardToneMapping = 2),
        (t.RepeatWrapping = c),
        (t.ReplaceStencilOp = 7681),
        (t.ReverseSubtractEquation = 102),
        (t.RingBufferGeometry = El),
        (t.RingGeometry = El),
        (t.Scene = aa),
        (t.SceneUtils = ru),
        (t.ShaderChunk = _n),
        (t.ShaderLib = Mn),
        (t.ShaderMaterial = nn),
        (t.ShadowMaterial = Ol),
        (t.Shape = Xo),
        (t.ShapeBufferGeometry = Al),
        (t.ShapeGeometry = Al),
        (t.ShapePath = class {
          constructor() {
            (this.type = "ShapePath"),
              (this.color = new Ft()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(t, e) {
            return (
              (this.currentPath = new qo()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(t, e),
              this
            );
          }
          lineTo(t, e) {
            return this.currentPath.lineTo(t, e), this;
          }
          quadraticCurveTo(t, e, i, n) {
            return this.currentPath.quadraticCurveTo(t, e, i, n), this;
          }
          bezierCurveTo(t, e, i, n, r, s) {
            return this.currentPath.bezierCurveTo(t, e, i, n, r, s), this;
          }
          splineThru(t) {
            return this.currentPath.splineThru(t), this;
          }
          toShapes(t, e) {
            function i(t) {
              const e = [];
              for (let i = 0, n = t.length; i < n; i++) {
                const n = t[i],
                  r = new Xo();
                (r.curves = n.curves), e.push(r);
              }
              return e;
            }
            function n(t, e) {
              const i = e.length;
              let n = !1;
              for (let r = i - 1, s = 0; s < i; r = s++) {
                let i = e[r],
                  a = e[s],
                  o = a.x - i.x,
                  l = a.y - i.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (l < 0 && ((i = e[s]), (o = -o), (a = e[r]), (l = -l)),
                    t.y < i.y || t.y > a.y)
                  )
                    continue;
                  if (t.y === i.y) {
                    if (t.x === i.x) return !0;
                  } else {
                    const e = l * (t.x - i.x) - o * (t.y - i.y);
                    if (0 === e) return !0;
                    if (e < 0) continue;
                    n = !n;
                  }
                } else {
                  if (t.y !== i.y) continue;
                  if ((a.x <= t.x && t.x <= i.x) || (i.x <= t.x && t.x <= a.x))
                    return !0;
                }
              }
              return n;
            }
            const r = xl.isClockWise,
              s = this.subPaths;
            if (0 === s.length) return [];
            if (!0 === e) return i(s);
            let a, o, l;
            const h = [];
            if (1 === s.length)
              return (
                (o = s[0]), (l = new Xo()), (l.curves = o.curves), h.push(l), h
              );
            let c = !r(s[0].getPoints());
            c = t ? !c : c;
            const u = [],
              d = [];
            let p,
              m,
              f = [],
              g = 0;
            (d[g] = void 0), (f[g] = []);
            for (let e = 0, i = s.length; e < i; e++)
              (o = s[e]),
                (p = o.getPoints()),
                (a = r(p)),
                (a = t ? !a : a),
                a
                  ? (!c && d[g] && g++,
                    (d[g] = { s: new Xo(), p }),
                    (d[g].s.curves = o.curves),
                    c && g++,
                    (f[g] = []))
                  : f[g].push({ h: o, p: p[0] });
            if (!d[0]) return i(s);
            if (d.length > 1) {
              let t = !1;
              const e = [];
              for (let t = 0, e = d.length; t < e; t++) u[t] = [];
              for (let i = 0, r = d.length; i < r; i++) {
                const r = f[i];
                for (let s = 0; s < r.length; s++) {
                  const a = r[s];
                  let o = !0;
                  for (let r = 0; r < d.length; r++)
                    n(a.p, d[r].p) &&
                      (i !== r && e.push({ froms: i, tos: r, hole: s }),
                      o ? ((o = !1), u[r].push(a)) : (t = !0));
                  o && u[i].push(a);
                }
              }
              e.length > 0 && (t || (f = u));
            }
            for (let t = 0, e = d.length; t < e; t++) {
              (l = d[t].s), h.push(l), (m = f[t]);
              for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h);
            }
            return h;
          }
        }),
        (t.ShapeUtils = xl),
        (t.ShortType = 1011),
        (t.Skeleton = Ha),
        (t.SkeletonHelper = Fc),
        (t.SkinnedMesh = Da),
        (t.SmoothShading = 2),
        (t.Sphere = ye),
        (t.SphereBufferGeometry = Rl),
        (t.SphereGeometry = Rl),
        (t.Spherical = class {
          constructor(t = 1, e = 0, i = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = i), this;
          }
          set(t, e, i) {
            return (this.radius = t), (this.phi = e), (this.theta = i), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          }
          makeSafe() {
            const t = 1e-6;
            return (
              (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, i) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + i * i)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, i)),
                  (this.phi = Math.acos(vt(e / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }),
        (t.SphericalHarmonics3 = Dh),
        (t.SplineCurve = Vo),
        (t.SpotLight = Sh),
        (t.SpotLightHelper = class extends Ke {
          constructor(t, e) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = e);
            const i = new Ii(),
              n = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
              ];
            for (let t = 0, e = 1, i = 32; t < i; t++, e++) {
              const r = (t / i) * Math.PI * 2,
                s = (e / i) * Math.PI * 2;
              n.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1);
            }
            i.setAttribute("position", new wi(n, 3));
            const r = new qa({ fog: !1, toneMapped: !1 });
            (this.cone = new eo(i, r)), this.add(this.cone), this.update();
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
          }
          update() {
            this.light.updateMatrixWorld();
            const t = this.light.distance ? this.light.distance : 1e3,
              e = t * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, t),
              Dc.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(Dc),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          }
        }),
        (t.Sprite = Sa),
        (t.SpriteMaterial = ca),
        (t.SrcAlphaFactor = 204),
        (t.SrcAlphaSaturateFactor = 210),
        (t.SrcColorFactor = 202),
        (t.StaticCopyUsage = 35046),
        (t.StaticDrawUsage = ht),
        (t.StaticReadUsage = 35045),
        (t.StereoCamera = class {
          constructor() {
            (this.type = "StereoCamera"),
              (this.aspect = 1),
              (this.eyeSep = 0.064),
              (this.cameraL = new sn()),
              this.cameraL.layers.enable(1),
              (this.cameraL.matrixAutoUpdate = !1),
              (this.cameraR = new sn()),
              this.cameraR.layers.enable(2),
              (this.cameraR.matrixAutoUpdate = !1),
              (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
              });
          }
          update(t) {
            const e = this._cache;
            if (
              e.focus !== t.focus ||
              e.fov !== t.fov ||
              e.aspect !== t.aspect * this.aspect ||
              e.near !== t.near ||
              e.far !== t.far ||
              e.zoom !== t.zoom ||
              e.eyeSep !== this.eyeSep
            ) {
              (e.focus = t.focus),
                (e.fov = t.fov),
                (e.aspect = t.aspect * this.aspect),
                (e.near = t.near),
                (e.far = t.far),
                (e.zoom = t.zoom),
                (e.eyeSep = this.eyeSep),
                Kh.copy(t.projectionMatrix);
              const i = e.eyeSep / 2,
                n = (i * e.near) / e.focus,
                r = (e.near * Math.tan(gt * e.fov * 0.5)) / e.zoom;
              let s, a;
              (Zh.elements[12] = -i),
                (Jh.elements[12] = i),
                (s = -r * e.aspect + n),
                (a = r * e.aspect + n),
                (Kh.elements[0] = (2 * e.near) / (a - s)),
                (Kh.elements[8] = (a + s) / (a - s)),
                this.cameraL.projectionMatrix.copy(Kh),
                (s = -r * e.aspect - n),
                (a = r * e.aspect - n),
                (Kh.elements[0] = (2 * e.near) / (a - s)),
                (Kh.elements[8] = (a + s) / (a - s)),
                this.cameraR.projectionMatrix.copy(Kh);
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Zh),
              this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Jh);
          }
        }),
        (t.StreamCopyUsage = 35042),
        (t.StreamDrawUsage = 35040),
        (t.StreamReadUsage = 35041),
        (t.StringKeyframeTrack = nh),
        (t.SubtractEquation = 101),
        (t.SubtractiveBlending = 3),
        (t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }),
        (t.TangentSpaceNormalMap = 0),
        (t.TetrahedronBufferGeometry = Ll),
        (t.TetrahedronGeometry = Ll),
        (t.TextGeometry = function () {
          return (
            console.error(
              "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"
            ),
            new Ii()
          );
        }),
        (t.Texture = Gt),
        (t.TextureLoader = gh),
        (t.TorusBufferGeometry = Cl),
        (t.TorusGeometry = Cl),
        (t.TorusKnotBufferGeometry = Pl),
        (t.TorusKnotGeometry = Pl),
        (t.Triangle = li),
        (t.TriangleFanDrawMode = 2),
        (t.TriangleStripDrawMode = 1),
        (t.TrianglesDrawMode = 0),
        (t.TubeBufferGeometry = Il),
        (t.TubeGeometry = Il),
        (t.UVMapping = n),
        (t.Uint16Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
            ),
            new vi(t, e)
          );
        }),
        (t.Uint16BufferAttribute = vi),
        (t.Uint32Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
            ),
            new bi(t, e)
          );
        }),
        (t.Uint32BufferAttribute = bi),
        (t.Uint8Attribute = function (t, e) {
          return (
            console.warn(
              "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
            ),
            new gi(t, e)
          );
        }),
        (t.Uint8BufferAttribute = gi),
        (t.Uint8ClampedAttribute = function (t, e) {
          return (
            console.warn(
              "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
            ),
            new yi(t, e)
          );
        }),
        (t.Uint8ClampedBufferAttribute = yi),
        (t.Uniform = Sc),
        (t.UniformsLib = bn),
        (t.UniformsUtils = en),
        (t.UnsignedByteType = v),
        (t.UnsignedInt248Type = S),
        (t.UnsignedIntType = b),
        (t.UnsignedShort4444Type = 1017),
        (t.UnsignedShort5551Type = 1018),
        (t.UnsignedShortType = _),
        (t.VSMShadowMap = 3),
        (t.Vector2 = Et),
        (t.Vector3 = Jt),
        (t.Vector4 = Wt),
        (t.VectorKeyframeTrack = rh),
        (t.Vertex = function (t, e, i) {
          return (
            console.warn(
              "THREE.Vertex has been removed. Use THREE.Vector3 instead."
            ),
            new Jt(t, e, i)
          );
        }),
        (t.VertexColors = 2),
        (t.VideoTexture = co),
        (t.WebGL1Renderer = na),
        (t.WebGLCubeRenderTarget = hn),
        (t.WebGLMultipleRenderTargets = qt),
        (t.WebGLMultisampleRenderTarget = Xt),
        (t.WebGLRenderTarget = jt),
        (t.WebGLRenderTargetCube = function (t, e, i) {
          return (
            console.warn(
              "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
            ),
            new hn(t, i)
          );
        }),
        (t.WebGLRenderer = ia),
        (t.WebGLUtils = Ys),
        (t.WireframeGeometry = zl),
        (t.WireframeHelper = function (t, e) {
          return (
            console.warn(
              "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
            ),
            new eo(
              new zl(t.geometry),
              new qa({ color: void 0 !== e ? e : 16777215 })
            )
          );
        }),
        (t.WrapAroundEnding = rt),
        (t.XHRLoader = function (t) {
          return (
            console.warn(
              "THREE.XHRLoader has been renamed to THREE.FileLoader."
            ),
            new dh(t)
          );
        }),
        (t.ZeroCurvatureEnding = it),
        (t.ZeroFactor = 200),
        (t.ZeroSlopeEnding = nt),
        (t.ZeroStencilOp = 0),
        (t._SRGBAFormat = dt),
        (t.sRGBEncoding = ot),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    "object" == typeof exports && "undefined" != typeof module
      ? i(exports)
      : "function" == typeof define && define.amd
      ? define(["exports"], i)
      : i(
          ((e =
            "undefined" != typeof globalThis ? globalThis : e || self).THREE =
            {})
        );
  let n = (t, e = !1, i = 500, n = 0) => {
    const r = document.querySelector(t);
    if (r) {
      let s = "",
        a = 0;
      e &&
        ((s = "header.header"), (a = document.querySelector(s).offsetHeight));
      let o = {
        speedAsDuration: !0,
        speed: i,
        header: s,
        offset: n,
        easing: "easeOutQuad",
      };
      if (
        (document.documentElement.classList.contains("menu-open") && qr(),
        "undefined" != typeof SmoothScroll)
      )
        new SmoothScroll().animateScroll(r, "", o);
      else {
        let t = r.getBoundingClientRect().top + scrollY;
        window.scrollTo({ top: a ? t - a : t, behavior: "smooth" });
      }
      Xr(`[gotoBlock]: Юхуу...едем к ${t}`);
    } else Xr(`[gotoBlock]: Ой ой..Такого блока нет на странице: ${t}`);
  };
  const r = { inputMaskModule: null, selectModule: null };
  let s = {
    getErrors(t) {
      let e = 0,
        i = t.querySelectorAll("*[data-required]");
      return (
        i.length &&
          i.forEach((t) => {
            (null === t.offsetParent && "SELECT" !== t.tagName) ||
              t.disabled ||
              (e += this.validateInput(t));
          }),
        e
      );
    },
    validateInput(t) {
      let e = 0;
      return (
        "email" === t.dataset.required
          ? ((t.value = t.value.replace(" ", "")),
            this.emailTest(t) ? (this.addError(t), e++) : this.removeError(t))
          : ("checkbox" !== t.type || t.checked) && t.value
          ? this.removeError(t)
          : (this.addError(t), e++),
        e
      );
    },
    addError(t) {
      t.classList.add("_form-error"),
        t.parentElement.classList.add("_form-error");
      let e = t.parentElement.querySelector(".form__error");
      e && t.parentElement.removeChild(e),
        t.dataset.error &&
          t.parentElement.insertAdjacentHTML(
            "beforeend",
            `<div class="form__error">${t.dataset.error}</div>`
          );
    },
    removeError(t) {
      t.classList.remove("_form-error"),
        t.parentElement.classList.remove("_form-error"),
        t.parentElement.querySelector(".form__error") &&
          t.parentElement.removeChild(
            t.parentElement.querySelector(".form__error")
          );
    },
    formClean(t) {
      t.reset(),
        setTimeout(() => {
          let e = t.querySelectorAll("input,textarea");
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.parentElement.classList.remove("_form-focus"),
              i.classList.remove("_form-focus"),
              s.removeError(i),
              (i.value = i.dataset.placeholder);
          }
          let i = t.querySelectorAll(".checkbox__input");
          if (i.length > 0)
            for (let t = 0; t < i.length; t++) {
              i[t].checked = !1;
            }
          if (r.selectModule) {
            let e = t.querySelectorAll(".select");
            if (e.length)
              for (let t = 0; t < e.length; t++) {
                const i = e[t].querySelector("select");
                r.selectModule.selectBuild(i);
              }
          }
        }, 0);
    },
    emailTest: (t) =>
      !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(t.value),
  };
  function a() {
    const t = document.querySelectorAll(".rating");
    t.length > 0 &&
      (function () {
        let e, i;
        for (let e = 0; e < t.length; e++) {
          n(t[e]);
        }
        function n(t) {
          r(t), s(), t.classList.contains("rating_set") && a(t);
        }
        function r(t) {
          (e = t.querySelector(".rating__active")),
            (i = t.querySelector(".rating__value"));
        }
        function s(t = i.innerHTML) {
          const n = t / 0.05;
          e.style.width = `${n}%`;
        }
        function a(t) {
          const e = t.querySelectorAll(".rating__item");
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            a.addEventListener("mouseenter", function (e) {
              r(t), s(a.value);
            }),
              a.addEventListener("mouseleave", function (t) {
                s();
              }),
              a.addEventListener("click", function (e) {
                r(t),
                  t.dataset.ajax ? o(a.value, t) : ((i.innerHTML = n + 1), s());
              });
          }
        }
        async function o(t, e) {
          if (!e.classList.contains("rating_sending")) {
            e.classList.add("rating_sending");
            let t = await fetch("rating.json", { method: "GET" });
            if (t.ok) {
              const n = (await t.json()).newRating;
              (i.innerHTML = n), s(), e.classList.remove("rating_sending");
            } else alert("Ошибка"), e.classList.remove("rating_sending");
          }
        }
      })();
  }
  const o = [];
  for (let t = 0; t < 256; t++) o[t] = (t < 16 ? "0" : "") + t.toString(16);
  const l = Math.PI / 180,
    h = 180 / Math.PI;
  function c() {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0;
    return (
      o[255 & t] +
      o[(t >> 8) & 255] +
      o[(t >> 16) & 255] +
      o[(t >> 24) & 255] +
      "-" +
      o[255 & e] +
      o[(e >> 8) & 255] +
      "-" +
      o[((e >> 16) & 15) | 64] +
      o[(e >> 24) & 255] +
      "-" +
      o[(63 & i) | 128] +
      o[(i >> 8) & 255] +
      "-" +
      o[(i >> 16) & 255] +
      o[(i >> 24) & 255] +
      o[255 & n] +
      o[(n >> 8) & 255] +
      o[(n >> 16) & 255] +
      o[(n >> 24) & 255]
    ).toUpperCase();
  }
  function u(t, e, i) {
    return Math.max(e, Math.min(i, t));
  }
  function d(t, e) {
    return ((t % e) + e) % e;
  }
  function p(t, e, i) {
    return (1 - i) * t + i * e;
  }
  class m {
    constructor(t = 0, e = 0, i = 0, n = 1) {
      (this._x = t), (this._y = e), (this._z = i), (this._w = n);
    }
    static slerp(t, e, i, n) {
      return (
        console.warn(
          "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
        ),
        i.slerpQuaternions(t, e, n)
      );
    }
    static slerpFlat(t, e, i, n, r, s, a) {
      let o = i[n + 0],
        l = i[n + 1],
        h = i[n + 2],
        c = i[n + 3];
      const u = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        m = r[s + 3];
      if (0 === a)
        return (
          (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = h), void (t[e + 3] = c)
        );
      if (1 === a)
        return (
          (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = m)
        );
      if (c !== m || o !== u || l !== d || h !== p) {
        let t = 1 - a;
        const e = o * u + l * d + h * p + c * m,
          i = e >= 0 ? 1 : -1,
          n = 1 - e * e;
        if (n > Number.EPSILON) {
          const r = Math.sqrt(n),
            s = Math.atan2(r, e * i);
          (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
        }
        const r = a * i;
        if (
          ((o = o * t + u * r),
          (l = l * t + d * r),
          (h = h * t + p * r),
          (c = c * t + m * r),
          t === 1 - a)
        ) {
          const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
          (o *= t), (l *= t), (h *= t), (c *= t);
        }
      }
      (t[e] = o), (t[e + 1] = l), (t[e + 2] = h), (t[e + 3] = c);
    }
    static multiplyQuaternionsFlat(t, e, i, n, r, s) {
      const a = i[n],
        o = i[n + 1],
        l = i[n + 2],
        h = i[n + 3],
        c = r[s],
        u = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return (
        (t[e] = a * p + h * c + o * d - l * u),
        (t[e + 1] = o * p + h * u + l * c - a * d),
        (t[e + 2] = l * p + h * d + a * u - o * c),
        (t[e + 3] = h * p - a * c - o * u - l * d),
        t
      );
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      (this._w = t), this._onChangeCallback();
    }
    set(t, e, i, n) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = i),
        (this._w = n),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(t, e) {
      if (!t || !t.isEuler)
        throw new Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      const i = t._x,
        n = t._y,
        r = t._z,
        s = t._order,
        a = Math.cos,
        o = Math.sin,
        l = a(i / 2),
        h = a(n / 2),
        c = a(r / 2),
        u = o(i / 2),
        d = o(n / 2),
        p = o(r / 2);
      switch (s) {
        case "XYZ":
          (this._x = u * h * c + l * d * p),
            (this._y = l * d * c - u * h * p),
            (this._z = l * h * p + u * d * c),
            (this._w = l * h * c - u * d * p);
          break;
        case "YXZ":
          (this._x = u * h * c + l * d * p),
            (this._y = l * d * c - u * h * p),
            (this._z = l * h * p - u * d * c),
            (this._w = l * h * c + u * d * p);
          break;
        case "ZXY":
          (this._x = u * h * c - l * d * p),
            (this._y = l * d * c + u * h * p),
            (this._z = l * h * p + u * d * c),
            (this._w = l * h * c - u * d * p);
          break;
        case "ZYX":
          (this._x = u * h * c - l * d * p),
            (this._y = l * d * c + u * h * p),
            (this._z = l * h * p - u * d * c),
            (this._w = l * h * c + u * d * p);
          break;
        case "YZX":
          (this._x = u * h * c + l * d * p),
            (this._y = l * d * c + u * h * p),
            (this._z = l * h * p - u * d * c),
            (this._w = l * h * c - u * d * p);
          break;
        case "XZY":
          (this._x = u * h * c - l * d * p),
            (this._y = l * d * c - u * h * p),
            (this._z = l * h * p + u * d * c),
            (this._w = l * h * c + u * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              s
          );
      }
      return !1 !== e && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const i = e / 2,
        n = Math.sin(i);
      return (
        (this._x = t.x * n),
        (this._y = t.y * n),
        (this._z = t.z * n),
        (this._w = Math.cos(i)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t) {
      const e = t.elements,
        i = e[0],
        n = e[4],
        r = e[8],
        s = e[1],
        a = e[5],
        o = e[9],
        l = e[2],
        h = e[6],
        c = e[10],
        u = i + a + c;
      if (u > 0) {
        const t = 0.5 / Math.sqrt(u + 1);
        (this._w = 0.25 / t),
          (this._x = (h - o) * t),
          (this._y = (r - l) * t),
          (this._z = (s - n) * t);
      } else if (i > a && i > c) {
        const t = 2 * Math.sqrt(1 + i - a - c);
        (this._w = (h - o) / t),
          (this._x = 0.25 * t),
          (this._y = (n + s) / t),
          (this._z = (r + l) / t);
      } else if (a > c) {
        const t = 2 * Math.sqrt(1 + a - i - c);
        (this._w = (r - l) / t),
          (this._x = (n + s) / t),
          (this._y = 0.25 * t),
          (this._z = (o + h) / t);
      } else {
        const t = 2 * Math.sqrt(1 + c - i - a);
        (this._w = (s - n) / t),
          (this._x = (r + l) / t),
          (this._y = (o + h) / t),
          (this._z = 0.25 * t);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let i = t.dot(e) + 1;
      return (
        i < Number.EPSILON
          ? ((i = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = i))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = i)))
          : ((this._x = t.y * e.z - t.z * e.y),
            (this._y = t.z * e.x - t.x * e.z),
            (this._z = t.x * e.y - t.y * e.x),
            (this._w = i)),
        this.normalize()
      );
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(u(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const i = this.angleTo(t);
      if (0 === i) return this;
      const n = Math.min(1, e / i);
      return this.slerp(t, n), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let t = this.length();
      return (
        0 === t
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
          ),
          this.multiplyQuaternions(t, e))
        : this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const i = t._x,
        n = t._y,
        r = t._z,
        s = t._w,
        a = e._x,
        o = e._y,
        l = e._z,
        h = e._w;
      return (
        (this._x = i * h + s * a + n * l - r * o),
        (this._y = n * h + s * o + r * a - i * l),
        (this._z = r * h + s * l + i * o - n * a),
        (this._w = s * h - i * a - n * o - r * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const i = this._x,
        n = this._y,
        r = this._z,
        s = this._w;
      let a = s * t._w + i * t._x + n * t._y + r * t._z;
      if (
        (a < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (a = -a))
          : this.copy(t),
        a >= 1)
      )
        return (this._w = s), (this._x = i), (this._y = n), (this._z = r), this;
      const o = 1 - a * a;
      if (o <= Number.EPSILON) {
        const t = 1 - e;
        return (
          (this._w = t * s + e * this._w),
          (this._x = t * i + e * this._x),
          (this._y = t * n + e * this._y),
          (this._z = t * r + e * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      }
      const l = Math.sqrt(o),
        h = Math.atan2(l, a),
        c = Math.sin((1 - e) * h) / l,
        u = Math.sin(e * h) / l;
      return (
        (this._w = s * c + this._w * u),
        (this._x = i * c + this._x * u),
        (this._y = n * c + this._y * u),
        (this._z = r * c + this._z * u),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(t, e, i) {
      return this.copy(t).slerp(e, i);
    }
    random() {
      const t = Math.random(),
        e = Math.sqrt(1 - t),
        i = Math.sqrt(t),
        n = 2 * Math.PI * Math.random(),
        r = 2 * Math.PI * Math.random();
      return this.set(
        e * Math.cos(n),
        i * Math.sin(r),
        i * Math.cos(r),
        e * Math.sin(n)
      );
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this._x = t[e]),
        (this._y = t[e + 1]),
        (this._z = t[e + 2]),
        (this._w = t[e + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this._x = t.getX(e)),
        (this._y = t.getY(e)),
        (this._z = t.getZ(e)),
        (this._w = t.getW(e)),
        this
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
  }
  m.prototype.isQuaternion = !0;
  const f = 1e3,
    g = 1001,
    y = 1002,
    x = 1003,
    v = 1006,
    _ = 1008,
    b = 2300,
    M = 2301,
    w = 2302,
    S = 3001,
    T = 7680,
    E = 35044,
    A = {
      arraySlice: function (t, e, i) {
        return A.isTypedArray(t)
          ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length))
          : t.slice(e, i);
      },
      convertArray: function (t, e, i) {
        return !t || (!i && t.constructor === e)
          ? t
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      },
      isTypedArray: function (t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      },
      getKeyframeOrder: function (t) {
        const e = t.length,
          i = new Array(e);
        for (let t = 0; t !== e; ++t) i[t] = t;
        return (
          i.sort(function (e, i) {
            return t[e] - t[i];
          }),
          i
        );
      },
      sortedArray: function (t, e, i) {
        const n = t.length,
          r = new t.constructor(n);
        for (let s = 0, a = 0; a !== n; ++s) {
          const n = i[s] * e;
          for (let i = 0; i !== e; ++i) r[a++] = t[n + i];
        }
        return r;
      },
      flattenJSON: function (t, e, i, n) {
        let r = 1,
          s = t[0];
        for (; void 0 !== s && void 0 === s[n]; ) s = t[r++];
        if (void 0 === s) return;
        let a = s[n];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = s[n]),
                void 0 !== a && (e.push(s.time), i.push.apply(i, a)),
                (s = t[r++]);
            } while (void 0 !== s);
          else if (void 0 !== a.toArray)
            do {
              (a = s[n]),
                void 0 !== a && (e.push(s.time), a.toArray(i, i.length)),
                (s = t[r++]);
            } while (void 0 !== s);
          else
            do {
              (a = s[n]),
                void 0 !== a && (e.push(s.time), i.push(a)),
                (s = t[r++]);
            } while (void 0 !== s);
      },
      subclip: function (t, e, i, n, r = 30) {
        const s = t.clone();
        s.name = e;
        const a = [];
        for (let t = 0; t < s.tracks.length; ++t) {
          const e = s.tracks[t],
            o = e.getValueSize(),
            l = [],
            h = [];
          for (let t = 0; t < e.times.length; ++t) {
            const s = e.times[t] * r;
            if (!(s < i || s >= n)) {
              l.push(e.times[t]);
              for (let i = 0; i < o; ++i) h.push(e.values[t * o + i]);
            }
          }
          0 !== l.length &&
            ((e.times = A.convertArray(l, e.times.constructor)),
            (e.values = A.convertArray(h, e.values.constructor)),
            a.push(e));
        }
        s.tracks = a;
        let o = 1 / 0;
        for (let t = 0; t < s.tracks.length; ++t)
          o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
        return s.resetDuration(), s;
      },
      makeClipAdditive: function (t, e = 0, i = t, n = 30) {
        n <= 0 && (n = 30);
        const r = i.tracks.length,
          s = e / n;
        for (let e = 0; e < r; ++e) {
          const n = i.tracks[e],
            r = n.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const a = t.tracks.find(function (t) {
            return t.name === n.name && t.ValueTypeName === r;
          });
          if (void 0 === a) continue;
          let o = 0;
          const l = n.getValueSize();
          n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (o = l / 3);
          let h = 0;
          const c = a.getValueSize();
          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (h = c / 3);
          const u = n.times.length - 1;
          let d;
          if (s <= n.times[0]) {
            const t = o,
              e = l - o;
            d = A.arraySlice(n.values, t, e);
          } else if (s >= n.times[u]) {
            const t = u * l + o,
              e = t + l - o;
            d = A.arraySlice(n.values, t, e);
          } else {
            const t = n.createInterpolant(),
              e = o,
              i = l - o;
            t.evaluate(s), (d = A.arraySlice(t.resultBuffer, e, i));
          }
          if ("quaternion" === r) {
            new m().fromArray(d).normalize().conjugate().toArray(d);
          }
          const p = a.times.length;
          for (let t = 0; t < p; ++t) {
            const e = t * c + h;
            if ("quaternion" === r)
              m.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
            else {
              const t = c - 2 * h;
              for (let i = 0; i < t; ++i) a.values[e + i] -= d[i];
            }
          }
        }
        return (t.blendMode = 2501), t;
      },
    };
  class R {
    constructor(t, e, i, n) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
        (this.sampleValues = e),
        (this.valueSize = i),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let i = this._cachedIndex,
        n = e[i],
        r = e[i - 1];
      t: {
        e: {
          let s;
          i: {
            n: if (!(t < n)) {
              for (let s = i + 2; ; ) {
                if (void 0 === n) {
                  if (t < r) break n;
                  return (
                    (i = e.length),
                    (this._cachedIndex = i),
                    this.afterEnd_(i - 1, t, r)
                  );
                }
                if (i === s) break;
                if (((r = n), (n = e[++i]), t < n)) break e;
              }
              s = e.length;
              break i;
            }
            if (t >= r) break t;
            {
              const a = e[1];
              t < a && ((i = 2), (r = a));
              for (let s = i - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
                if (i === s) break;
                if (((n = r), (r = e[--i - 1]), t >= r)) break e;
              }
              (s = i), (i = 0);
            }
          }
          for (; i < s; ) {
            const n = (i + s) >>> 1;
            t < e[n] ? (s = n) : (i = n + 1);
          }
          if (((n = e[i]), (r = e[i - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
          if (void 0 === n)
            return (
              (i = e.length),
              (this._cachedIndex = i),
              this.afterEnd_(i - 1, r, t)
            );
        }
        (this._cachedIndex = i), this.intervalChanged_(i, r, n);
      }
      return this.interpolate_(i, r, t, n);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        i = this.sampleValues,
        n = this.valueSize,
        r = t * n;
      for (let t = 0; t !== n; ++t) e[t] = i[r + t];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  (R.prototype.beforeStart_ = R.prototype.copySampleValue_),
    (R.prototype.afterEnd_ = R.prototype.copySampleValue_);
  class L extends R {
    constructor(t, e, i, n) {
      super(t, e, i, n),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
    }
    intervalChanged_(t, e, i) {
      const n = this.parameterPositions;
      let r = t - 2,
        s = t + 1,
        a = n[r],
        o = n[s];
      if (void 0 === a)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (r = t), (a = 2 * e - i);
            break;
          case 2402:
            (r = n.length - 2), (a = e + n[r] - n[r + 1]);
            break;
          default:
            (r = t), (a = i);
        }
      if (void 0 === o)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (s = t), (o = 2 * i - e);
            break;
          case 2402:
            (s = 1), (o = i + n[1] - n[0]);
            break;
          default:
            (s = t - 1), (o = e);
        }
      const l = 0.5 * (i - e),
        h = this.valueSize;
      (this._weightPrev = l / (e - a)),
        (this._weightNext = l / (o - i)),
        (this._offsetPrev = r * h),
        (this._offsetNext = s * h);
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        h = this._offsetPrev,
        c = this._offsetNext,
        u = this._weightPrev,
        d = this._weightNext,
        p = (i - e) / (n - e),
        m = p * p,
        f = m * p,
        g = -u * f + 2 * u * m - u * p,
        y = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
        x = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
        v = d * f - d * m;
      for (let t = 0; t !== a; ++t)
        r[t] = g * s[h + t] + y * s[l + t] + x * s[o + t] + v * s[c + t];
      return r;
    }
  }
  class C extends R {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        h = (i - e) / (n - e),
        c = 1 - h;
      for (let t = 0; t !== a; ++t) r[t] = s[l + t] * c + s[o + t] * h;
      return r;
    }
  }
  class P extends R {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class I {
    constructor(t, e, i, n) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = A.convertArray(e, this.TimeBufferType)),
        (this.values = A.convertArray(i, this.ValueBufferType)),
        this.setInterpolation(n || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let i;
      if (e.toJSON !== this.toJSON) i = e.toJSON(t);
      else {
        i = {
          name: t.name,
          times: A.convertArray(t.times, Array),
          values: A.convertArray(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (i.interpolation = e);
      }
      return (i.type = t.ValueTypeName), i;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new P(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new C(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new L(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case b:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case M:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case w:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return b;
        case this.InterpolantFactoryMethodLinear:
          return M;
        case this.InterpolantFactoryMethodSmooth:
          return w;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
      }
      return this;
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
      }
      return this;
    }
    trim(t, e) {
      const i = this.times,
        n = i.length;
      let r = 0,
        s = n - 1;
      for (; r !== n && i[r] < t; ) ++r;
      for (; -1 !== s && i[s] > e; ) --s;
      if ((++s, 0 !== r || s !== n)) {
        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
        const t = this.getValueSize();
        (this.times = A.arraySlice(i, r, s)),
          (this.values = A.arraySlice(this.values, r * t, s * t));
      }
      return this;
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (t = !1));
      const i = this.times,
        n = this.values,
        r = i.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let s = null;
      for (let e = 0; e !== r; e++) {
        const n = i[e];
        if ("number" == typeof n && isNaN(n)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            e,
            n
          ),
            (t = !1);
          break;
        }
        if (null !== s && s > n) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            e,
            n,
            s
          ),
            (t = !1);
          break;
        }
        s = n;
      }
      if (void 0 !== n && A.isTypedArray(n))
        for (let e = 0, i = n.length; e !== i; ++e) {
          const i = n[e];
          if (isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              e,
              i
            ),
              (t = !1);
            break;
          }
        }
      return t;
    }
    optimize() {
      const t = A.arraySlice(this.times),
        e = A.arraySlice(this.values),
        i = this.getValueSize(),
        n = this.getInterpolation() === w,
        r = t.length - 1;
      let s = 1;
      for (let a = 1; a < r; ++a) {
        let r = !1;
        const o = t[a];
        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
          if (n) r = !0;
          else {
            const t = a * i,
              n = t - i,
              s = t + i;
            for (let a = 0; a !== i; ++a) {
              const i = e[t + a];
              if (i !== e[n + a] || i !== e[s + a]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (a !== s) {
            t[s] = t[a];
            const n = a * i,
              r = s * i;
            for (let t = 0; t !== i; ++t) e[r + t] = e[n + t];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (let t = r * i, n = s * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
        ++s;
      }
      return (
        s !== t.length
          ? ((this.times = A.arraySlice(t, 0, s)),
            (this.values = A.arraySlice(e, 0, s * i)))
          : ((this.times = t), (this.values = e)),
        this
      );
    }
    clone() {
      const t = A.arraySlice(this.times, 0),
        e = A.arraySlice(this.values, 0),
        i = new (0, this.constructor)(this.name, t, e);
      return (i.createInterpolant = this.createInterpolant), i;
    }
  }
  (I.prototype.TimeBufferType = Float32Array),
    (I.prototype.ValueBufferType = Float32Array),
    (I.prototype.DefaultInterpolation = M);
  class z extends I {}
  (z.prototype.ValueTypeName = "bool"),
    (z.prototype.ValueBufferType = Array),
    (z.prototype.DefaultInterpolation = b),
    (z.prototype.InterpolantFactoryMethodLinear = void 0),
    (z.prototype.InterpolantFactoryMethodSmooth = void 0);
  class D extends I {}
  D.prototype.ValueTypeName = "color";
  class N extends I {}
  N.prototype.ValueTypeName = "number";
  class O extends R {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = (i - e) / (n - e);
      let l = t * a;
      for (let t = l + a; l !== t; l += 4) m.slerpFlat(r, 0, s, l - a, s, l, o);
      return r;
    }
  }
  class B extends I {
    InterpolantFactoryMethodLinear(t) {
      return new O(this.times, this.values, this.getValueSize(), t);
    }
  }
  (B.prototype.ValueTypeName = "quaternion"),
    (B.prototype.DefaultInterpolation = M),
    (B.prototype.InterpolantFactoryMethodSmooth = void 0);
  class F extends I {}
  (F.prototype.ValueTypeName = "string"),
    (F.prototype.ValueBufferType = Array),
    (F.prototype.DefaultInterpolation = b),
    (F.prototype.InterpolantFactoryMethodLinear = void 0),
    (F.prototype.InterpolantFactoryMethodSmooth = void 0);
  class H extends I {}
  H.prototype.ValueTypeName = "vector";
  class U {
    constructor(t, e = -1, i, n = 2500) {
      (this.name = t),
        (this.tracks = i),
        (this.duration = e),
        (this.blendMode = n),
        (this.uuid = c()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      const e = [],
        i = t.tracks,
        n = 1 / (t.fps || 1);
      for (let t = 0, r = i.length; t !== r; ++t) e.push(k(i[t]).scale(n));
      const r = new this(t.name, t.duration, e, t.blendMode);
      return (r.uuid = t.uuid), r;
    }
    static toJSON(t) {
      const e = [],
        i = t.tracks,
        n = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode,
        };
      for (let t = 0, n = i.length; t !== n; ++t) e.push(I.toJSON(i[t]));
      return n;
    }
    static CreateFromMorphTargetSequence(t, e, i, n) {
      const r = e.length,
        s = [];
      for (let t = 0; t < r; t++) {
        let a = [],
          o = [];
        a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
        const l = A.getKeyframeOrder(a);
        (a = A.sortedArray(a, 1, l)),
          (o = A.sortedArray(o, 1, l)),
          n || 0 !== a[0] || (a.push(r), o.push(o[0])),
          s.push(
            new N(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(
              1 / i
            )
          );
      }
      return new this(t, -1, s);
    }
    static findByName(t, e) {
      let i = t;
      if (!Array.isArray(t)) {
        const e = t;
        i = (e.geometry && e.geometry.animations) || e.animations;
      }
      for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, i) {
      const n = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e],
          s = i.name.match(r);
        if (s && s.length > 1) {
          const t = s[1];
          let e = n[t];
          e || (n[t] = e = []), e.push(i);
        }
      }
      const s = [];
      for (const t in n)
        s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
      return s;
    }
    static parseAnimation(t, e) {
      if (!t)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      const i = function (t, e, i, n, r) {
          if (0 !== i.length) {
            const s = [],
              a = [];
            A.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a));
          }
        },
        n = [],
        r = t.name || "default",
        s = t.fps || 30,
        a = t.blendMode;
      let o = t.length || -1;
      const l = t.hierarchy || [];
      for (let t = 0; t < l.length; t++) {
        const r = l[t].keys;
        if (r && 0 !== r.length)
          if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++)
              if (r[e].morphTargets)
                for (let i = 0; i < r[e].morphTargets.length; i++)
                  t[r[e].morphTargets[i]] = -1;
            for (const i in t) {
              const t = [],
                s = [];
              for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                const n = r[e];
                t.push(n.time), s.push(n.morphTarget === i ? 1 : 0);
              }
              n.push(new N(".morphTargetInfluence[" + i + "]", t, s));
            }
            o = t.length * (s || 1);
          } else {
            const s = ".bones[" + e[t].name + "]";
            i(H, s + ".position", r, "pos", n),
              i(B, s + ".quaternion", r, "rot", n),
              i(H, s + ".scale", r, "scl", n);
          }
      }
      if (0 === n.length) return null;
      return new this(r, o, n, a);
    }
    resetDuration() {
      let t = 0;
      for (let e = 0, i = this.tracks.length; e !== i; ++e) {
        const i = this.tracks[e];
        t = Math.max(t, i.times[i.times.length - 1]);
      }
      return (this.duration = t), this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function k(t) {
    if (void 0 === t.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    const e = (function (t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return N;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return H;
        case "color":
          return D;
        case "quaternion":
          return B;
        case "bool":
        case "boolean":
          return z;
        case "string":
          return F;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    })(t.type);
    if (void 0 === t.times) {
      const e = [],
        i = [];
      A.flattenJSON(t.keys, e, i, "value"), (t.times = e), (t.values = i);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  class G {
    constructor(t = 0, e = 0, i = 0) {
      (this.x = t), (this.y = e), (this.z = i);
    }
    set(t, e, i) {
      return (
        void 0 === i && (i = this.z),
        (this.x = t),
        (this.y = e),
        (this.z = i),
        this
      );
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    }
    add(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(t, e))
        : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    }
    sub(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(t, e))
        : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    }
    multiply(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
          ),
          this.multiplyVectors(t, e))
        : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    }
    multiplyVectors(t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    }
    applyEuler(t) {
      return (
        (t && t.isEuler) ||
          console.error(
            "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
          ),
        this.applyQuaternion(W.setFromEuler(t))
      );
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(W.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x,
        i = this.y,
        n = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * i + r[6] * n),
        (this.y = r[1] * e + r[4] * i + r[7] * n),
        (this.z = r[2] * e + r[5] * i + r[8] * n),
        this
      );
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x,
        i = this.y,
        n = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s),
        (this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s),
        (this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s),
        this
      );
    }
    applyQuaternion(t) {
      const e = this.x,
        i = this.y,
        n = this.z,
        r = t.x,
        s = t.y,
        a = t.z,
        o = t.w,
        l = o * e + s * n - a * i,
        h = o * i + a * e - r * n,
        c = o * n + r * i - s * e,
        u = -r * e - s * i - a * n;
      return (
        (this.x = l * o + u * -r + h * -a - c * -s),
        (this.y = h * o + u * -s + c * -r - l * -a),
        (this.z = c * o + u * -a + l * -s - h * -r),
        this
      );
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld
      );
    }
    transformDirection(t) {
      const e = this.x,
        i = this.y,
        n = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * i + r[8] * n),
        (this.y = r[1] * e + r[5] * i + r[9] * n),
        (this.z = r[2] * e + r[6] * i + r[10] * n),
        this.normalize()
      );
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    }
    lerpVectors(t, e, i) {
      return (
        (this.x = t.x + (e.x - t.x) * i),
        (this.y = t.y + (e.y - t.y) * i),
        (this.z = t.z + (e.z - t.z) * i),
        this
      );
    }
    cross(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
          ),
          this.crossVectors(t, e))
        : this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const i = t.x,
        n = t.y,
        r = t.z,
        s = e.x,
        a = e.y,
        o = e.z;
      return (
        (this.x = n * o - r * a),
        (this.y = r * s - i * o),
        (this.z = i * a - n * s),
        this
      );
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const i = t.dot(this) / e;
      return this.copy(t).multiplyScalar(i);
    }
    projectOnPlane(t) {
      return V.copy(this).projectOnVector(t), this.sub(V);
    }
    reflect(t) {
      return this.sub(V.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const i = this.dot(t) / e;
      return Math.acos(u(i, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        i = this.y - t.y,
        n = this.z - t.z;
      return e * e + i * i + n * n;
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, i) {
      const n = Math.sin(e) * t;
      return (
        (this.x = n * Math.sin(i)),
        (this.y = Math.cos(e) * t),
        (this.z = n * Math.cos(i)),
        this
      );
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, i) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = i),
        (this.z = t * Math.cos(e)),
        this
      );
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(),
        i = this.setFromMatrixColumn(t, 1).length(),
        n = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = i), (this.z = n), this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
    }
    fromBufferAttribute(t, e, i) {
      return (
        void 0 !== i &&
          console.warn(
            "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const t = 2 * (Math.random() - 0.5),
        e = Math.random() * Math.PI * 2,
        i = Math.sqrt(1 - t ** 2);
      return (
        (this.x = i * Math.cos(e)),
        (this.y = i * Math.sin(e)),
        (this.z = t),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  G.prototype.isVector3 = !0;
  const V = new G(),
    W = new m();
  class j {
    constructor() {
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
      const g = this.elements;
      return (
        (g[0] = t),
        (g[4] = e),
        (g[8] = i),
        (g[12] = n),
        (g[1] = r),
        (g[5] = s),
        (g[9] = a),
        (g[13] = o),
        (g[2] = l),
        (g[6] = h),
        (g[10] = c),
        (g[14] = u),
        (g[3] = d),
        (g[7] = p),
        (g[11] = m),
        (g[15] = f),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new j().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements,
        i = t.elements;
      return (
        (e[0] = i[0]),
        (e[1] = i[1]),
        (e[2] = i[2]),
        (e[3] = i[3]),
        (e[4] = i[4]),
        (e[5] = i[5]),
        (e[6] = i[6]),
        (e[7] = i[7]),
        (e[8] = i[8]),
        (e[9] = i[9]),
        (e[10] = i[10]),
        (e[11] = i[11]),
        (e[12] = i[12]),
        (e[13] = i[13]),
        (e[14] = i[14]),
        (e[15] = i[15]),
        this
      );
    }
    copyPosition(t) {
      const e = this.elements,
        i = t.elements;
      return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return (
        this.set(
          e[0],
          e[3],
          e[6],
          0,
          e[1],
          e[4],
          e[7],
          0,
          e[2],
          e[5],
          e[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(t, e, i) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(t, e, i) {
      return (
        this.set(
          t.x,
          e.x,
          i.x,
          0,
          t.y,
          e.y,
          i.y,
          0,
          t.z,
          e.z,
          i.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(t) {
      const e = this.elements,
        i = t.elements,
        n = 1 / q.setFromMatrixColumn(t, 0).length(),
        r = 1 / q.setFromMatrixColumn(t, 1).length(),
        s = 1 / q.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = i[0] * n),
        (e[1] = i[1] * n),
        (e[2] = i[2] * n),
        (e[3] = 0),
        (e[4] = i[4] * r),
        (e[5] = i[5] * r),
        (e[6] = i[6] * r),
        (e[7] = 0),
        (e[8] = i[8] * s),
        (e[9] = i[9] * s),
        (e[10] = i[10] * s),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromEuler(t) {
      (t && t.isEuler) ||
        console.error(
          "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
        );
      const e = this.elements,
        i = t.x,
        n = t.y,
        r = t.z,
        s = Math.cos(i),
        a = Math.sin(i),
        o = Math.cos(n),
        l = Math.sin(n),
        h = Math.cos(r),
        c = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = s * h,
          i = s * c,
          n = a * h,
          r = a * c;
        (e[0] = o * h),
          (e[4] = -o * c),
          (e[8] = l),
          (e[1] = i + n * l),
          (e[5] = t - r * l),
          (e[9] = -a * o),
          (e[2] = r - t * l),
          (e[6] = n + i * l),
          (e[10] = s * o);
      } else if ("YXZ" === t.order) {
        const t = o * h,
          i = o * c,
          n = l * h,
          r = l * c;
        (e[0] = t + r * a),
          (e[4] = n * a - i),
          (e[8] = s * l),
          (e[1] = s * c),
          (e[5] = s * h),
          (e[9] = -a),
          (e[2] = i * a - n),
          (e[6] = r + t * a),
          (e[10] = s * o);
      } else if ("ZXY" === t.order) {
        const t = o * h,
          i = o * c,
          n = l * h,
          r = l * c;
        (e[0] = t - r * a),
          (e[4] = -s * c),
          (e[8] = n + i * a),
          (e[1] = i + n * a),
          (e[5] = s * h),
          (e[9] = r - t * a),
          (e[2] = -s * l),
          (e[6] = a),
          (e[10] = s * o);
      } else if ("ZYX" === t.order) {
        const t = s * h,
          i = s * c,
          n = a * h,
          r = a * c;
        (e[0] = o * h),
          (e[4] = n * l - i),
          (e[8] = t * l + r),
          (e[1] = o * c),
          (e[5] = r * l + t),
          (e[9] = i * l - n),
          (e[2] = -l),
          (e[6] = a * o),
          (e[10] = s * o);
      } else if ("YZX" === t.order) {
        const t = s * o,
          i = s * l,
          n = a * o,
          r = a * l;
        (e[0] = o * h),
          (e[4] = r - t * c),
          (e[8] = n * c + i),
          (e[1] = c),
          (e[5] = s * h),
          (e[9] = -a * h),
          (e[2] = -l * h),
          (e[6] = i * c + n),
          (e[10] = t - r * c);
      } else if ("XZY" === t.order) {
        const t = s * o,
          i = s * l,
          n = a * o,
          r = a * l;
        (e[0] = o * h),
          (e[4] = -c),
          (e[8] = l * h),
          (e[1] = t * c + r),
          (e[5] = s * h),
          (e[9] = i * c - n),
          (e[2] = n * c - i),
          (e[6] = a * h),
          (e[10] = r * c + t);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(t) {
      return this.compose(Y, t, J);
    }
    lookAt(t, e, i) {
      const n = this.elements;
      return (
        Q.subVectors(t, e),
        0 === Q.lengthSq() && (Q.z = 1),
        Q.normalize(),
        Z.crossVectors(i, Q),
        0 === Z.lengthSq() &&
          (1 === Math.abs(i.z) ? (Q.x += 1e-4) : (Q.z += 1e-4),
          Q.normalize(),
          Z.crossVectors(i, Q)),
        Z.normalize(),
        K.crossVectors(Q, Z),
        (n[0] = Z.x),
        (n[4] = K.x),
        (n[8] = Q.x),
        (n[1] = Z.y),
        (n[5] = K.y),
        (n[9] = Q.y),
        (n[2] = Z.z),
        (n[6] = K.z),
        (n[10] = Q.z),
        this
      );
    }
    multiply(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
          ),
          this.multiplyMatrices(t, e))
        : this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const i = t.elements,
        n = e.elements,
        r = this.elements,
        s = i[0],
        a = i[4],
        o = i[8],
        l = i[12],
        h = i[1],
        c = i[5],
        u = i[9],
        d = i[13],
        p = i[2],
        m = i[6],
        f = i[10],
        g = i[14],
        y = i[3],
        x = i[7],
        v = i[11],
        _ = i[15],
        b = n[0],
        M = n[4],
        w = n[8],
        S = n[12],
        T = n[1],
        E = n[5],
        A = n[9],
        R = n[13],
        L = n[2],
        C = n[6],
        P = n[10],
        I = n[14],
        z = n[3],
        D = n[7],
        N = n[11],
        O = n[15];
      return (
        (r[0] = s * b + a * T + o * L + l * z),
        (r[4] = s * M + a * E + o * C + l * D),
        (r[8] = s * w + a * A + o * P + l * N),
        (r[12] = s * S + a * R + o * I + l * O),
        (r[1] = h * b + c * T + u * L + d * z),
        (r[5] = h * M + c * E + u * C + d * D),
        (r[9] = h * w + c * A + u * P + d * N),
        (r[13] = h * S + c * R + u * I + d * O),
        (r[2] = p * b + m * T + f * L + g * z),
        (r[6] = p * M + m * E + f * C + g * D),
        (r[10] = p * w + m * A + f * P + g * N),
        (r[14] = p * S + m * R + f * I + g * O),
        (r[3] = y * b + x * T + v * L + _ * z),
        (r[7] = y * M + x * E + v * C + _ * D),
        (r[11] = y * w + x * A + v * P + _ * N),
        (r[15] = y * S + x * R + v * I + _ * O),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        i = t[4],
        n = t[8],
        r = t[12],
        s = t[1],
        a = t[5],
        o = t[9],
        l = t[13],
        h = t[2],
        c = t[6],
        u = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * o * c -
            n * l * c -
            r * a * u +
            i * l * u +
            n * a * d -
            i * o * d) +
        t[7] *
          (+e * o * d -
            e * l * u +
            r * s * u -
            n * s * d +
            n * l * h -
            r * o * h) +
        t[11] *
          (+e * l * c -
            e * a * d -
            r * s * c +
            i * s * d +
            r * a * h -
            i * l * h) +
        t[15] *
          (-n * a * h -
            e * o * c +
            e * a * u +
            n * s * c -
            i * s * u +
            i * o * h)
      );
    }
    transpose() {
      const t = this.elements;
      let e;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    }
    setPosition(t, e, i) {
      const n = this.elements;
      return (
        t.isVector3
          ? ((n[12] = t.x), (n[13] = t.y), (n[14] = t.z))
          : ((n[12] = t), (n[13] = e), (n[14] = i)),
        this
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        i = t[1],
        n = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        h = t[8],
        c = t[9],
        u = t[10],
        d = t[11],
        p = t[12],
        m = t[13],
        f = t[14],
        g = t[15],
        y =
          c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
        x =
          p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
        v =
          h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
        _ =
          p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
        b = e * y + i * x + n * v + r * _;
      if (0 === b)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const M = 1 / b;
      return (
        (t[0] = y * M),
        (t[1] =
          (m * u * r -
            c * f * r -
            m * n * d +
            i * f * d +
            c * n * g -
            i * u * g) *
          M),
        (t[2] =
          (a * f * r -
            m * o * r +
            m * n * l -
            i * f * l -
            a * n * g +
            i * o * g) *
          M),
        (t[3] =
          (c * o * r -
            a * u * r -
            c * n * l +
            i * u * l +
            a * n * d -
            i * o * d) *
          M),
        (t[4] = x * M),
        (t[5] =
          (h * f * r -
            p * u * r +
            p * n * d -
            e * f * d -
            h * n * g +
            e * u * g) *
          M),
        (t[6] =
          (p * o * r -
            s * f * r -
            p * n * l +
            e * f * l +
            s * n * g -
            e * o * g) *
          M),
        (t[7] =
          (s * u * r -
            h * o * r +
            h * n * l -
            e * u * l -
            s * n * d +
            e * o * d) *
          M),
        (t[8] = v * M),
        (t[9] =
          (p * c * r -
            h * m * r -
            p * i * d +
            e * m * d +
            h * i * g -
            e * c * g) *
          M),
        (t[10] =
          (s * m * r -
            p * a * r +
            p * i * l -
            e * m * l -
            s * i * g +
            e * a * g) *
          M),
        (t[11] =
          (h * a * r -
            s * c * r -
            h * i * l +
            e * c * l +
            s * i * d -
            e * a * d) *
          M),
        (t[12] = _ * M),
        (t[13] =
          (h * m * n -
            p * c * n +
            p * i * u -
            e * m * u -
            h * i * f +
            e * c * f) *
          M),
        (t[14] =
          (p * a * n -
            s * m * n -
            p * i * o +
            e * m * o +
            s * i * f -
            e * a * f) *
          M),
        (t[15] =
          (s * c * n -
            h * a * n +
            h * i * o -
            e * c * o -
            s * i * u +
            e * a * u) *
          M),
        this
      );
    }
    scale(t) {
      const e = this.elements,
        i = t.x,
        n = t.y,
        r = t.z;
      return (
        (e[0] *= i),
        (e[4] *= n),
        (e[8] *= r),
        (e[1] *= i),
        (e[5] *= n),
        (e[9] *= r),
        (e[2] *= i),
        (e[6] *= n),
        (e[10] *= r),
        (e[3] *= i),
        (e[7] *= n),
        (e[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, i, n));
    }
    makeTranslation(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
    }
    makeRotationX(t) {
      const e = Math.cos(t),
        i = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t),
        i = Math.sin(t);
      return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t),
        i = Math.sin(t);
      return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const i = Math.cos(e),
        n = Math.sin(e),
        r = 1 - i,
        s = t.x,
        a = t.y,
        o = t.z,
        l = r * s,
        h = r * a;
      return (
        this.set(
          l * s + i,
          l * a - n * o,
          l * o + n * a,
          0,
          l * a + n * o,
          h * a + i,
          h * o - n * s,
          0,
          l * o - n * a,
          h * o + n * s,
          r * o * o + i,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, i, n, r, s) {
      return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, i) {
      const n = this.elements,
        r = e._x,
        s = e._y,
        a = e._z,
        o = e._w,
        l = r + r,
        h = s + s,
        c = a + a,
        u = r * l,
        d = r * h,
        p = r * c,
        m = s * h,
        f = s * c,
        g = a * c,
        y = o * l,
        x = o * h,
        v = o * c,
        _ = i.x,
        b = i.y,
        M = i.z;
      return (
        (n[0] = (1 - (m + g)) * _),
        (n[1] = (d + v) * _),
        (n[2] = (p - x) * _),
        (n[3] = 0),
        (n[4] = (d - v) * b),
        (n[5] = (1 - (u + g)) * b),
        (n[6] = (f + y) * b),
        (n[7] = 0),
        (n[8] = (p + x) * M),
        (n[9] = (f - y) * M),
        (n[10] = (1 - (u + m)) * M),
        (n[11] = 0),
        (n[12] = t.x),
        (n[13] = t.y),
        (n[14] = t.z),
        (n[15] = 1),
        this
      );
    }
    decompose(t, e, i) {
      const n = this.elements;
      let r = q.set(n[0], n[1], n[2]).length();
      const s = q.set(n[4], n[5], n[6]).length(),
        a = q.set(n[8], n[9], n[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = n[12]),
        (t.y = n[13]),
        (t.z = n[14]),
        X.copy(this);
      const o = 1 / r,
        l = 1 / s,
        h = 1 / a;
      return (
        (X.elements[0] *= o),
        (X.elements[1] *= o),
        (X.elements[2] *= o),
        (X.elements[4] *= l),
        (X.elements[5] *= l),
        (X.elements[6] *= l),
        (X.elements[8] *= h),
        (X.elements[9] *= h),
        (X.elements[10] *= h),
        e.setFromRotationMatrix(X),
        (i.x = r),
        (i.y = s),
        (i.z = a),
        this
      );
    }
    makePerspective(t, e, i, n, r, s) {
      void 0 === s &&
        console.warn(
          "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
        );
      const a = this.elements,
        o = (2 * r) / (e - t),
        l = (2 * r) / (i - n),
        h = (e + t) / (e - t),
        c = (i + n) / (i - n),
        u = -(s + r) / (s - r),
        d = (-2 * s * r) / (s - r);
      return (
        (a[0] = o),
        (a[4] = 0),
        (a[8] = h),
        (a[12] = 0),
        (a[1] = 0),
        (a[5] = l),
        (a[9] = c),
        (a[13] = 0),
        (a[2] = 0),
        (a[6] = 0),
        (a[10] = u),
        (a[14] = d),
        (a[3] = 0),
        (a[7] = 0),
        (a[11] = -1),
        (a[15] = 0),
        this
      );
    }
    makeOrthographic(t, e, i, n, r, s) {
      const a = this.elements,
        o = 1 / (e - t),
        l = 1 / (i - n),
        h = 1 / (s - r),
        c = (e + t) * o,
        u = (i + n) * l,
        d = (s + r) * h;
      return (
        (a[0] = 2 * o),
        (a[4] = 0),
        (a[8] = 0),
        (a[12] = -c),
        (a[1] = 0),
        (a[5] = 2 * l),
        (a[9] = 0),
        (a[13] = -u),
        (a[2] = 0),
        (a[6] = 0),
        (a[10] = -2 * h),
        (a[14] = -d),
        (a[3] = 0),
        (a[7] = 0),
        (a[11] = 0),
        (a[15] = 1),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        i = t.elements;
      for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const i = this.elements;
      return (
        (t[e] = i[0]),
        (t[e + 1] = i[1]),
        (t[e + 2] = i[2]),
        (t[e + 3] = i[3]),
        (t[e + 4] = i[4]),
        (t[e + 5] = i[5]),
        (t[e + 6] = i[6]),
        (t[e + 7] = i[7]),
        (t[e + 8] = i[8]),
        (t[e + 9] = i[9]),
        (t[e + 10] = i[10]),
        (t[e + 11] = i[11]),
        (t[e + 12] = i[12]),
        (t[e + 13] = i[13]),
        (t[e + 14] = i[14]),
        (t[e + 15] = i[15]),
        t
      );
    }
  }
  j.prototype.isMatrix4 = !0;
  const q = new G(),
    X = new j(),
    Y = new G(0, 0, 0),
    J = new G(1, 1, 1),
    Z = new G(),
    K = new G(),
    Q = new G();
  class $ {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const i = this._listeners;
      void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const i = this._listeners;
      return void 0 !== i[t] && -1 !== i[t].indexOf(e);
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const i = this._listeners[t];
      if (void 0 !== i) {
        const t = i.indexOf(e);
        -1 !== t && i.splice(t, 1);
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const i = e.slice(0);
        for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
        t.target = null;
      }
    }
  }
  const tt = new j(),
    et = new m();
  class it {
    constructor(t = 0, e = 0, i = 0, n = it.DefaultOrder) {
      (this._x = t), (this._y = e), (this._z = i), (this._order = n);
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      (this._order = t), this._onChangeCallback();
    }
    set(t, e, i, n = this._order) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = i),
        (this._order = n),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t, e = this._order, i = !0) {
      const n = t.elements,
        r = n[0],
        s = n[4],
        a = n[8],
        o = n[1],
        l = n[5],
        h = n[9],
        c = n[2],
        d = n[6],
        p = n[10];
      switch (e) {
        case "XYZ":
          (this._y = Math.asin(u(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-s, r)))
              : ((this._x = Math.atan2(d, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-u(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(o, l)))
              : ((this._y = Math.atan2(-c, r)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(u(d, -1, 1))),
            Math.abs(d) < 0.9999999
              ? ((this._y = Math.atan2(-c, p)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(o, r)));
          break;
        case "ZYX":
          (this._y = Math.asin(-u(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(o, r)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(u(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-c, r)))
              : ((this._x = 0), (this._y = Math.atan2(a, p)));
          break;
        case "XZY":
          (this._z = Math.asin(-u(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, r)))
              : ((this._x = Math.atan2(-h, p)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              e
          );
      }
      return (this._order = e), !0 === i && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, i) {
      return (
        tt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(tt, e, i)
      );
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return et.setFromEuler(this), this.setFromQuaternion(et, t);
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      );
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._order),
        t
      );
    }
    toVector3(t) {
      return t
        ? t.set(this._x, this._y, this._z)
        : new G(this._x, this._y, this._z);
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
  }
  (it.prototype.isEuler = !0),
    (it.DefaultOrder = "XYZ"),
    (it.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
  class nt {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = ((1 << t) | 0) >>> 0;
    }
    enable(t) {
      this.mask |= (1 << t) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= (1 << t) | 0;
    }
    disable(t) {
      this.mask &= ~((1 << t) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return 0 != (this.mask & t.mask);
    }
    isEnabled(t) {
      return 0 != (this.mask & ((1 << t) | 0));
    }
  }
  class rt {
    constructor() {
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    set(t, e, i, n, r, s, a, o, l) {
      const h = this.elements;
      return (
        (h[0] = t),
        (h[1] = n),
        (h[2] = a),
        (h[3] = e),
        (h[4] = r),
        (h[5] = o),
        (h[6] = i),
        (h[7] = s),
        (h[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements,
        i = t.elements;
      return (
        (e[0] = i[0]),
        (e[1] = i[1]),
        (e[2] = i[2]),
        (e[3] = i[3]),
        (e[4] = i[4]),
        (e[5] = i[5]),
        (e[6] = i[6]),
        (e[7] = i[7]),
        (e[8] = i[8]),
        this
      );
    }
    extractBasis(t, e, i) {
      return (
        t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return (
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const i = t.elements,
        n = e.elements,
        r = this.elements,
        s = i[0],
        a = i[3],
        o = i[6],
        l = i[1],
        h = i[4],
        c = i[7],
        u = i[2],
        d = i[5],
        p = i[8],
        m = n[0],
        f = n[3],
        g = n[6],
        y = n[1],
        x = n[4],
        v = n[7],
        _ = n[2],
        b = n[5],
        M = n[8];
      return (
        (r[0] = s * m + a * y + o * _),
        (r[3] = s * f + a * x + o * b),
        (r[6] = s * g + a * v + o * M),
        (r[1] = l * m + h * y + c * _),
        (r[4] = l * f + h * x + c * b),
        (r[7] = l * g + h * v + c * M),
        (r[2] = u * m + d * y + p * _),
        (r[5] = u * f + d * x + p * b),
        (r[8] = u * g + d * v + p * M),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[3] *= t),
        (e[6] *= t),
        (e[1] *= t),
        (e[4] *= t),
        (e[7] *= t),
        (e[2] *= t),
        (e[5] *= t),
        (e[8] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        i = t[1],
        n = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        h = t[8];
      return (
        e * s * h - e * a * l - i * r * h + i * a * o + n * r * l - n * s * o
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        i = t[1],
        n = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        h = t[8],
        c = h * s - a * l,
        u = a * o - h * r,
        d = l * r - s * o,
        p = e * c + i * u + n * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const m = 1 / p;
      return (
        (t[0] = c * m),
        (t[1] = (n * l - h * i) * m),
        (t[2] = (a * i - n * s) * m),
        (t[3] = u * m),
        (t[4] = (h * e - n * o) * m),
        (t[5] = (n * r - a * e) * m),
        (t[6] = d * m),
        (t[7] = (i * o - l * e) * m),
        (t[8] = (s * e - i * r) * m),
        this
      );
    }
    transpose() {
      let t;
      const e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[3]),
        (e[3] = t),
        (t = e[2]),
        (e[2] = e[6]),
        (e[6] = t),
        (t = e[5]),
        (e[5] = e[7]),
        (e[7] = t),
        this
      );
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return (
        (t[0] = e[0]),
        (t[1] = e[3]),
        (t[2] = e[6]),
        (t[3] = e[1]),
        (t[4] = e[4]),
        (t[5] = e[7]),
        (t[6] = e[2]),
        (t[7] = e[5]),
        (t[8] = e[8]),
        this
      );
    }
    setUvTransform(t, e, i, n, r, s, a) {
      const o = Math.cos(r),
        l = Math.sin(r);
      return (
        this.set(
          i * o,
          i * l,
          -i * (o * s + l * a) + s + t,
          -n * l,
          n * o,
          -n * (-l * s + o * a) + a + e,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(t, e) {
      const i = this.elements;
      return (
        (i[0] *= t),
        (i[3] *= t),
        (i[6] *= t),
        (i[1] *= e),
        (i[4] *= e),
        (i[7] *= e),
        this
      );
    }
    rotate(t) {
      const e = Math.cos(t),
        i = Math.sin(t),
        n = this.elements,
        r = n[0],
        s = n[3],
        a = n[6],
        o = n[1],
        l = n[4],
        h = n[7];
      return (
        (n[0] = e * r + i * o),
        (n[3] = e * s + i * l),
        (n[6] = e * a + i * h),
        (n[1] = -i * r + e * o),
        (n[4] = -i * s + e * l),
        (n[7] = -i * a + e * h),
        this
      );
    }
    translate(t, e) {
      const i = this.elements;
      return (
        (i[0] += t * i[2]),
        (i[3] += t * i[5]),
        (i[6] += t * i[8]),
        (i[1] += e * i[2]),
        (i[4] += e * i[5]),
        (i[7] += e * i[8]),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        i = t.elements;
      for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const i = this.elements;
      return (
        (t[e] = i[0]),
        (t[e + 1] = i[1]),
        (t[e + 2] = i[2]),
        (t[e + 3] = i[3]),
        (t[e + 4] = i[4]),
        (t[e + 5] = i[5]),
        (t[e + 6] = i[6]),
        (t[e + 7] = i[7]),
        (t[e + 8] = i[8]),
        t
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  rt.prototype.isMatrix3 = !0;
  let st = 0;
  const at = new G(),
    ot = new m(),
    lt = new j(),
    ht = new G(),
    ct = new G(),
    ut = new G(),
    dt = new m(),
    pt = new G(1, 0, 0),
    mt = new G(0, 1, 0),
    ft = new G(0, 0, 1),
    gt = { type: "added" },
    yt = { type: "removed" };
  class xt extends $ {
    constructor() {
      super(),
        Object.defineProperty(this, "id", { value: st++ }),
        (this.uuid = c()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = xt.DefaultUp.clone());
      const t = new G(),
        e = new it(),
        i = new m(),
        n = new G(1, 1, 1);
      e._onChange(function () {
        i.setFromEuler(e, !1);
      }),
        i._onChange(function () {
          e.setFromQuaternion(i, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: i },
          scale: { configurable: !0, enumerable: !0, value: n },
          modelViewMatrix: { value: new j() },
          normalMatrix: { value: new rt() },
        }),
        (this.matrix = new j()),
        (this.matrixWorld = new j()),
        (this.matrixAutoUpdate = xt.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new nt()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return ot.setFromAxisAngle(t, e), this.quaternion.multiply(ot), this;
    }
    rotateOnWorldAxis(t, e) {
      return ot.setFromAxisAngle(t, e), this.quaternion.premultiply(ot), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(pt, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(mt, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(ft, t);
    }
    translateOnAxis(t, e) {
      return (
        at.copy(t).applyQuaternion(this.quaternion),
        this.position.add(at.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(pt, t);
    }
    translateY(t) {
      return this.translateOnAxis(mt, t);
    }
    translateZ(t) {
      return this.translateOnAxis(ft, t);
    }
    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return t.applyMatrix4(lt.copy(this.matrixWorld).invert());
    }
    lookAt(t, e, i) {
      t.isVector3 ? ht.copy(t) : ht.set(t, e, i);
      const n = this.parent;
      this.updateWorldMatrix(!0, !1),
        ct.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? lt.lookAt(ct, ht, this.up)
          : lt.lookAt(ht, ct, this.up),
        this.quaternion.setFromRotationMatrix(lt),
        n &&
          (lt.extractRotation(n.matrixWorld),
          ot.setFromRotationMatrix(lt),
          this.quaternion.premultiply(ot.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(gt))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t
              ),
          this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(yt)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        (e.parent = null), e.dispatchEvent(yt);
      }
      return (this.children.length = 0), this;
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        lt.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          lt.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(lt),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let i = 0, n = this.children.length; i < n; i++) {
        const n = this.children[i].getObjectByProperty(t, e);
        if (void 0 !== n) return n;
      }
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ct, t, ut), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ct, dt, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(t) {
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
    }
    updateWorldMatrix(t, e) {
      const i = this.parent;
      if (
        (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        i = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
        }),
        (i.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const n = {};
      function r(e, i) {
        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        !0 === this.castShadow && (n.castShadow = !0),
        !0 === this.receiveShadow && (n.receiveShadow = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.frustumCulled && (n.frustumCulled = !1),
        0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        (n.layers = this.layers.mask),
        (n.matrix = this.matrix.toArray()),
        !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((n.type = "InstancedMesh"),
          (n.count = this.count),
          (n.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (n.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (n.background = this.background.toJSON())
            : this.background.isTexture &&
              (n.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            (n.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const i = e.shapes;
          if (Array.isArray(i))
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              r(t.shapes, n);
            }
          else r(t.shapes, i);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((n.bindMode = this.bindMode),
          (n.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let i = 0, n = this.material.length; i < n; i++)
            e.push(r(t.materials, this.material[i]));
          n.material = e;
        } else n.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        n.children = [];
        for (let e = 0; e < this.children.length; e++)
          n.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        n.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const i = this.animations[e];
          n.animations.push(r(t.animations, i));
        }
      }
      if (e) {
        const e = s(t.geometries),
          n = s(t.materials),
          r = s(t.textures),
          a = s(t.images),
          o = s(t.shapes),
          l = s(t.skeletons),
          h = s(t.animations);
        e.length > 0 && (i.geometries = e),
          n.length > 0 && (i.materials = n),
          r.length > 0 && (i.textures = r),
          a.length > 0 && (i.images = a),
          o.length > 0 && (i.shapes = o),
          l.length > 0 && (i.skeletons = l),
          h.length > 0 && (i.animations = h);
      }
      return (i.object = n), i;
      function s(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          delete n.metadata, e.push(n);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let e = 0; e < t.children.length; e++) {
          const i = t.children[e];
          this.add(i.clone());
        }
      return this;
    }
  }
  (xt.DefaultUp = new G(0, 1, 0)),
    (xt.DefaultMatrixAutoUpdate = !0),
    (xt.prototype.isObject3D = !0);
  class vt extends xt {
    constructor() {
      super(), (this.type = "Bone");
    }
  }
  vt.prototype.isBone = !0;
  class _t {
    constructor(
      t = new G(1 / 0, 1 / 0, 1 / 0),
      e = new G(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.min = t), (this.max = e);
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      let e = 1 / 0,
        i = 1 / 0,
        n = 1 / 0,
        r = -1 / 0,
        s = -1 / 0,
        a = -1 / 0;
      for (let o = 0, l = t.length; o < l; o += 3) {
        const l = t[o],
          h = t[o + 1],
          c = t[o + 2];
        l < e && (e = l),
          h < i && (i = h),
          c < n && (n = c),
          l > r && (r = l),
          h > s && (s = h),
          c > a && (a = c);
      }
      return this.min.set(e, i, n), this.max.set(r, s, a), this;
    }
    setFromBufferAttribute(t) {
      let e = 1 / 0,
        i = 1 / 0,
        n = 1 / 0,
        r = -1 / 0,
        s = -1 / 0,
        a = -1 / 0;
      for (let o = 0, l = t.count; o < l; o++) {
        const l = t.getX(o),
          h = t.getY(o),
          c = t.getZ(o);
        l < e && (e = l),
          h < i && (i = h),
          c < n && (n = c),
          l > r && (r = l),
          h > s && (s = h),
          c > a && (a = c);
      }
      return this.min.set(e, i, n), this.max.set(r, s, a), this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const i = Mt.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = !1) {
      t.updateWorldMatrix(!1, !1);
      const i = t.geometry;
      if (void 0 !== i)
        if (e && null != i.attributes && void 0 !== i.attributes.position) {
          const e = i.attributes.position;
          for (let i = 0, n = e.count; i < n; i++)
            Mt.fromBufferAttribute(e, i).applyMatrix4(t.matrixWorld),
              this.expandByPoint(Mt);
        } else
          null === i.boundingBox && i.computeBoundingBox(),
            wt.copy(i.boundingBox),
            wt.applyMatrix4(t.matrixWorld),
            this.union(wt);
      const n = t.children;
      for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
      return this;
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    }
    getParameter(t, e) {
      return e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, Mt),
        Mt.distanceToSquared(t.center) <= t.radius * t.radius
      );
    }
    intersectsPlane(t) {
      let e, i;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
        e <= -t.constant && i >= -t.constant
      );
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(Ct),
        Pt.subVectors(this.max, Ct),
        St.subVectors(t.a, Ct),
        Tt.subVectors(t.b, Ct),
        Et.subVectors(t.c, Ct),
        At.subVectors(Tt, St),
        Rt.subVectors(Et, Tt),
        Lt.subVectors(St, Et);
      let e = [
        0,
        -At.z,
        At.y,
        0,
        -Rt.z,
        Rt.y,
        0,
        -Lt.z,
        Lt.y,
        At.z,
        0,
        -At.x,
        Rt.z,
        0,
        -Rt.x,
        Lt.z,
        0,
        -Lt.x,
        -At.y,
        At.x,
        0,
        -Rt.y,
        Rt.x,
        0,
        -Lt.y,
        Lt.x,
        0,
      ];
      return (
        !!Dt(e, St, Tt, Et, Pt) &&
        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!Dt(e, St, Tt, Et, Pt) &&
          (It.crossVectors(At, Rt),
          (e = [It.x, It.y, It.z]),
          Dt(e, St, Tt, Et, Pt)))
      );
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return Mt.copy(t).clamp(this.min, this.max).sub(t).length();
    }
    getBoundingSphere(t) {
      return (
        this.getCenter(t.center),
        (t.radius = 0.5 * this.getSize(Mt).length()),
        t
      );
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return (
        this.isEmpty() ||
          (bt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          bt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          bt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          bt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          bt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          bt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          bt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          bt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(bt)),
        this
      );
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  _t.prototype.isBox3 = !0;
  const bt = [
      new G(),
      new G(),
      new G(),
      new G(),
      new G(),
      new G(),
      new G(),
      new G(),
    ],
    Mt = new G(),
    wt = new _t(),
    St = new G(),
    Tt = new G(),
    Et = new G(),
    At = new G(),
    Rt = new G(),
    Lt = new G(),
    Ct = new G(),
    Pt = new G(),
    It = new G(),
    zt = new G();
  function Dt(t, e, i, n, r) {
    for (let s = 0, a = t.length - 3; s <= a; s += 3) {
      zt.fromArray(t, s);
      const a =
          r.x * Math.abs(zt.x) + r.y * Math.abs(zt.y) + r.z * Math.abs(zt.z),
        o = e.dot(zt),
        l = i.dot(zt),
        h = n.dot(zt);
      if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1;
    }
    return !0;
  }
  class Nt {
    constructor(t = 0, e = 0, i = 0, n = 1) {
      (this.x = t), (this.y = e), (this.z = i), (this.w = n);
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, i, n) {
      return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setW(t) {
      return (this.w = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = void 0 !== t.w ? t.w : 1),
        this
      );
    }
    add(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(t, e))
        : ((this.x += t.x),
          (this.y += t.y),
          (this.z += t.z),
          (this.w += t.w),
          this);
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x),
        (this.y = t.y + e.y),
        (this.z = t.z + e.z),
        (this.w = t.w + e.w),
        this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e),
        (this.y += t.y * e),
        (this.z += t.z * e),
        (this.w += t.w * e),
        this
      );
    }
    sub(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(t, e))
        : ((this.x -= t.x),
          (this.y -= t.y),
          (this.z -= t.z),
          (this.w -= t.w),
          this);
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x),
        (this.y = t.y - e.y),
        (this.z = t.z - e.z),
        (this.w = t.w - e.w),
        this
      );
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      );
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
    }
    applyMatrix4(t) {
      const e = this.x,
        i = this.y,
        n = this.z,
        r = this.w,
        s = t.elements;
      return (
        (this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r),
        (this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r),
        (this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r),
        (this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r),
        this
      );
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return (
        e < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, i, n, r;
      const s = 0.01,
        a = 0.1,
        o = t.elements,
        l = o[0],
        h = o[4],
        c = o[8],
        u = o[1],
        d = o[5],
        p = o[9],
        m = o[2],
        f = o[6],
        g = o[10];
      if (Math.abs(h - u) < s && Math.abs(c - m) < s && Math.abs(p - f) < s) {
        if (
          Math.abs(h + u) < a &&
          Math.abs(c + m) < a &&
          Math.abs(p + f) < a &&
          Math.abs(l + d + g - 3) < a
        )
          return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (l + 1) / 2,
          o = (d + 1) / 2,
          y = (g + 1) / 2,
          x = (h + u) / 4,
          v = (c + m) / 4,
          _ = (p + f) / 4;
        return (
          t > o && t > y
            ? t < s
              ? ((i = 0), (n = 0.707106781), (r = 0.707106781))
              : ((i = Math.sqrt(t)), (n = x / i), (r = v / i))
            : o > y
            ? o < s
              ? ((i = 0.707106781), (n = 0), (r = 0.707106781))
              : ((n = Math.sqrt(o)), (i = x / n), (r = _ / n))
            : y < s
            ? ((i = 0.707106781), (n = 0.707106781), (r = 0))
            : ((r = Math.sqrt(y)), (i = v / r), (n = _ / r)),
          this.set(i, n, r, e),
          this
        );
      }
      let y = Math.sqrt(
        (f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h)
      );
      return (
        Math.abs(y) < 0.001 && (y = 1),
        (this.x = (f - p) / y),
        (this.y = (c - m) / y),
        (this.z = (u - h) / y),
        (this.w = Math.acos((l + d + g - 1) / 2)),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        (this.w = Math.max(t, Math.min(e, this.w))),
        this
      );
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        (this.w += (t.w - this.w) * e),
        this
      );
    }
    lerpVectors(t, e, i) {
      return (
        (this.x = t.x + (e.x - t.x) * i),
        (this.y = t.y + (e.y - t.y) * i),
        (this.z = t.z + (e.z - t.z) * i),
        (this.w = t.w + (e.w - t.w) * i),
        this
      );
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        (this.w = t[e + 3]),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        (t[e + 3] = this.w),
        t
      );
    }
    fromBufferAttribute(t, e, i) {
      return (
        void 0 !== i &&
          console.warn(
            "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        (this.w = t.getW(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  Nt.prototype.isVector4 = !0;
  class Ot {
    constructor(t = 0, e = 0) {
      (this.x = t), (this.y = e);
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this;
    }
    add(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(t, e))
        : ((this.x += t.x), (this.y += t.y), this);
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this;
    }
    addVectors(t, e) {
      return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
    }
    addScaledVector(t, e) {
      return (this.x += t.x * e), (this.y += t.y * e), this;
    }
    sub(t, e) {
      return void 0 !== e
        ? (console.warn(
            "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(t, e))
        : ((this.x -= t.x), (this.y -= t.y), this);
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this;
    }
    subVectors(t, e) {
      return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this;
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x,
        i = this.y,
        n = t.elements;
      return (
        (this.x = n[0] * e + n[3] * i + n[6]),
        (this.y = n[1] * e + n[4] * i + n[7]),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        this
      );
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        i = this.y - t.y;
      return e * e + i * i;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
      );
    }
    lerpVectors(t, e, i) {
      return (
        (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), this
      );
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), t;
    }
    fromBufferAttribute(t, e, i) {
      return (
        void 0 !== i &&
          console.warn(
            "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        this
      );
    }
    rotateAround(t, e) {
      const i = Math.cos(e),
        n = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return (
        (this.x = r * i - s * n + t.x), (this.y = r * n + s * i + t.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  Ot.prototype.isVector2 = !0;
  const Bt = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    Ft = { h: 0, s: 0, l: 0 },
    Ht = { h: 0, s: 0, l: 0 };
  function Ut(t, e, i) {
    return (
      i < 0 && (i += 1),
      i > 1 && (i -= 1),
      i < 1 / 6
        ? t + 6 * (e - t) * i
        : i < 0.5
        ? e
        : i < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - i)
        : t
    );
  }
  function kt(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function Gt(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  class Vt {
    constructor(t, e, i) {
      return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
    }
    set(t) {
      return (
        t && t.isColor
          ? this.copy(t)
          : "number" == typeof t
          ? this.setHex(t)
          : "string" == typeof t && this.setStyle(t),
        this
      );
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    }
    setHex(t) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        this
      );
    }
    setRGB(t, e, i) {
      return (this.r = t), (this.g = e), (this.b = i), this;
    }
    setHSL(t, e, i) {
      if (((t = d(t, 1)), (e = u(e, 0, 1)), (i = u(i, 0, 1)), 0 === e))
        this.r = this.g = this.b = i;
      else {
        const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
          r = 2 * i - n;
        (this.r = Ut(r, n, t + 1 / 3)),
          (this.g = Ut(r, n, t)),
          (this.b = Ut(r, n, t - 1 / 3));
      }
      return this;
    }
    setStyle(t) {
      function e(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + t + " will be ignored."
          );
      }
      let i;
      if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
        let t;
        const n = i[1],
          r = i[2];
        switch (n) {
          case "rgb":
          case "rgba":
            if (
              (t =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                e(t[4]),
                this
              );
            if (
              (t =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                e(t[4]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (t =
                /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            ) {
              const i = parseFloat(t[1]) / 360,
                n = parseInt(t[2], 10) / 100,
                r = parseInt(t[3], 10) / 100;
              return e(t[4]), this.setHSL(i, n, r);
            }
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const t = i[1],
          e = t.length;
        if (3 === e)
          return (
            (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
            (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
            (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
            this
          );
        if (6 === e)
          return (
            (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
            (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
            (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
            this
          );
      }
      return t && t.length > 0 ? this.setColorName(t) : this;
    }
    setColorName(t) {
      const e = Bt[t.toLowerCase()];
      return (
        void 0 !== e
          ? this.setHex(e)
          : console.warn("THREE.Color: Unknown color " + t),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    }
    copySRGBToLinear(t) {
      return (this.r = kt(t.r)), (this.g = kt(t.g)), (this.b = kt(t.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.r = Gt(t.r)), (this.g = Gt(t.g)), (this.b = Gt(t.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex() {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(t) {
      const e = this.r,
        i = this.g,
        n = this.b,
        r = Math.max(e, i, n),
        s = Math.min(e, i, n);
      let a, o;
      const l = (s + r) / 2;
      if (s === r) (a = 0), (o = 0);
      else {
        const t = r - s;
        switch (((o = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
          case e:
            a = (i - n) / t + (i < n ? 6 : 0);
            break;
          case i:
            a = (n - e) / t + 2;
            break;
          case n:
            a = (e - i) / t + 4;
        }
        a /= 6;
      }
      return (t.h = a), (t.s = o), (t.l = l), t;
    }
    getStyle() {
      return (
        "rgb(" +
        ((255 * this.r) | 0) +
        "," +
        ((255 * this.g) | 0) +
        "," +
        ((255 * this.b) | 0) +
        ")"
      );
    }
    offsetHSL(t, e, i) {
      return (
        this.getHSL(Ft),
        (Ft.h += t),
        (Ft.s += e),
        (Ft.l += i),
        this.setHSL(Ft.h, Ft.s, Ft.l),
        this
      );
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    }
    addColors(t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    }
    lerp(t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    }
    lerpColors(t, e, i) {
      return (
        (this.r = t.r + (e.r - t.r) * i),
        (this.g = t.g + (e.g - t.g) * i),
        (this.b = t.b + (e.b - t.b) * i),
        this
      );
    }
    lerpHSL(t, e) {
      this.getHSL(Ft), t.getHSL(Ht);
      const i = p(Ft.h, Ht.h, e),
        n = p(Ft.s, Ht.s, e),
        r = p(Ft.l, Ht.l, e);
      return this.setHSL(i, n, r), this;
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.r = t.getX(e)),
        (this.g = t.getY(e)),
        (this.b = t.getZ(e)),
        !0 === t.normalized &&
          ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
        this
      );
    }
    toJSON() {
      return this.getHex();
    }
  }
  (Vt.NAMES = Bt),
    (Vt.prototype.isColor = !0),
    (Vt.prototype.r = 1),
    (Vt.prototype.g = 1),
    (Vt.prototype.b = 1);
  const Wt = new G(),
    jt = new Ot();
  class qt {
    constructor(t, e, i) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === i),
        (this.usage = E),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, i) {
      (t *= this.itemSize), (i *= e.itemSize);
      for (let n = 0, r = this.itemSize; n < r; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    copyColorsArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyColorsArray(): color is undefined",
            n
          ),
          (r = new Vt())),
          (e[i++] = r.r),
          (e[i++] = r.g),
          (e[i++] = r.b);
      }
      return this;
    }
    copyVector2sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
            n
          ),
          (r = new Ot())),
          (e[i++] = r.x),
          (e[i++] = r.y);
      }
      return this;
    }
    copyVector3sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
            n
          ),
          (r = new G())),
          (e[i++] = r.x),
          (e[i++] = r.y),
          (e[i++] = r.z);
      }
      return this;
    }
    copyVector4sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
            n
          ),
          (r = new Nt())),
          (e[i++] = r.x),
          (e[i++] = r.y),
          (e[i++] = r.z),
          (e[i++] = r.w);
      }
      return this;
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, i = this.count; e < i; e++)
          jt.fromBufferAttribute(this, e),
            jt.applyMatrix3(t),
            this.setXY(e, jt.x, jt.y);
      else if (3 === this.itemSize)
        for (let e = 0, i = this.count; e < i; e++)
          Wt.fromBufferAttribute(this, e),
            Wt.applyMatrix3(t),
            this.setXYZ(e, Wt.x, Wt.y, Wt.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, i = this.count; e < i; e++)
        (Wt.x = this.getX(e)),
          (Wt.y = this.getY(e)),
          (Wt.z = this.getZ(e)),
          Wt.applyMatrix4(t),
          this.setXYZ(e, Wt.x, Wt.y, Wt.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, i = this.count; e < i; e++)
        (Wt.x = this.getX(e)),
          (Wt.y = this.getY(e)),
          (Wt.z = this.getZ(e)),
          Wt.applyNormalMatrix(t),
          this.setXYZ(e, Wt.x, Wt.y, Wt.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, i = this.count; e < i; e++)
        (Wt.x = this.getX(e)),
          (Wt.y = this.getY(e)),
          (Wt.z = this.getZ(e)),
          Wt.transformDirection(t),
          this.setXYZ(e, Wt.x, Wt.y, Wt.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getX(t) {
      return this.array[t * this.itemSize];
    }
    setX(t, e) {
      return (this.array[t * this.itemSize] = e), this;
    }
    getY(t) {
      return this.array[t * this.itemSize + 1];
    }
    setY(t, e) {
      return (this.array[t * this.itemSize + 1] = e), this;
    }
    getZ(t) {
      return this.array[t * this.itemSize + 2];
    }
    setZ(t, e) {
      return (this.array[t * this.itemSize + 2] = e), this;
    }
    getW(t) {
      return this.array[t * this.itemSize + 3];
    }
    setW(t, e) {
      return (this.array[t * this.itemSize + 3] = e), this;
    }
    setXY(t, e, i) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = i),
        this
      );
    }
    setXYZ(t, e, i, n) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = i),
        (this.array[t + 2] = n),
        this
      );
    }
    setXYZW(t, e, i, n, r) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = i),
        (this.array[t + 2] = n),
        (this.array[t + 3] = r),
        this
      );
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (t.name = this.name),
        this.usage !== E && (t.usage = this.usage),
        (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
          (t.updateRange = this.updateRange),
        t
      );
    }
  }
  qt.prototype.isBufferAttribute = !0;
  class Xt extends qt {
    constructor(t, e, i) {
      super(new Uint16Array(t), e, i);
    }
  }
  class Yt extends qt {
    constructor(t, e, i) {
      super(new Uint32Array(t), e, i);
    }
  }
  (class extends qt {
    constructor(t, e, i) {
      super(new Uint16Array(t), e, i);
    }
  }.prototype.isFloat16BufferAttribute = !0);
  class Jt extends qt {
    constructor(t, e, i) {
      super(new Float32Array(t), e, i);
    }
  }
  const Zt = new _t(),
    Kt = new G(),
    Qt = new G(),
    $t = new G();
  class te {
    constructor(t = new G(), e = -1) {
      (this.center = t), (this.radius = e);
    }
    set(t, e) {
      return this.center.copy(t), (this.radius = e), this;
    }
    setFromPoints(t, e) {
      const i = this.center;
      void 0 !== e ? i.copy(e) : Zt.setFromPoints(t).getCenter(i);
      let n = 0;
      for (let e = 0, r = t.length; e < r; e++)
        n = Math.max(n, i.distanceToSquared(t[e]));
      return (this.radius = Math.sqrt(n)), this;
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const i = this.center.distanceToSquared(t);
      return (
        e.copy(t),
        i > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      $t.subVectors(t, this.center);
      const e = $t.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e),
          i = 0.5 * (t - this.radius);
        this.center.add($t.multiplyScalar(i / t)), (this.radius += i);
      }
      return this;
    }
    union(t) {
      return (
        !0 === this.center.equals(t.center)
          ? Qt.set(0, 0, 1).multiplyScalar(t.radius)
          : Qt.subVectors(t.center, this.center)
              .normalize()
              .multiplyScalar(t.radius),
        this.expandByPoint(Kt.copy(t.center).add(Qt)),
        this.expandByPoint(Kt.copy(t.center).sub(Qt)),
        this
      );
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array;
  function ee(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t);
  }
  let ie = 0;
  const ne = new j(),
    re = new xt(),
    se = new G(),
    ae = new _t(),
    oe = new _t(),
    le = new G();
  class he extends $ {
    constructor() {
      super(),
        Object.defineProperty(this, "id", { value: ie++ }),
        (this.uuid = c()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (
              (function (t) {
                for (let e = t.length - 1; e >= 0; --e)
                  if (t[e] > 65535) return !0;
                return !1;
              })(t)
                ? Yt
                : Xt
            )(t, 1))
          : (this.index = t),
        this
      );
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return (this.attributes[t] = e), this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
    addGroup(t, e, i = 0) {
      this.groups.push({ start: t, count: e, materialIndex: i });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      const i = this.attributes.normal;
      if (void 0 !== i) {
        const e = new rt().getNormalMatrix(t);
        i.applyNormalMatrix(e), (i.needsUpdate = !0);
      }
      const n = this.attributes.tangent;
      return (
        void 0 !== n && (n.transformDirection(t), (n.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(t) {
      return ne.makeRotationFromQuaternion(t), this.applyMatrix4(ne), this;
    }
    rotateX(t) {
      return ne.makeRotationX(t), this.applyMatrix4(ne), this;
    }
    rotateY(t) {
      return ne.makeRotationY(t), this.applyMatrix4(ne), this;
    }
    rotateZ(t) {
      return ne.makeRotationZ(t), this.applyMatrix4(ne), this;
    }
    translate(t, e, i) {
      return ne.makeTranslation(t, e, i), this.applyMatrix4(ne), this;
    }
    scale(t, e, i) {
      return ne.makeScale(t, e, i), this.applyMatrix4(ne), this;
    }
    lookAt(t) {
      return (
        re.lookAt(t), re.updateMatrix(), this.applyMatrix4(re.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(se).negate(),
        this.translate(se.x, se.y, se.z),
        this
      );
    }
    setFromPoints(t) {
      const e = [];
      for (let i = 0, n = t.length; i < n; i++) {
        const n = t[i];
        e.push(n.x, n.y, n.z || 0);
      }
      return this.setAttribute("position", new Jt(e, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new _t());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingBox.set(
            new G(-1 / 0, -1 / 0, -1 / 0),
            new G(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            ae.setFromBufferAttribute(i),
              this.morphTargetsRelative
                ? (le.addVectors(this.boundingBox.min, ae.min),
                  this.boundingBox.expandByPoint(le),
                  le.addVectors(this.boundingBox.max, ae.max),
                  this.boundingBox.expandByPoint(le))
                : (this.boundingBox.expandByPoint(ae.min),
                  this.boundingBox.expandByPoint(ae.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new te());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingSphere.set(new G(), 1 / 0)
        );
      if (t) {
        const i = this.boundingSphere.center;
        if ((ae.setFromBufferAttribute(t), e))
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            oe.setFromBufferAttribute(i),
              this.morphTargetsRelative
                ? (le.addVectors(ae.min, oe.min),
                  ae.expandByPoint(le),
                  le.addVectors(ae.max, oe.max),
                  ae.expandByPoint(le))
                : (ae.expandByPoint(oe.min), ae.expandByPoint(oe.max));
          }
        ae.getCenter(i);
        let n = 0;
        for (let e = 0, r = t.count; e < r; e++)
          le.fromBufferAttribute(t, e),
            (n = Math.max(n, i.distanceToSquared(le)));
        if (e)
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = this.morphTargetsRelative;
            for (let e = 0, r = s.count; e < r; e++)
              le.fromBufferAttribute(s, e),
                a && (se.fromBufferAttribute(t, e), le.add(se)),
                (n = Math.max(n, i.distanceToSquared(le)));
          }
        (this.boundingSphere.radius = Math.sqrt(n)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      const t = this.index,
        e = this.attributes;
      if (
        null === t ||
        void 0 === e.position ||
        void 0 === e.normal ||
        void 0 === e.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
      const i = t.array,
        n = e.position.array,
        r = e.normal.array,
        s = e.uv.array,
        a = n.length / 3;
      void 0 === e.tangent &&
        this.setAttribute("tangent", new qt(new Float32Array(4 * a), 4));
      const o = e.tangent.array,
        l = [],
        h = [];
      for (let t = 0; t < a; t++) (l[t] = new G()), (h[t] = new G());
      const c = new G(),
        u = new G(),
        d = new G(),
        p = new Ot(),
        m = new Ot(),
        f = new Ot(),
        g = new G(),
        y = new G();
      function x(t, e, i) {
        c.fromArray(n, 3 * t),
          u.fromArray(n, 3 * e),
          d.fromArray(n, 3 * i),
          p.fromArray(s, 2 * t),
          m.fromArray(s, 2 * e),
          f.fromArray(s, 2 * i),
          u.sub(c),
          d.sub(c),
          m.sub(p),
          f.sub(p);
        const r = 1 / (m.x * f.y - f.x * m.y);
        isFinite(r) &&
          (g
            .copy(u)
            .multiplyScalar(f.y)
            .addScaledVector(d, -m.y)
            .multiplyScalar(r),
          y
            .copy(d)
            .multiplyScalar(m.x)
            .addScaledVector(u, -f.x)
            .multiplyScalar(r),
          l[t].add(g),
          l[e].add(g),
          l[i].add(g),
          h[t].add(y),
          h[e].add(y),
          h[i].add(y));
      }
      let v = this.groups;
      0 === v.length && (v = [{ start: 0, count: i.length }]);
      for (let t = 0, e = v.length; t < e; ++t) {
        const e = v[t],
          n = e.start;
        for (let t = n, r = n + e.count; t < r; t += 3)
          x(i[t + 0], i[t + 1], i[t + 2]);
      }
      const _ = new G(),
        b = new G(),
        M = new G(),
        w = new G();
      function S(t) {
        M.fromArray(r, 3 * t), w.copy(M);
        const e = l[t];
        _.copy(e),
          _.sub(M.multiplyScalar(M.dot(e))).normalize(),
          b.crossVectors(w, e);
        const i = b.dot(h[t]) < 0 ? -1 : 1;
        (o[4 * t] = _.x),
          (o[4 * t + 1] = _.y),
          (o[4 * t + 2] = _.z),
          (o[4 * t + 3] = i);
      }
      for (let t = 0, e = v.length; t < e; ++t) {
        const e = v[t],
          n = e.start;
        for (let t = n, r = n + e.count; t < r; t += 3)
          S(i[t + 0]), S(i[t + 1]), S(i[t + 2]);
      }
    }
    computeVertexNormals() {
      const t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        let i = this.getAttribute("normal");
        if (void 0 === i)
          (i = new qt(new Float32Array(3 * e.count), 3)),
            this.setAttribute("normal", i);
        else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
        const n = new G(),
          r = new G(),
          s = new G(),
          a = new G(),
          o = new G(),
          l = new G(),
          h = new G(),
          c = new G();
        if (t)
          for (let u = 0, d = t.count; u < d; u += 3) {
            const d = t.getX(u + 0),
              p = t.getX(u + 1),
              m = t.getX(u + 2);
            n.fromBufferAttribute(e, d),
              r.fromBufferAttribute(e, p),
              s.fromBufferAttribute(e, m),
              h.subVectors(s, r),
              c.subVectors(n, r),
              h.cross(c),
              a.fromBufferAttribute(i, d),
              o.fromBufferAttribute(i, p),
              l.fromBufferAttribute(i, m),
              a.add(h),
              o.add(h),
              l.add(h),
              i.setXYZ(d, a.x, a.y, a.z),
              i.setXYZ(p, o.x, o.y, o.z),
              i.setXYZ(m, l.x, l.y, l.z);
          }
        else
          for (let t = 0, a = e.count; t < a; t += 3)
            n.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              s.fromBufferAttribute(e, t + 2),
              h.subVectors(s, r),
              c.subVectors(n, r),
              h.cross(c),
              i.setXYZ(t + 0, h.x, h.y, h.z),
              i.setXYZ(t + 1, h.x, h.y, h.z),
              i.setXYZ(t + 2, h.x, h.y, h.z);
        this.normalizeNormals(), (i.needsUpdate = !0);
      }
    }
    merge(t, e) {
      if (!t || !t.isBufferGeometry)
        return void console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          t
        );
      void 0 === e &&
        ((e = 0),
        console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
      const i = this.attributes;
      for (const n in i) {
        if (void 0 === t.attributes[n]) continue;
        const r = i[n].array,
          s = t.attributes[n],
          a = s.array,
          o = s.itemSize * e,
          l = Math.min(a.length, r.length - o);
        for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t];
      }
      return this;
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, i = t.count; e < i; e++)
        le.fromBufferAttribute(t, e),
          le.normalize(),
          t.setXYZ(e, le.x, le.y, le.z);
    }
    toNonIndexed() {
      function t(t, e) {
        const i = t.array,
          n = t.itemSize,
          r = t.normalized,
          s = new i.constructor(e.length * n);
        let a = 0,
          o = 0;
        for (let r = 0, l = e.length; r < l; r++) {
          a = t.isInterleavedBufferAttribute
            ? e[r] * t.data.stride + t.offset
            : e[r] * n;
          for (let t = 0; t < n; t++) s[o++] = i[a++];
        }
        return new qt(s, n, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      const e = new he(),
        i = this.index.array,
        n = this.attributes;
      for (const r in n) {
        const s = t(n[r], i);
        e.setAttribute(r, s);
      }
      const r = this.morphAttributes;
      for (const n in r) {
        const s = [],
          a = r[n];
        for (let e = 0, n = a.length; e < n; e++) {
          const n = t(a[e], i);
          s.push(n);
        }
        e.morphAttributes[n] = s;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const s = this.groups;
      for (let t = 0, i = s.length; t < i; t++) {
        const i = s[t];
        e.addGroup(i.start, i.count, i.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t;
      }
      t.data = { attributes: {} };
      const e = this.index;
      null !== e &&
        (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array),
        });
      const i = this.attributes;
      for (const e in i) {
        const n = i[e];
        t.data.attributes[e] = n.toJSON(t.data);
      }
      const n = {};
      let r = !1;
      for (const e in this.morphAttributes) {
        const i = this.morphAttributes[e],
          s = [];
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          s.push(n.toJSON(t.data));
        }
        s.length > 0 && ((n[e] = s), (r = !0));
      }
      r &&
        ((t.data.morphAttributes = n),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const a = this.boundingSphere;
      return (
        null !== a &&
          (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius,
          }),
        t
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const e = {};
      this.name = t.name;
      const i = t.index;
      null !== i && this.setIndex(i.clone(e));
      const n = t.attributes;
      for (const t in n) {
        const i = n[t];
        this.setAttribute(t, i.clone(e));
      }
      const r = t.morphAttributes;
      for (const t in r) {
        const i = [],
          n = r[t];
        for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
        this.morphAttributes[t] = i;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const s = t.groups;
      for (let t = 0, e = s.length; t < e; t++) {
        const e = s[t];
        this.addGroup(e.start, e.count, e.materialIndex);
      }
      const a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      const o = t.boundingSphere;
      return (
        null !== o && (this.boundingSphere = o.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        void 0 !== t.parameters &&
          (this.parameters = Object.assign({}, t.parameters)),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  he.prototype.isBufferGeometry = !0;
  class ce extends xt {
    constructor(t, e = 1) {
      super(),
        (this.type = "Light"),
        (this.color = new Vt(t)),
        (this.intensity = e);
    }
    dispose() {}
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.color = this.color.getHex()),
        (e.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
      );
    }
  }
  ce.prototype.isLight = !0;
  const ue = new G(),
    de = new G(),
    pe = new rt();
  class me {
    constructor(t = new G(1, 0, 0), e = 0) {
      (this.normal = t), (this.constant = e);
    }
    set(t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    }
    setComponents(t, e, i, n) {
      return this.normal.set(t, e, i), (this.constant = n), this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    }
    setFromCoplanarPoints(t, e, i) {
      const n = ue.subVectors(i, e).cross(de.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(n, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e
        .copy(this.normal)
        .multiplyScalar(-this.distanceToPoint(t))
        .add(t);
    }
    intersectLine(t, e) {
      const i = t.delta(ue),
        n = this.normal.dot(i);
      if (0 === n)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / n;
      return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start),
        i = this.distanceToPoint(t.end);
      return (e < 0 && i > 0) || (i < 0 && e > 0);
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const i = e || pe.getNormalMatrix(t),
        n = this.coplanarPoint(ue).applyMatrix4(t),
        r = this.normal.applyMatrix3(i).normalize();
      return (this.constant = -n.dot(r)), this;
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  me.prototype.isPlane = !0;
  const fe = new te(),
    ge = new G();
  class ye {
    constructor(
      t = new me(),
      e = new me(),
      i = new me(),
      n = new me(),
      r = new me(),
      s = new me()
    ) {
      this.planes = [t, e, i, n, r, s];
    }
    set(t, e, i, n, r, s) {
      const a = this.planes;
      return (
        a[0].copy(t),
        a[1].copy(e),
        a[2].copy(i),
        a[3].copy(n),
        a[4].copy(r),
        a[5].copy(s),
        this
      );
    }
    copy(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
      return this;
    }
    setFromProjectionMatrix(t) {
      const e = this.planes,
        i = t.elements,
        n = i[0],
        r = i[1],
        s = i[2],
        a = i[3],
        o = i[4],
        l = i[5],
        h = i[6],
        c = i[7],
        u = i[8],
        d = i[9],
        p = i[10],
        m = i[11],
        f = i[12],
        g = i[13],
        y = i[14],
        x = i[15];
      return (
        e[0].setComponents(a - n, c - o, m - u, x - f).normalize(),
        e[1].setComponents(a + n, c + o, m + u, x + f).normalize(),
        e[2].setComponents(a + r, c + l, m + d, x + g).normalize(),
        e[3].setComponents(a - r, c - l, m - d, x - g).normalize(),
        e[4].setComponents(a - s, c - h, m - p, x - y).normalize(),
        e[5].setComponents(a + s, c + h, m + p, x + y).normalize(),
        this
      );
    }
    intersectsObject(t) {
      const e = t.geometry;
      return (
        null === e.boundingSphere && e.computeBoundingSphere(),
        fe.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
        this.intersectsSphere(fe)
      );
    }
    intersectsSprite(t) {
      return (
        fe.center.set(0, 0, 0),
        (fe.radius = 0.7071067811865476),
        fe.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(fe)
      );
    }
    intersectsSphere(t) {
      const e = this.planes,
        i = t.center,
        n = -t.radius;
      for (let t = 0; t < 6; t++) {
        if (e[t].distanceToPoint(i) < n) return !1;
      }
      return !0;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++) {
        const n = e[i];
        if (
          ((ge.x = n.normal.x > 0 ? t.max.x : t.min.x),
          (ge.y = n.normal.y > 0 ? t.max.y : t.min.y),
          (ge.z = n.normal.z > 0 ? t.max.z : t.min.z),
          n.distanceToPoint(ge) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const xe = new j(),
    ve = new G(),
    _e = new G();
  class be {
    constructor(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new Ot(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new j()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new ye()),
        (this._frameExtents = new Ot(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new Nt(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      const e = this.camera,
        i = this.matrix;
      ve.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(ve),
        _e.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(_e),
        e.updateMatrixWorld(),
        xe.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(xe),
        i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        i.multiply(e.projectionMatrix),
        i.multiply(e.matrixWorldInverse);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t = {};
      return (
        0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      );
    }
  }
  class Me extends xt {
    constructor() {
      super(),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new j()),
        (this.projectionMatrix = new j()),
        (this.projectionMatrixInverse = new j());
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        this
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Me.prototype.isCamera = !0;
  class we extends Me {
    constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, s = 2e3) {
      super(),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = i),
        (this.bottom = n),
        (this.near = r),
        (this.far = s),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    }
    setViewOffset(t, e, i, n, r, s) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = i),
        (this.view.offsetY = n),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        i = (this.right + this.left) / 2,
        n = (this.top + this.bottom) / 2;
      let r = i - t,
        s = i + t,
        a = n + e,
        o = n - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (s = r + t * this.view.width),
          (a -= e * this.view.offsetY),
          (o = a - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    }
  }
  we.prototype.isOrthographicCamera = !0;
  class Se extends be {
    constructor() {
      super(new we(-5, 5, 5, -5, 0.5, 500));
    }
  }
  Se.prototype.isDirectionalLightShadow = !0;
  class Te extends ce {
    constructor(t, e) {
      super(t, e),
        (this.type = "DirectionalLight"),
        this.position.copy(xt.DefaultUp),
        this.updateMatrix(),
        (this.target = new xt()),
        (this.shadow = new Se());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  Te.prototype.isDirectionalLight = !0;
  const Ee = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  const Ae = new (class {
    constructor(t, e, i) {
      const n = this;
      let r,
        s = !1,
        a = 0,
        o = 0;
      const l = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = i),
        (this.itemStart = function (t) {
          o++, !1 === s && void 0 !== n.onStart && n.onStart(t, a, o), (s = !0);
        }),
        (this.itemEnd = function (t) {
          a++,
            void 0 !== n.onProgress && n.onProgress(t, a, o),
            a === o && ((s = !1), void 0 !== n.onLoad && n.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== n.onError && n.onError(t);
        }),
        (this.resolveURL = function (t) {
          return r ? r(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (r = t), this;
        }),
        (this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (let e = 0, i = l.length; e < i; e += 2) {
            const i = l[e],
              n = l[e + 1];
            if ((i.global && (i.lastIndex = 0), i.test(t))) return n;
          }
          return null;
        });
    }
  })();
  class Re {
    constructor(t) {
      (this.manager = void 0 !== t ? t : Ae),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(t, e) {
      const i = this;
      return new Promise(function (n, r) {
        i.load(t, n, e, r);
      });
    }
    parse() {}
    setCrossOrigin(t) {
      return (this.crossOrigin = t), this;
    }
    setWithCredentials(t) {
      return (this.withCredentials = t), this;
    }
    setPath(t) {
      return (this.path = t), this;
    }
    setResourcePath(t) {
      return (this.resourcePath = t), this;
    }
    setRequestHeader(t) {
      return (this.requestHeader = t), this;
    }
  }
  const Le = {};
  class Ce extends Re {
    constructor(t) {
      super(t);
    }
    load(t, e, i, n) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = Ee.get(t);
      if (void 0 !== r)
        return (
          this.manager.itemStart(t),
          setTimeout(() => {
            e && e(r), this.manager.itemEnd(t);
          }, 0),
          r
        );
      if (void 0 !== Le[t])
        return void Le[t].push({ onLoad: e, onProgress: i, onError: n });
      (Le[t] = []), Le[t].push({ onLoad: e, onProgress: i, onError: n });
      const s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        a = this.mimeType,
        o = this.responseType;
      fetch(s)
        .then((e) => {
          if (200 === e.status || 0 === e.status) {
            if (
              (0 === e.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              "undefined" == typeof ReadableStream ||
                void 0 === e.body.getReader)
            )
              return e;
            const i = Le[t],
              n = e.body.getReader(),
              r = e.headers.get("Content-Length"),
              s = r ? parseInt(r) : 0,
              a = 0 !== s;
            let o = 0;
            const l = new ReadableStream({
              start(t) {
                !(function e() {
                  n.read().then(({ done: n, value: r }) => {
                    if (n) t.close();
                    else {
                      o += r.byteLength;
                      const n = new ProgressEvent("progress", {
                        lengthComputable: a,
                        loaded: o,
                        total: s,
                      });
                      for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t];
                        e.onProgress && e.onProgress(n);
                      }
                      t.enqueue(r), e();
                    }
                  });
                })();
              },
            });
            return new Response(l);
          }
          throw Error(
            `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
          );
        })
        .then((t) => {
          switch (o) {
            case "arraybuffer":
              return t.arrayBuffer();
            case "blob":
              return t.blob();
            case "document":
              return t
                .text()
                .then((t) => new DOMParser().parseFromString(t, a));
            case "json":
              return t.json();
            default:
              if (void 0 === a) return t.text();
              {
                const e = /charset="?([^;"\s]*)"?/i.exec(a),
                  i = e && e[1] ? e[1].toLowerCase() : void 0,
                  n = new TextDecoder(i);
                return t.arrayBuffer().then((t) => n.decode(t));
              }
          }
        })
        .then((e) => {
          Ee.add(t, e);
          const i = Le[t];
          delete Le[t];
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            n.onLoad && n.onLoad(e);
          }
        })
        .catch((e) => {
          const i = Le[t];
          if (void 0 === i) throw (this.manager.itemError(t), e);
          delete Le[t];
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            n.onError && n.onError(e);
          }
          this.manager.itemError(t);
        })
        .finally(() => {
          this.manager.itemEnd(t);
        }),
        this.manager.itemStart(t);
    }
    setResponseType(t) {
      return (this.responseType = t), this;
    }
    setMimeType(t) {
      return (this.mimeType = t), this;
    }
  }
  class Pe extends xt {
    constructor() {
      super(), (this.type = "Group");
    }
  }
  Pe.prototype.isGroup = !0;
  class Ie extends Re {
    constructor(t) {
      super(t),
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(t) {
      return (this.options = t), this;
    }
    load(t, e, i, n) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = Ee.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const a = {};
      (a.credentials =
        "anonymous" === this.crossOrigin ? "same-origin" : "include"),
        (a.headers = this.requestHeader),
        fetch(t, a)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return createImageBitmap(
              t,
              Object.assign(r.options, { colorSpaceConversion: "none" })
            );
          })
          .then(function (i) {
            Ee.add(t, i), e && e(i), r.manager.itemEnd(t);
          })
          .catch(function (e) {
            n && n(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }),
        r.manager.itemStart(t);
    }
  }
  Ie.prototype.isImageBitmapLoader = !0;
  const ze = new G();
  class De {
    constructor(t, e, i, n = !1) {
      (this.name = ""),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = i),
        (this.normalized = !0 === n);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, i = this.data.count; e < i; e++)
        (ze.x = this.getX(e)),
          (ze.y = this.getY(e)),
          (ze.z = this.getZ(e)),
          ze.applyMatrix4(t),
          this.setXYZ(e, ze.x, ze.y, ze.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, i = this.count; e < i; e++)
        (ze.x = this.getX(e)),
          (ze.y = this.getY(e)),
          (ze.z = this.getZ(e)),
          ze.applyNormalMatrix(t),
          this.setXYZ(e, ze.x, ze.y, ze.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, i = this.count; e < i; e++)
        (ze.x = this.getX(e)),
          (ze.y = this.getY(e)),
          (ze.z = this.getZ(e)),
          ze.transformDirection(t),
          this.setXYZ(e, ze.x, ze.y, ze.z);
      return this;
    }
    setX(t, e) {
      return (this.data.array[t * this.data.stride + this.offset] = e), this;
    }
    setY(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 1] = e), this
      );
    }
    setZ(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 2] = e), this
      );
    }
    setW(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 3] = e), this
      );
    }
    getX(t) {
      return this.data.array[t * this.data.stride + this.offset];
    }
    getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    }
    getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    }
    getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    }
    setXY(t, e, i) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = i),
        this
      );
    }
    setXYZ(t, e, i, n) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = i),
        (this.data.array[t + 2] = n),
        this
      );
    }
    setXYZW(t, e, i, n, r) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = i),
        (this.data.array[t + 2] = n),
        (this.data.array[t + 3] = r),
        this
      );
    }
    clone(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const i = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[i + e]);
        }
        return new qt(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized
        );
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new De(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    }
    toJSON(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const i = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[i + e]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    }
  }
  De.prototype.isInterleavedBufferAttribute = !0;
  const Ne = new G(),
    Oe = new G(),
    Be = new G(),
    Fe = new G(),
    He = new G(),
    Ue = new G(),
    ke = new G();
  class Ge {
    constructor(t = new G(), e = new G(0, 0, -1)) {
      (this.origin = t), (this.direction = e);
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, Ne)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const i = e.dot(this.direction);
      return i < 0
        ? e.copy(this.origin)
        : e.copy(this.direction).multiplyScalar(i).add(this.origin);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = Ne.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (Ne.copy(this.direction).multiplyScalar(e).add(this.origin),
          Ne.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, i, n) {
      Oe.copy(t).add(e).multiplyScalar(0.5),
        Be.copy(e).sub(t).normalize(),
        Fe.copy(this.origin).sub(Oe);
      const r = 0.5 * t.distanceTo(e),
        s = -this.direction.dot(Be),
        a = Fe.dot(this.direction),
        o = -Fe.dot(Be),
        l = Fe.lengthSq(),
        h = Math.abs(1 - s * s);
      let c, u, d, p;
      if (h > 0)
        if (((c = s * o - a), (u = s * a - o), (p = r * h), c >= 0))
          if (u >= -p)
            if (u <= p) {
              const t = 1 / h;
              (c *= t),
                (u *= t),
                (d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l);
            } else
              (u = r),
                (c = Math.max(0, -(s * u + a))),
                (d = -c * c + u * (u + 2 * o) + l);
          else
            (u = -r),
              (c = Math.max(0, -(s * u + a))),
              (d = -c * c + u * (u + 2 * o) + l);
        else
          u <= -p
            ? ((c = Math.max(0, -(-s * r + a))),
              (u = c > 0 ? -r : Math.min(Math.max(-r, -o), r)),
              (d = -c * c + u * (u + 2 * o) + l))
            : u <= p
            ? ((c = 0),
              (u = Math.min(Math.max(-r, -o), r)),
              (d = u * (u + 2 * o) + l))
            : ((c = Math.max(0, -(s * r + a))),
              (u = c > 0 ? r : Math.min(Math.max(-r, -o), r)),
              (d = -c * c + u * (u + 2 * o) + l));
      else
        (u = s > 0 ? -r : r),
          (c = Math.max(0, -(s * u + a))),
          (d = -c * c + u * (u + 2 * o) + l);
      return (
        i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
        n && n.copy(Be).multiplyScalar(u).add(Oe),
        d
      );
    }
    intersectSphere(t, e) {
      Ne.subVectors(t.center, this.origin);
      const i = Ne.dot(this.direction),
        n = Ne.dot(Ne) - i * i,
        r = t.radius * t.radius;
      if (n > r) return null;
      const s = Math.sqrt(r - n),
        a = i - s,
        o = i + s;
      return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const i = -(this.origin.dot(t.normal) + t.constant) / e;
      return i >= 0 ? i : null;
    }
    intersectPlane(t, e) {
      const i = this.distanceToPlane(t);
      return null === i ? null : this.at(i, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let i, n, r, s, a, o;
      const l = 1 / this.direction.x,
        h = 1 / this.direction.y,
        c = 1 / this.direction.z,
        u = this.origin;
      return (
        l >= 0
          ? ((i = (t.min.x - u.x) * l), (n = (t.max.x - u.x) * l))
          : ((i = (t.max.x - u.x) * l), (n = (t.min.x - u.x) * l)),
        h >= 0
          ? ((r = (t.min.y - u.y) * h), (s = (t.max.y - u.y) * h))
          : ((r = (t.max.y - u.y) * h), (s = (t.min.y - u.y) * h)),
        i > s || r > n
          ? null
          : ((r > i || i != i) && (i = r),
            (s < n || n != n) && (n = s),
            c >= 0
              ? ((a = (t.min.z - u.z) * c), (o = (t.max.z - u.z) * c))
              : ((a = (t.max.z - u.z) * c), (o = (t.min.z - u.z) * c)),
            i > o || a > n
              ? null
              : ((a > i || i != i) && (i = a),
                (o < n || n != n) && (n = o),
                n < 0 ? null : this.at(i >= 0 ? i : n, e)))
      );
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, Ne);
    }
    intersectTriangle(t, e, i, n, r) {
      He.subVectors(e, t), Ue.subVectors(i, t), ke.crossVectors(He, Ue);
      let s,
        a = this.direction.dot(ke);
      if (a > 0) {
        if (n) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        (s = -1), (a = -a);
      }
      Fe.subVectors(this.origin, t);
      const o = s * this.direction.dot(Ue.crossVectors(Fe, Ue));
      if (o < 0) return null;
      const l = s * this.direction.dot(He.cross(Fe));
      if (l < 0) return null;
      if (o + l > a) return null;
      const h = -s * Fe.dot(ke);
      return h < 0 ? null : this.at(h / a, r);
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  let Ve = 0;
  class We extends $ {
    constructor() {
      super(),
        Object.defineProperty(this, "id", { value: Ve++ }),
        (this.uuid = c()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = 100),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = T),
        (this.stencilZFail = T),
        (this.stencilZPass = T),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const i = t[e];
          if (void 0 === i) {
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
            continue;
          }
          if ("shading" === e) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === i);
            continue;
          }
          const n = this[e];
          void 0 !== n
            ? n && n.isColor
              ? n.set(i)
              : n && n.isVector3 && i && i.isVector3
              ? n.copy(i)
              : (this[e] = i)
            : console.warn(
                "THREE." +
                  this.type +
                  ": '" +
                  e +
                  "' is not a property of this material."
              );
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = { textures: {}, images: {} });
      const i = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function n(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          delete n.metadata, e.push(n);
        }
        return e;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        void 0 !== this.roughness && (i.roughness = this.roughness),
        void 0 !== this.metalness && (i.metalness = this.metalness),
        void 0 !== this.sheen && (i.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (i.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (i.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (i.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (i.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (i.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (i.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (i.shininess = this.shininess),
        void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (i.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (i.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((i.lightMap = this.lightMap.toJSON(t).uuid),
          (i.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((i.aoMap = this.aoMap.toJSON(t).uuid),
          (i.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
          (i.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((i.normalMap = this.normalMap.toJSON(t).uuid),
          (i.normalMapType = this.normalMapType),
          (i.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
          (i.displacementScale = this.displacementScale),
          (i.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (i.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((i.envMap = this.envMap.toJSON(t).uuid),
          void 0 !== this.combine && (i.combine = this.combine)),
        void 0 !== this.envMapIntensity &&
          (i.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (i.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (i.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (i.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (i.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance &&
          (i.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (i.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (i.size = this.size),
        null !== this.shadowSide && (i.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (i.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (i.blending = this.blending),
        0 !== this.side && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        !0 === this.transparent && (i.transparent = this.transparent),
        (i.depthFunc = this.depthFunc),
        (i.depthTest = this.depthTest),
        (i.depthWrite = this.depthWrite),
        (i.colorWrite = this.colorWrite),
        (i.stencilWrite = this.stencilWrite),
        (i.stencilWriteMask = this.stencilWriteMask),
        (i.stencilFunc = this.stencilFunc),
        (i.stencilRef = this.stencilRef),
        (i.stencilFuncMask = this.stencilFuncMask),
        (i.stencilFail = this.stencilFail),
        (i.stencilZFail = this.stencilZFail),
        (i.stencilZPass = this.stencilZPass),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (i.rotation = this.rotation),
        !0 === this.polygonOffset && (i.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (i.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (i.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (i.linewidth = this.linewidth),
        void 0 !== this.dashSize && (i.dashSize = this.dashSize),
        void 0 !== this.gapSize && (i.gapSize = this.gapSize),
        void 0 !== this.scale && (i.scale = this.scale),
        !0 === this.dithering && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        !0 === this.alphaToCoverage &&
          (i.alphaToCoverage = this.alphaToCoverage),
        !0 === this.premultipliedAlpha &&
          (i.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (i.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (i.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (i.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (i.flatShading = this.flatShading),
        !1 === this.visible && (i.visible = !1),
        !1 === this.toneMapped && (i.toneMapped = !1),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        e)
      ) {
        const e = n(t.textures),
          r = n(t.images);
        e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
      }
      return i;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.name = t.name),
        (this.fog = t.fog),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      const e = t.clippingPlanes;
      let i = null;
      if (null !== e) {
        const t = e.length;
        i = new Array(t);
        for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
      }
      return (
        (this.clippingPlanes = i),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  We.prototype.isMaterial = !0;
  class je extends We {
    constructor(t) {
      super(),
        (this.type = "LineBasicMaterial"),
        (this.color = new Vt(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        this
      );
    }
  }
  je.prototype.isLineBasicMaterial = !0;
  const qe = new G(),
    Xe = new G(),
    Ye = new j(),
    Je = new Ge(),
    Ze = new te();
  class Ke extends xt {
    constructor(t = new he(), e = new je()) {
      super(),
        (this.type = "Line"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    computeLineDistances() {
      const t = this.geometry;
      if (t.isBufferGeometry)
        if (null === t.index) {
          const e = t.attributes.position,
            i = [0];
          for (let t = 1, n = e.count; t < n; t++)
            qe.fromBufferAttribute(e, t - 1),
              Xe.fromBufferAttribute(e, t),
              (i[t] = i[t - 1]),
              (i[t] += qe.distanceTo(Xe));
          t.setAttribute("lineDistance", new Jt(i, 1));
        } else
          console.warn(
            "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else
        t.isGeometry &&
          console.error(
            "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      return this;
    }
    raycast(t, e) {
      const i = this.geometry,
        n = this.matrixWorld,
        r = t.params.Line.threshold,
        s = i.drawRange;
      if (
        (null === i.boundingSphere && i.computeBoundingSphere(),
        Ze.copy(i.boundingSphere),
        Ze.applyMatrix4(n),
        (Ze.radius += r),
        !1 === t.ray.intersectsSphere(Ze))
      )
        return;
      Ye.copy(n).invert(), Je.copy(t.ray).applyMatrix4(Ye);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = new G(),
        h = new G(),
        c = new G(),
        u = new G(),
        d = this.isLineSegments ? 2 : 1;
      if (i.isBufferGeometry) {
        const n = i.index,
          r = i.attributes.position;
        if (null !== n) {
          for (
            let i = Math.max(0, s.start),
              a = Math.min(n.count, s.start + s.count) - 1;
            i < a;
            i += d
          ) {
            const s = n.getX(i),
              a = n.getX(i + 1);
            l.fromBufferAttribute(r, s), h.fromBufferAttribute(r, a);
            if (Je.distanceSqToSegment(l, h, u, c) > o) continue;
            u.applyMatrix4(this.matrixWorld);
            const d = t.ray.origin.distanceTo(u);
            d < t.near ||
              d > t.far ||
              e.push({
                distance: d,
                point: c.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        } else {
          for (
            let i = Math.max(0, s.start),
              n = Math.min(r.count, s.start + s.count) - 1;
            i < n;
            i += d
          ) {
            l.fromBufferAttribute(r, i), h.fromBufferAttribute(r, i + 1);
            if (Je.distanceSqToSegment(l, h, u, c) > o) continue;
            u.applyMatrix4(this.matrixWorld);
            const n = t.ray.origin.distanceTo(u);
            n < t.near ||
              n > t.far ||
              e.push({
                distance: n,
                point: c.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        }
      } else
        i.isGeometry &&
          console.error(
            "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
    }
    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes,
          i = Object.keys(e);
        if (i.length > 0) {
          const t = e[i[0]];
          if (void 0 !== t) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e].name || String(e);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[i] = e);
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e &&
          e.length > 0 &&
          console.error(
            "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    }
  }
  Ke.prototype.isLine = !0;
  class Qe extends Ke {
    constructor(t, e) {
      super(t, e), (this.type = "LineLoop");
    }
  }
  Qe.prototype.isLineLoop = !0;
  const $e = new G(),
    ti = new G();
  class ei extends Ke {
    constructor(t, e) {
      super(t, e), (this.type = "LineSegments");
    }
    computeLineDistances() {
      const t = this.geometry;
      if (t.isBufferGeometry)
        if (null === t.index) {
          const e = t.attributes.position,
            i = [];
          for (let t = 0, n = e.count; t < n; t += 2)
            $e.fromBufferAttribute(e, t),
              ti.fromBufferAttribute(e, t + 1),
              (i[t] = 0 === t ? 0 : i[t - 1]),
              (i[t + 1] = i[t] + $e.distanceTo(ti));
          t.setAttribute("lineDistance", new Jt(i, 1));
        } else
          console.warn(
            "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else
        t.isGeometry &&
          console.error(
            "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      return this;
    }
  }
  ei.prototype.isLineSegments = !0;
  class ii {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      let e = "";
      for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
      try {
        return decodeURIComponent(escape(e));
      } catch (t) {
        return e;
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1);
    }
    static resolveURL(t, e) {
      return "string" != typeof t || "" === t
        ? ""
        : (/^https?:\/\//i.test(e) &&
            /^\//.test(t) &&
            (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(t) ||
          /^data:.*,.*$/i.test(t) ||
          /^blob:.*$/i.test(t)
            ? t
            : e + t);
    }
  }
  let ni;
  let ri = 0;
  class si extends $ {
    constructor(
      t = si.DEFAULT_IMAGE,
      e = si.DEFAULT_MAPPING,
      i = 1001,
      n = 1001,
      r = 1006,
      s = 1008,
      a = 1023,
      o = 1009,
      l = 1,
      h = 3e3
    ) {
      super(),
        Object.defineProperty(this, "id", { value: ri++ }),
        (this.uuid = c()),
        (this.name = ""),
        (this.image = t),
        (this.mipmaps = []),
        (this.mapping = e),
        (this.wrapS = i),
        (this.wrapT = n),
        (this.magFilter = r),
        (this.minFilter = s),
        (this.anisotropy = l),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = o),
        (this.offset = new Ot(0, 0)),
        (this.repeat = new Ot(1, 1)),
        (this.center = new Ot(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new rt()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = h),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.image = t.image),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.encoding = t.encoding),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      if (void 0 !== this.image) {
        const n = this.image;
        if (
          (void 0 === n.uuid && (n.uuid = c()),
          !e && void 0 === t.images[n.uuid])
        ) {
          let e;
          if (Array.isArray(n)) {
            e = [];
            for (let t = 0, i = n.length; t < i; t++)
              n[t].isDataTexture ? e.push(ai(n[t].image)) : e.push(ai(n[t]));
          } else e = ai(n);
          t.images[n.uuid] = { uuid: n.uuid, url: e };
        }
        i.image = n.uuid;
      }
      return (
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        e || (t.textures[this.uuid] = i),
        i
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (300 !== this.mapping) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case f:
            t.x = t.x - Math.floor(t.x);
            break;
          case g:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case y:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case f:
            t.y = t.y - Math.floor(t.y);
            break;
          case g:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case y:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  function ai(t) {
    return ("undefined" != typeof HTMLImageElement &&
      t instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ? class {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === ni && (ni = ee("canvas")),
                (ni.width = t.width),
                (ni.height = t.height);
              const i = ni.getContext("2d");
              t instanceof ImageData
                ? i.putImageData(t, 0, 0)
                : i.drawImage(t, 0, 0, t.width, t.height),
                (e = ni);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
          static sRGBToLinear(t) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const e = ee("canvas");
              (e.width = t.width), (e.height = t.height);
              const i = e.getContext("2d");
              i.drawImage(t, 0, 0, t.width, t.height);
              const n = i.getImageData(0, 0, t.width, t.height),
                r = n.data;
              for (let t = 0; t < r.length; t++) r[t] = 255 * kt(r[t] / 255);
              return i.putImageData(n, 0, 0), e;
            }
            if (t.data) {
              const e = t.data.slice(0);
              for (let t = 0; t < e.length; t++)
                e instanceof Uint8Array || e instanceof Uint8ClampedArray
                  ? (e[t] = Math.floor(255 * kt(e[t] / 255)))
                  : (e[t] = kt(e[t]));
              return { data: e, width: t.width, height: t.height };
            }
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
          }
        }.getDataURL(t)
      : t.data
      ? {
          data: Array.prototype.slice.call(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  (si.DEFAULT_IMAGE = void 0),
    (si.DEFAULT_MAPPING = 300),
    (si.prototype.isTexture = !0);
  class oi extends Re {
    constructor(t) {
      super(t);
    }
    load(t, e, i, n) {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = Ee.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const a = ee("img");
      function o() {
        h(), Ee.add(t, this), e && e(this), r.manager.itemEnd(t);
      }
      function l(e) {
        h(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }
      function h() {
        a.removeEventListener("load", o, !1),
          a.removeEventListener("error", l, !1);
      }
      return (
        a.addEventListener("load", o, !1),
        a.addEventListener("error", l, !1),
        "data:" !== t.substr(0, 5) &&
          void 0 !== this.crossOrigin &&
          (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        (a.src = t),
        a
      );
    }
  }
  class li extends Re {
    constructor(t) {
      super(t);
    }
    load(t, e, i, n) {
      const r = new si(),
        s = new oi(this.manager);
      return (
        s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(
          t,
          function (t) {
            (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
          },
          i,
          n
        ),
        r
      );
    }
  }
  class hi extends Me {
    constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
      super(),
        (this.type = "PerspectiveCamera"),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = i),
        (this.far = n),
        (this.focus = 10),
        (this.aspect = e),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    }
    setFocalLength(t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * h * Math.atan(e)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(0.5 * l * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    }
    getEffectiveFOV() {
      return 2 * h * Math.atan(Math.tan(0.5 * l * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e, i, n, r, s) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = i),
        (this.view.offsetY = n),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = (t * Math.tan(0.5 * l * this.fov)) / this.zoom,
        i = 2 * e,
        n = this.aspect * i,
        r = -0.5 * n;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          a = s.fullHeight;
        (r += (s.offsetX * n) / t),
          (e -= (s.offsetY * i) / a),
          (n *= s.width / t),
          (i *= s.height / a);
      }
      const a = this.filmOffset;
      0 !== a && (r += (t * a) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    }
  }
  hi.prototype.isPerspectiveCamera = !0;
  class ci extends be {
    constructor() {
      super(new hi(50, 1, 0.5, 500)), (this.focus = 1);
    }
    updateMatrices(t) {
      const e = this.camera,
        i = 2 * h * t.angle * this.focus,
        n = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      (i === e.fov && n === e.aspect && r === e.far) ||
        ((e.fov = i), (e.aspect = n), (e.far = r), e.updateProjectionMatrix()),
        super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), (this.focus = t.focus), this;
    }
  }
  ci.prototype.isSpotLightShadow = !0;
  class ui extends ce {
    constructor(t, e, i = 0, n = Math.PI / 3, r = 0, s = 1) {
      super(t, e),
        (this.type = "SpotLight"),
        this.position.copy(xt.DefaultUp),
        this.updateMatrix(),
        (this.target = new xt()),
        (this.distance = i),
        (this.angle = n),
        (this.penumbra = r),
        (this.decay = s),
        (this.shadow = new ci());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.distance = t.distance),
        (this.angle = t.angle),
        (this.penumbra = t.penumbra),
        (this.decay = t.decay),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  ui.prototype.isSpotLight = !0;
  const di = new G(),
    pi = new G(),
    mi = new G(),
    fi = new G(),
    gi = new G(),
    yi = new G(),
    xi = new G(),
    vi = new G(),
    _i = new G(),
    bi = new G();
  class Mi {
    constructor(t = new G(), e = new G(), i = new G()) {
      (this.a = t), (this.b = e), (this.c = i);
    }
    static getNormal(t, e, i, n) {
      n.subVectors(i, e), di.subVectors(t, e), n.cross(di);
      const r = n.lengthSq();
      return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
    }
    static getBarycoord(t, e, i, n, r) {
      di.subVectors(n, e), pi.subVectors(i, e), mi.subVectors(t, e);
      const s = di.dot(di),
        a = di.dot(pi),
        o = di.dot(mi),
        l = pi.dot(pi),
        h = pi.dot(mi),
        c = s * l - a * a;
      if (0 === c) return r.set(-2, -1, -1);
      const u = 1 / c,
        d = (l * o - a * h) * u,
        p = (s * h - a * o) * u;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(t, e, i, n) {
      return (
        this.getBarycoord(t, e, i, n, fi),
        fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1
      );
    }
    static getUV(t, e, i, n, r, s, a, o) {
      return (
        this.getBarycoord(t, e, i, n, fi),
        o.set(0, 0),
        o.addScaledVector(r, fi.x),
        o.addScaledVector(s, fi.y),
        o.addScaledVector(a, fi.z),
        o
      );
    }
    static isFrontFacing(t, e, i, n) {
      return di.subVectors(i, e), pi.subVectors(t, e), di.cross(pi).dot(n) < 0;
    }
    set(t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
    }
    setFromPointsAndIndices(t, e, i, n) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
    }
    setFromAttributeAndIndices(t, e, i, n) {
      return (
        this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, i),
        this.c.fromBufferAttribute(t, n),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return (
        di.subVectors(this.c, this.b),
        pi.subVectors(this.a, this.b),
        0.5 * di.cross(pi).length()
      );
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return Mi.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return Mi.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getUV(t, e, i, n, r) {
      return Mi.getUV(t, this.a, this.b, this.c, e, i, n, r);
    }
    containsPoint(t) {
      return Mi.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return Mi.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const i = this.a,
        n = this.b,
        r = this.c;
      let s, a;
      gi.subVectors(n, i), yi.subVectors(r, i), vi.subVectors(t, i);
      const o = gi.dot(vi),
        l = yi.dot(vi);
      if (o <= 0 && l <= 0) return e.copy(i);
      _i.subVectors(t, n);
      const h = gi.dot(_i),
        c = yi.dot(_i);
      if (h >= 0 && c <= h) return e.copy(n);
      const u = o * c - h * l;
      if (u <= 0 && o >= 0 && h <= 0)
        return (s = o / (o - h)), e.copy(i).addScaledVector(gi, s);
      bi.subVectors(t, r);
      const d = gi.dot(bi),
        p = yi.dot(bi);
      if (p >= 0 && d <= p) return e.copy(r);
      const m = d * l - o * p;
      if (m <= 0 && l >= 0 && p <= 0)
        return (a = l / (l - p)), e.copy(i).addScaledVector(yi, a);
      const f = h * p - d * c;
      if (f <= 0 && c - h >= 0 && d - p >= 0)
        return (
          xi.subVectors(r, n),
          (a = (c - h) / (c - h + (d - p))),
          e.copy(n).addScaledVector(xi, a)
        );
      const g = 1 / (f + m + u);
      return (
        (s = m * g),
        (a = u * g),
        e.copy(i).addScaledVector(gi, s).addScaledVector(yi, a)
      );
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }
  class wi extends We {
    constructor(t) {
      super(),
        (this.type = "MeshBasicMaterial"),
        (this.color = new Vt(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        this
      );
    }
  }
  wi.prototype.isMeshBasicMaterial = !0;
  const Si = new j(),
    Ti = new Ge(),
    Ei = new te(),
    Ai = new G(),
    Ri = new G(),
    Li = new G(),
    Ci = new G(),
    Pi = new G(),
    Ii = new G(),
    zi = new G(),
    Di = new G(),
    Ni = new G(),
    Oi = new Ot(),
    Bi = new Ot(),
    Fi = new Ot(),
    Hi = new G(),
    Ui = new G();
  class ki extends xt {
    constructor(t = new he(), e = new wi()) {
      super(),
        (this.type = "Mesh"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t) {
      return (
        super.copy(t),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary
          )),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes,
          i = Object.keys(e);
        if (i.length > 0) {
          const t = e[i[0]];
          if (void 0 !== t) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e].name || String(e);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[i] = e);
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e &&
          e.length > 0 &&
          console.error(
            "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    }
    raycast(t, e) {
      const i = this.geometry,
        n = this.material,
        r = this.matrixWorld;
      if (void 0 === n) return;
      if (
        (null === i.boundingSphere && i.computeBoundingSphere(),
        Ei.copy(i.boundingSphere),
        Ei.applyMatrix4(r),
        !1 === t.ray.intersectsSphere(Ei))
      )
        return;
      if (
        (Si.copy(r).invert(),
        Ti.copy(t.ray).applyMatrix4(Si),
        null !== i.boundingBox && !1 === Ti.intersectsBox(i.boundingBox))
      )
        return;
      let s;
      if (i.isBufferGeometry) {
        const r = i.index,
          a = i.attributes.position,
          o = i.morphAttributes.position,
          l = i.morphTargetsRelative,
          h = i.attributes.uv,
          c = i.attributes.uv2,
          u = i.groups,
          d = i.drawRange;
        if (null !== r)
          if (Array.isArray(n))
            for (let i = 0, p = u.length; i < p; i++) {
              const p = u[i],
                m = n[p.materialIndex];
              for (
                let i = Math.max(p.start, d.start),
                  n = Math.min(
                    r.count,
                    Math.min(p.start + p.count, d.start + d.count)
                  );
                i < n;
                i += 3
              ) {
                const n = r.getX(i),
                  u = r.getX(i + 1),
                  d = r.getX(i + 2);
                (s = Gi(this, m, t, Ti, a, o, l, h, c, n, u, d)),
                  s &&
                    ((s.faceIndex = Math.floor(i / 3)),
                    (s.face.materialIndex = p.materialIndex),
                    e.push(s));
              }
            }
          else {
            for (
              let i = Math.max(0, d.start),
                u = Math.min(r.count, d.start + d.count);
              i < u;
              i += 3
            ) {
              const u = r.getX(i),
                d = r.getX(i + 1),
                p = r.getX(i + 2);
              (s = Gi(this, n, t, Ti, a, o, l, h, c, u, d, p)),
                s && ((s.faceIndex = Math.floor(i / 3)), e.push(s));
            }
          }
        else if (void 0 !== a)
          if (Array.isArray(n))
            for (let i = 0, r = u.length; i < r; i++) {
              const r = u[i],
                p = n[r.materialIndex];
              for (
                let i = Math.max(r.start, d.start),
                  n = Math.min(
                    a.count,
                    Math.min(r.start + r.count, d.start + d.count)
                  );
                i < n;
                i += 3
              ) {
                (s = Gi(this, p, t, Ti, a, o, l, h, c, i, i + 1, i + 2)),
                  s &&
                    ((s.faceIndex = Math.floor(i / 3)),
                    (s.face.materialIndex = r.materialIndex),
                    e.push(s));
              }
            }
          else {
            for (
              let i = Math.max(0, d.start),
                r = Math.min(a.count, d.start + d.count);
              i < r;
              i += 3
            ) {
              (s = Gi(this, n, t, Ti, a, o, l, h, c, i, i + 1, i + 2)),
                s && ((s.faceIndex = Math.floor(i / 3)), e.push(s));
            }
          }
      } else
        i.isGeometry &&
          console.error(
            "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
    }
  }
  function Gi(t, e, i, n, r, s, a, o, l, h, c, u) {
    Ai.fromBufferAttribute(r, h),
      Ri.fromBufferAttribute(r, c),
      Li.fromBufferAttribute(r, u);
    const d = t.morphTargetInfluences;
    if (s && d) {
      zi.set(0, 0, 0), Di.set(0, 0, 0), Ni.set(0, 0, 0);
      for (let t = 0, e = s.length; t < e; t++) {
        const e = d[t],
          i = s[t];
        0 !== e &&
          (Ci.fromBufferAttribute(i, h),
          Pi.fromBufferAttribute(i, c),
          Ii.fromBufferAttribute(i, u),
          a
            ? (zi.addScaledVector(Ci, e),
              Di.addScaledVector(Pi, e),
              Ni.addScaledVector(Ii, e))
            : (zi.addScaledVector(Ci.sub(Ai), e),
              Di.addScaledVector(Pi.sub(Ri), e),
              Ni.addScaledVector(Ii.sub(Li), e)));
      }
      Ai.add(zi), Ri.add(Di), Li.add(Ni);
    }
    t.isSkinnedMesh &&
      (t.boneTransform(h, Ai), t.boneTransform(c, Ri), t.boneTransform(u, Li));
    const p = (function (t, e, i, n, r, s, a, o) {
      let l;
      if (
        ((l =
          1 === e.side
            ? n.intersectTriangle(a, s, r, !0, o)
            : n.intersectTriangle(r, s, a, 2 !== e.side, o)),
        null === l)
      )
        return null;
      Ui.copy(o), Ui.applyMatrix4(t.matrixWorld);
      const h = i.ray.origin.distanceTo(Ui);
      return h < i.near || h > i.far
        ? null
        : { distance: h, point: Ui.clone(), object: t };
    })(t, e, i, n, Ai, Ri, Li, Hi);
    if (p) {
      o &&
        (Oi.fromBufferAttribute(o, h),
        Bi.fromBufferAttribute(o, c),
        Fi.fromBufferAttribute(o, u),
        (p.uv = Mi.getUV(Hi, Ai, Ri, Li, Oi, Bi, Fi, new Ot()))),
        l &&
          (Oi.fromBufferAttribute(l, h),
          Bi.fromBufferAttribute(l, c),
          Fi.fromBufferAttribute(l, u),
          (p.uv2 = Mi.getUV(Hi, Ai, Ri, Li, Oi, Bi, Fi, new Ot())));
      const t = { a: h, b: c, c: u, normal: new G(), materialIndex: 0 };
      Mi.getNormal(Ai, Ri, Li, t.normal), (p.face = t);
    }
    return p;
  }
  ki.prototype.isMesh = !0;
  const Vi = new G(),
    Wi = new Nt(),
    ji = new Nt(),
    qi = new G(),
    Xi = new j();
  class Yi extends ki {
    constructor(t, e) {
      super(t, e),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new j()),
        (this.bindMatrixInverse = new j());
    }
    copy(t) {
      return (
        super.copy(t),
        (this.bindMode = t.bindMode),
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        (this.skeleton = t.skeleton),
        this
      );
    }
    bind(t, e) {
      (this.skeleton = t),
        void 0 === e &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t = new Nt(),
        e = this.geometry.attributes.skinWeight;
      for (let i = 0, n = e.count; i < n; i++) {
        (t.x = e.getX(i)),
          (t.y = e.getY(i)),
          (t.z = e.getZ(i)),
          (t.w = e.getW(i));
        const n = 1 / t.manhattanLength();
        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
          e.setXYZW(i, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        "attached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    }
    boneTransform(t, e) {
      const i = this.skeleton,
        n = this.geometry;
      Wi.fromBufferAttribute(n.attributes.skinIndex, t),
        ji.fromBufferAttribute(n.attributes.skinWeight, t),
        Vi.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let t = 0; t < 4; t++) {
        const n = ji.getComponent(t);
        if (0 !== n) {
          const r = Wi.getComponent(t);
          Xi.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
            e.addScaledVector(qi.copy(Vi).applyMatrix4(Xi), n);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  }
  Yi.prototype.isSkinnedMesh = !0;
  class Ji extends si {
    constructor(
      t = null,
      e = 1,
      i = 1,
      n,
      r,
      s,
      a,
      o,
      l = 1003,
      h = 1003,
      c,
      u
    ) {
      super(null, s, a, o, l, h, n, r, c, u),
        (this.image = { data: t, width: e, height: i }),
        (this.magFilter = l),
        (this.minFilter = h),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  Ji.prototype.isDataTexture = !0;
  const Zi = new j(),
    Ki = new j();
  class Qi {
    constructor(t = [], e = []) {
      (this.uuid = c()),
        (this.bones = t.slice(0)),
        (this.boneInverses = e),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        (this.boneTextureSize = 0),
        (this.frame = -1),
        this.init();
    }
    init() {
      const t = this.bones,
        e = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)
      )
        this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new j());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = new j();
        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
          this.boneInverses.push(e);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e &&
          (e.parent && e.parent.isBone
            ? (e.matrix.copy(e.parent.matrixWorld).invert(),
              e.matrix.multiply(e.matrixWorld))
            : e.matrix.copy(e.matrixWorld),
          e.matrix.decompose(e.position, e.quaternion, e.scale));
      }
    }
    update() {
      const t = this.bones,
        e = this.boneInverses,
        i = this.boneMatrices,
        n = this.boneTexture;
      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n] ? t[n].matrixWorld : Ki;
        Zi.multiplyMatrices(r, e[n]), Zi.toArray(i, 16 * n);
      }
      null !== n && (n.needsUpdate = !0);
    }
    clone() {
      return new Qi(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(4 * this.bones.length);
      var e;
      (e = t),
        (t = Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))),
        (t = Math.max(t, 4));
      const i = new Float32Array(t * t * 4);
      i.set(this.boneMatrices);
      const n = new Ji(i, t, t, 1023, 1015);
      return (
        (n.needsUpdate = !0),
        (this.boneMatrices = i),
        (this.boneTexture = n),
        (this.boneTextureSize = t),
        this
      );
    }
    getBoneByName(t) {
      for (let e = 0, i = this.bones.length; e < i; e++) {
        const i = this.bones[e];
        if (i.name === t) return i;
      }
    }
    dispose() {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let i = 0, n = t.bones.length; i < n; i++) {
        const n = t.bones[i];
        let r = e[n];
        void 0 === r &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", n),
          (r = new vt())),
          this.bones.push(r),
          this.boneInverses.push(new j().fromArray(t.boneInverses[i]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      t.uuid = this.uuid;
      const e = this.bones,
        i = this.boneInverses;
      for (let n = 0, r = e.length; n < r; n++) {
        const r = e[n];
        t.bones.push(r.uuid);
        const s = i[n];
        t.boneInverses.push(s.toArray());
      }
      return t;
    }
  }
  const $i = "\\[\\]\\.:\\/",
    tn = new RegExp("[\\[\\]\\.:\\/]", "g"),
    en = "[^\\[\\]\\.:\\/]",
    nn = "[^" + $i.replace("\\.", "") + "]",
    rn = /((?:WC+[\/:])*)/.source.replace("WC", en),
    sn = /(WCOD+)?/.source.replace("WCOD", nn),
    an = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", en),
    on = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", en),
    ln = new RegExp("^" + rn + sn + an + on + "$"),
    hn = ["material", "materials", "bones"];
  class cn {
    constructor(t, e, i) {
      (this.path = e),
        (this.parsedPath = i || cn.parseTrackName(e)),
        (this.node = cn.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(t, e, i) {
      return t && t.isAnimationObjectGroup
        ? new cn.Composite(t, e, i)
        : new cn(t, e, i);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(tn, "");
    }
    static parseTrackName(t) {
      const e = ln.exec(t);
      if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const i = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        n = i.nodeName && i.nodeName.lastIndexOf(".");
      if (void 0 !== n && -1 !== n) {
        const t = i.nodeName.substring(n + 1);
        -1 !== hn.indexOf(t) &&
          ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = t));
      }
      if (null === i.propertyName || 0 === i.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t
        );
      return i;
    }
    static findNode(t, e) {
      if (
        !e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const i = t.skeleton.getBoneByName(e);
        if (void 0 !== i) return i;
      }
      if (t.children) {
        const i = function (t) {
            for (let n = 0; n < t.length; n++) {
              const r = t[n];
              if (r.name === e || r.uuid === e) return r;
              const s = i(r.children);
              if (s) return s;
            }
            return null;
          },
          n = i(t.children);
        if (n) return n;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath,
        i = e.objectName,
        n = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t ||
          ((t = cn.findNode(this.rootNode, e.nodeName) || this.rootNode),
          (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path +
            " but it wasn't found."
        );
      if (i) {
        let n = e.objectIndex;
        switch (i) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === n) {
                n = e;
                break;
              }
            break;
          default:
            if (void 0 === t[i])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            t = t[i];
        }
        if (void 0 !== n) {
          if (void 0 === t[n])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t
            );
          t = t[n];
        }
      }
      const s = t[n];
      if (void 0 === s) {
        const i = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            i +
            "." +
            n +
            " but it wasn't found.",
          t
        );
      }
      let a = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (a = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (a = this.Versioning.MatrixWorldNeedsUpdate);
      let o = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === n) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!t.geometry.isBufferGeometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
              this
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (o = this.BindingType.ArrayElement),
          (this.resolvedProperty = s),
          (this.propertyIndex = r);
      } else
        void 0 !== s.fromArray && void 0 !== s.toArray
          ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
          : Array.isArray(s)
          ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
          : (this.propertyName = n);
      (this.getValue = this.GetterByBindingType[o]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (cn.Composite = class {
    constructor(t, e, i) {
      const n = i || cn.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, n));
    }
    getValue(t, e) {
      this.bind();
      const i = this._targetGroup.nCachedObjects_,
        n = this._bindings[i];
      void 0 !== n && n.getValue(t, e);
    }
    setValue(t, e) {
      const i = this._bindings;
      for (
        let n = this._targetGroup.nCachedObjects_, r = i.length;
        n !== r;
        ++n
      )
        i[n].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, i = t.length;
        e !== i;
        ++e
      )
        t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, i = t.length;
        e !== i;
        ++e
      )
        t[e].unbind();
    }
  }),
    (cn.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (cn.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (cn.prototype.GetterByBindingType = [
      cn.prototype._getValue_direct,
      cn.prototype._getValue_array,
      cn.prototype._getValue_arrayElement,
      cn.prototype._getValue_toArray,
    ]),
    (cn.prototype.SetterByBindingTypeAndVersioning = [
      [
        cn.prototype._setValue_direct,
        cn.prototype._setValue_direct_setNeedsUpdate,
        cn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        cn.prototype._setValue_array,
        cn.prototype._setValue_array_setNeedsUpdate,
        cn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        cn.prototype._setValue_arrayElement,
        cn.prototype._setValue_arrayElement_setNeedsUpdate,
        cn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        cn.prototype._setValue_fromArray,
        cn.prototype._setValue_fromArray_setNeedsUpdate,
        cn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]);
  class un extends We {
    constructor(t) {
      super(),
        (this.type = "PointsMaterial"),
        (this.color = new Vt(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        this
      );
    }
  }
  un.prototype.isPointsMaterial = !0;
  const dn = new j(),
    pn = new Ge(),
    mn = new te(),
    fn = new G();
  class gn extends xt {
    constructor(t = new he(), e = new un()) {
      super(),
        (this.type = "Points"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    raycast(t, e) {
      const i = this.geometry,
        n = this.matrixWorld,
        r = t.params.Points.threshold,
        s = i.drawRange;
      if (
        (null === i.boundingSphere && i.computeBoundingSphere(),
        mn.copy(i.boundingSphere),
        mn.applyMatrix4(n),
        (mn.radius += r),
        !1 === t.ray.intersectsSphere(mn))
      )
        return;
      dn.copy(n).invert(), pn.copy(t.ray).applyMatrix4(dn);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a;
      if (i.isBufferGeometry) {
        const r = i.index,
          a = i.attributes.position;
        if (null !== r) {
          for (
            let i = Math.max(0, s.start),
              l = Math.min(r.count, s.start + s.count);
            i < l;
            i++
          ) {
            const s = r.getX(i);
            fn.fromBufferAttribute(a, s), yn(fn, s, o, n, t, e, this);
          }
        } else {
          for (
            let i = Math.max(0, s.start),
              r = Math.min(a.count, s.start + s.count);
            i < r;
            i++
          )
            fn.fromBufferAttribute(a, i), yn(fn, i, o, n, t, e, this);
        }
      } else
        console.error(
          "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes,
          i = Object.keys(e);
        if (i.length > 0) {
          const t = e[i[0]];
          if (void 0 !== t) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e].name || String(e);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[i] = e);
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e &&
          e.length > 0 &&
          console.error(
            "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    }
  }
  function yn(t, e, i, n, r, s, a) {
    const o = pn.distanceSqToPoint(t);
    if (o < i) {
      const i = new G();
      pn.closestPointToPoint(t, i), i.applyMatrix4(n);
      const l = r.ray.origin.distanceTo(i);
      if (l < r.near || l > r.far) return;
      s.push({
        distance: l,
        distanceToRay: Math.sqrt(o),
        point: i,
        index: e,
        face: null,
        object: a,
      });
    }
  }
  gn.prototype.isPoints = !0;
  const xn = new j(),
    vn = new G(),
    _n = new G();
  class bn extends be {
    constructor() {
      super(new hi(90, 1, 0.5, 500)),
        (this._frameExtents = new Ot(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new Nt(2, 1, 1, 1),
          new Nt(0, 1, 1, 1),
          new Nt(3, 1, 1, 1),
          new Nt(1, 1, 1, 1),
          new Nt(3, 0, 1, 1),
          new Nt(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new G(1, 0, 0),
          new G(-1, 0, 0),
          new G(0, 0, 1),
          new G(0, 0, -1),
          new G(0, 1, 0),
          new G(0, -1, 0),
        ]),
        (this._cubeUps = [
          new G(0, 1, 0),
          new G(0, 1, 0),
          new G(0, 1, 0),
          new G(0, 1, 0),
          new G(0, 0, 1),
          new G(0, 0, -1),
        ]);
    }
    updateMatrices(t, e = 0) {
      const i = this.camera,
        n = this.matrix,
        r = t.distance || i.far;
      r !== i.far && ((i.far = r), i.updateProjectionMatrix()),
        vn.setFromMatrixPosition(t.matrixWorld),
        i.position.copy(vn),
        _n.copy(i.position),
        _n.add(this._cubeDirections[e]),
        i.up.copy(this._cubeUps[e]),
        i.lookAt(_n),
        i.updateMatrixWorld(),
        n.makeTranslation(-vn.x, -vn.y, -vn.z),
        xn.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(xn);
    }
  }
  bn.prototype.isPointLightShadow = !0;
  class Mn extends ce {
    constructor(t, e, i = 0, n = 1) {
      super(t, e),
        (this.type = "PointLight"),
        (this.distance = i),
        (this.decay = n),
        (this.shadow = new bn());
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.distance = t.distance),
        (this.decay = t.decay),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  Mn.prototype.isPointLight = !0;
  class wn {
    constructor(t, e) {
      (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = E),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = c());
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, i) {
      (t *= this.stride), (i *= e.stride);
      for (let n = 0, r = this.stride; n < r; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = c()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const e = new this.array.constructor(
          t.arrayBuffers[this.array.buffer._uuid]
        ),
        i = new this.constructor(e, this.stride);
      return i.setUsage(this.usage), i;
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    toJSON(t) {
      return (
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = c()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  }
  wn.prototype.isInterleavedBuffer = !0;
  class Sn extends We {
    constructor(t) {
      super(),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new Vt(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new Vt(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ot(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "" }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        this
      );
    }
  }
  Sn.prototype.isMeshStandardMaterial = !0;
  class Tn extends Sn {
    constructor(t) {
      super(),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new Ot(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.ior = 1.5),
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return u((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
          },
          set: function (t) {
            this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
          },
        }),
        (this.sheenColor = new Vt(0)),
        (this.sheenColorMap = null),
        (this.sheenRoughness = 1),
        (this.sheenRoughnessMap = null),
        (this.transmissionMap = null),
        (this.thickness = 0),
        (this.thicknessMap = null),
        (this.attenuationDistance = 0),
        (this.attenuationColor = new Vt(1, 1, 1)),
        (this.specularIntensity = 1),
        (this.specularIntensityMap = null),
        (this.specularColor = new Vt(1, 1, 1)),
        (this.specularColorMap = null),
        (this._sheen = 0),
        (this._clearcoat = 0),
        (this._transmission = 0),
        this.setValues(t);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++,
        (this._transmission = t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.clearcoat = t.clearcoat),
        (this.clearcoatMap = t.clearcoatMap),
        (this.clearcoatRoughness = t.clearcoatRoughness),
        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = t.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        (this.ior = t.ior),
        (this.sheen = t.sheen),
        this.sheenColor.copy(t.sheenColor),
        (this.sheenColorMap = t.sheenColorMap),
        (this.sheenRoughness = t.sheenRoughness),
        (this.sheenRoughnessMap = t.sheenRoughnessMap),
        (this.transmission = t.transmission),
        (this.transmissionMap = t.transmissionMap),
        (this.thickness = t.thickness),
        (this.thicknessMap = t.thicknessMap),
        (this.attenuationDistance = t.attenuationDistance),
        this.attenuationColor.copy(t.attenuationColor),
        (this.specularIntensity = t.specularIntensity),
        (this.specularIntensityMap = t.specularIntensityMap),
        this.specularColor.copy(t.specularColor),
        (this.specularColorMap = t.specularColorMap),
        this
      );
    }
  }
  Tn.prototype.isMeshPhysicalMaterial = !0;
  class En extends Re {
    constructor(t) {
      super(t),
        (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (t) {
          return new Pn(t);
        }),
        this.register(function (t) {
          return new Bn(t);
        }),
        this.register(function (t) {
          return new Fn(t);
        }),
        this.register(function (t) {
          return new In(t);
        }),
        this.register(function (t) {
          return new zn(t);
        }),
        this.register(function (t) {
          return new Dn(t);
        }),
        this.register(function (t) {
          return new Nn(t);
        }),
        this.register(function (t) {
          return new On(t);
        }),
        this.register(function (t) {
          return new Ln(t);
        }),
        this.register(function (t) {
          return new Hn(t);
        });
    }
    load(t, e, i, n) {
      const r = this;
      let s;
      (s =
        "" !== this.resourcePath
          ? this.resourcePath
          : "" !== this.path
          ? this.path
          : ii.extractUrlBase(t)),
        this.manager.itemStart(t);
      const a = function (e) {
          n ? n(e) : console.error(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t);
        },
        o = new Ce(this.manager);
      o.setPath(this.path),
        o.setResponseType("arraybuffer"),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(
          t,
          function (i) {
            try {
              r.parse(
                i,
                s,
                function (i) {
                  e(i), r.manager.itemEnd(t);
                },
                a
              );
            } catch (t) {
              a(t);
            }
          },
          i,
          a
        );
    }
    setDRACOLoader(t) {
      return (this.dracoLoader = t), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(t) {
      return (this.ktx2Loader = t), this;
    }
    setMeshoptDecoder(t) {
      return (this.meshoptDecoder = t), this;
    }
    register(t) {
      return (
        -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
        this
      );
    }
    unregister(t) {
      return (
        -1 !== this.pluginCallbacks.indexOf(t) &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
        this
      );
    }
    parse(t, e, i, n) {
      let r;
      const s = {},
        a = {};
      if ("string" == typeof t) r = t;
      else {
        if (ii.decodeText(new Uint8Array(t, 0, 4)) === Un) {
          try {
            s[Rn.KHR_BINARY_GLTF] = new Vn(t);
          } catch (t) {
            return void (n && n(t));
          }
          r = s[Rn.KHR_BINARY_GLTF].content;
        } else r = ii.decodeText(new Uint8Array(t));
      }
      const o = JSON.parse(r);
      if (void 0 === o.asset || o.asset.version[0] < 2)
        return void (
          n &&
          n(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          )
        );
      const l = new br(o, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let t = 0; t < this.pluginCallbacks.length; t++) {
        const e = this.pluginCallbacks[t](l);
        (a[e.name] = e), (s[e.name] = !0);
      }
      if (o.extensionsUsed)
        for (let t = 0; t < o.extensionsUsed.length; ++t) {
          const e = o.extensionsUsed[t],
            i = o.extensionsRequired || [];
          switch (e) {
            case Rn.KHR_MATERIALS_UNLIT:
              s[e] = new Cn();
              break;
            case Rn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              s[e] = new Xn();
              break;
            case Rn.KHR_DRACO_MESH_COMPRESSION:
              s[e] = new Wn(o, this.dracoLoader);
              break;
            case Rn.KHR_TEXTURE_TRANSFORM:
              s[e] = new jn();
              break;
            case Rn.KHR_MESH_QUANTIZATION:
              s[e] = new Yn();
              break;
            default:
              i.indexOf(e) >= 0 &&
                void 0 === a[e] &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + e + '".'
                );
          }
        }
      l.setExtensions(s), l.setPlugins(a), l.parse(i, n);
    }
    parseAsync(t, e) {
      const i = this;
      return new Promise(function (n, r) {
        i.parse(t, e, n, r);
      });
    }
  }
  function An() {
    let t = {};
    return {
      get: function (e) {
        return t[e];
      },
      add: function (e, i) {
        t[e] = i;
      },
      remove: function (e) {
        delete t[e];
      },
      removeAll: function () {
        t = {};
      },
    };
  }
  const Rn = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
      "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  };
  class Ln {
    constructor(t) {
      (this.parser = t),
        (this.name = Rn.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    _markDefs() {
      const t = this.parser,
        e = this.parser.json.nodes || [];
      for (let i = 0, n = e.length; i < n; i++) {
        const n = e[i];
        n.extensions &&
          n.extensions[this.name] &&
          void 0 !== n.extensions[this.name].light &&
          t._addNodeRef(this.cache, n.extensions[this.name].light);
      }
    }
    _loadLight(t) {
      const e = this.parser,
        i = "light:" + t;
      let n = e.cache.get(i);
      if (n) return n;
      const r = e.json,
        s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[t];
      let a;
      const o = new Vt(16777215);
      void 0 !== s.color && o.fromArray(s.color);
      const l = void 0 !== s.range ? s.range : 0;
      switch (s.type) {
        case "directional":
          (a = new Te(o)), a.target.position.set(0, 0, -1), a.add(a.target);
          break;
        case "point":
          (a = new Mn(o)), (a.distance = l);
          break;
        case "spot":
          (a = new ui(o)),
            (a.distance = l),
            (s.spot = s.spot || {}),
            (s.spot.innerConeAngle =
              void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
            (s.spot.outerConeAngle =
              void 0 !== s.spot.outerConeAngle
                ? s.spot.outerConeAngle
                : Math.PI / 4),
            (a.angle = s.spot.outerConeAngle),
            (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
            a.target.position.set(0, 0, -1),
            a.add(a.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
      }
      return (
        a.position.set(0, 0, 0),
        (a.decay = 2),
        void 0 !== s.intensity && (a.intensity = s.intensity),
        (a.name = e.createUniqueName(s.name || "light_" + t)),
        (n = Promise.resolve(a)),
        e.cache.add(i, n),
        n
      );
    }
    createNodeAttachment(t) {
      const e = this,
        i = this.parser,
        n = i.json.nodes[t],
        r = ((n.extensions && n.extensions[this.name]) || {}).light;
      return void 0 === r
        ? null
        : this._loadLight(r).then(function (t) {
            return i._getNodeRef(e.cache, r, t);
          });
    }
  }
  class Cn {
    constructor() {
      this.name = Rn.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return wi;
    }
    extendParams(t, e, i) {
      const n = [];
      (t.color = new Vt(1, 1, 1)), (t.opacity = 1);
      const r = e.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const e = r.baseColorFactor;
          t.color.fromArray(e), (t.opacity = e[3]);
        }
        void 0 !== r.baseColorTexture &&
          n.push(i.assignTexture(t, "map", r.baseColorTexture));
      }
      return Promise.all(n);
    }
  }
  class Pn {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_CLEARCOAT);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser,
        n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = n.extensions[this.name];
      if (
        (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
        void 0 !== s.clearcoatTexture &&
          r.push(i.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
        void 0 !== s.clearcoatRoughnessFactor &&
          (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
        void 0 !== s.clearcoatRoughnessTexture &&
          r.push(
            i.assignTexture(
              e,
              "clearcoatRoughnessMap",
              s.clearcoatRoughnessTexture
            )
          ),
        void 0 !== s.clearcoatNormalTexture &&
          (r.push(
            i.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)
          ),
          void 0 !== s.clearcoatNormalTexture.scale))
      ) {
        const t = s.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new Ot(t, t);
      }
      return Promise.all(r);
    }
  }
  class In {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_SHEEN);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser,
        n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [];
      (e.sheenColor = new Vt(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1);
      const s = n.extensions[this.name];
      return (
        void 0 !== s.sheenColorFactor &&
          e.sheenColor.fromArray(s.sheenColorFactor),
        void 0 !== s.sheenRoughnessFactor &&
          (e.sheenRoughness = s.sheenRoughnessFactor),
        void 0 !== s.sheenColorTexture &&
          r.push(i.assignTexture(e, "sheenColorMap", s.sheenColorTexture)),
        void 0 !== s.sheenRoughnessTexture &&
          r.push(
            i.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)
          ),
        Promise.all(r)
      );
    }
  }
  class zn {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_TRANSMISSION);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser,
        n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = n.extensions[this.name];
      return (
        void 0 !== s.transmissionFactor &&
          (e.transmission = s.transmissionFactor),
        void 0 !== s.transmissionTexture &&
          r.push(i.assignTexture(e, "transmissionMap", s.transmissionTexture)),
        Promise.all(r)
      );
    }
  }
  class Dn {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_VOLUME);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser,
        n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = n.extensions[this.name];
      (e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
        void 0 !== s.thicknessTexture &&
          r.push(i.assignTexture(e, "thicknessMap", s.thicknessTexture)),
        (e.attenuationDistance = s.attenuationDistance || 0);
      const a = s.attenuationColor || [1, 1, 1];
      return (e.attenuationColor = new Vt(a[0], a[1], a[2])), Promise.all(r);
    }
  }
  class Nn {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_IOR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const n = i.extensions[this.name];
      return (e.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
    }
  }
  class On {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_MATERIALS_SPECULAR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Tn : null;
    }
    extendMaterialParams(t, e) {
      const i = this.parser,
        n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = n.extensions[this.name];
      (e.specularIntensity =
        void 0 !== s.specularFactor ? s.specularFactor : 1),
        void 0 !== s.specularTexture &&
          r.push(i.assignTexture(e, "specularIntensityMap", s.specularTexture));
      const a = s.specularColorFactor || [1, 1, 1];
      return (
        (e.specularColor = new Vt(a[0], a[1], a[2])),
        void 0 !== s.specularColorTexture &&
          r.push(
            i
              .assignTexture(e, "specularColorMap", s.specularColorTexture)
              .then(function (t) {
                t.encoding = S;
              })
          ),
        Promise.all(r)
      );
    }
  }
  class Bn {
    constructor(t) {
      (this.parser = t), (this.name = Rn.KHR_TEXTURE_BASISU);
    }
    loadTexture(t) {
      const e = this.parser,
        i = e.json,
        n = i.textures[t];
      if (!n.extensions || !n.extensions[this.name]) return null;
      const r = n.extensions[this.name],
        s = i.images[r.source],
        a = e.options.ktx2Loader;
      if (!a) {
        if (
          i.extensionsRequired &&
          i.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
          );
        return null;
      }
      return e.loadTextureImage(t, s, a);
    }
  }
  class Fn {
    constructor(t) {
      (this.parser = t),
        (this.name = Rn.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    loadTexture(t) {
      const e = this.name,
        i = this.parser,
        n = i.json,
        r = n.textures[t];
      if (!r.extensions || !r.extensions[e]) return null;
      const s = r.extensions[e],
        a = n.images[s.source];
      let o = i.textureLoader;
      if (a.uri) {
        const t = i.options.manager.getHandler(a.uri);
        null !== t && (o = t);
      }
      return this.detectSupport().then(function (r) {
        if (r) return i.loadTextureImage(t, a, o);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported."
          );
        return i.loadTexture(t);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (t) {
            const e = new Image();
            (e.src =
              "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
              (e.onload = e.onerror =
                function () {
                  t(1 === e.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class Hn {
    constructor(t) {
      (this.name = Rn.EXT_MESHOPT_COMPRESSION), (this.parser = t);
    }
    loadBufferView(t) {
      const e = this.parser.json,
        i = e.bufferViews[t];
      if (i.extensions && i.extensions[this.name]) {
        const t = i.extensions[this.name],
          n = this.parser.getDependency("buffer", t.buffer),
          r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (
            e.extensionsRequired &&
            e.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
            );
          return null;
        }
        return Promise.all([n, r.ready]).then(function (e) {
          const i = t.byteOffset || 0,
            n = t.byteLength || 0,
            s = t.count,
            a = t.byteStride,
            o = new ArrayBuffer(s * a),
            l = new Uint8Array(e[0], i, n);
          return (
            r.decodeGltfBuffer(new Uint8Array(o), s, a, l, t.mode, t.filter), o
          );
        });
      }
      return null;
    }
  }
  const Un = "glTF",
    kn = 1313821514,
    Gn = 5130562;
  class Vn {
    constructor(t) {
      (this.name = Rn.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      const e = new DataView(t, 0, 12);
      if (
        ((this.header = {
          magic: ii.decodeText(new Uint8Array(t.slice(0, 4))),
          version: e.getUint32(4, !0),
          length: e.getUint32(8, !0),
        }),
        this.header.magic !== Un)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - 12,
        n = new DataView(t, 12);
      let r = 0;
      for (; r < i; ) {
        const e = n.getUint32(r, !0);
        r += 4;
        const i = n.getUint32(r, !0);
        if (((r += 4), i === kn)) {
          const i = new Uint8Array(t, 12 + r, e);
          this.content = ii.decodeText(i);
        } else if (i === Gn) {
          const i = 12 + r;
          this.body = t.slice(i, i + e);
        }
        r += e;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class Wn {
    constructor(t, e) {
      if (!e)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = Rn.KHR_DRACO_MESH_COMPRESSION),
        (this.json = t),
        (this.dracoLoader = e),
        this.dracoLoader.preload();
    }
    decodePrimitive(t, e) {
      const i = this.json,
        n = this.dracoLoader,
        r = t.extensions[this.name].bufferView,
        s = t.extensions[this.name].attributes,
        a = {},
        o = {},
        l = {};
      for (const t in s) {
        const e = hr[t] || t.toLowerCase();
        a[e] = s[t];
      }
      for (const e in t.attributes) {
        const n = hr[e] || e.toLowerCase();
        if (void 0 !== s[e]) {
          const r = i.accessors[t.attributes[e]],
            s = sr[r.componentType];
          (l[n] = s), (o[n] = !0 === r.normalized);
        }
      }
      return e.getDependency("bufferView", r).then(function (t) {
        return new Promise(function (e) {
          n.decodeDracoFile(
            t,
            function (t) {
              for (const e in t.attributes) {
                const i = t.attributes[e],
                  n = o[e];
                void 0 !== n && (i.normalized = n);
              }
              e(t);
            },
            a,
            l
          );
        });
      });
    }
  }
  class jn {
    constructor() {
      this.name = Rn.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t, e) {
      return (
        void 0 !== e.texCoord &&
          console.warn(
            'THREE.GLTFLoader: Custom UV sets in "' +
              this.name +
              '" extension not yet supported.'
          ),
        (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) ||
          ((t = t.clone()),
          void 0 !== e.offset && t.offset.fromArray(e.offset),
          void 0 !== e.rotation && (t.rotation = e.rotation),
          void 0 !== e.scale && t.repeat.fromArray(e.scale),
          (t.needsUpdate = !0)),
        t
      );
    }
  }
  class qn extends Sn {
    constructor(t) {
      super(), (this.isGLTFSpecularGlossinessMaterial = !0);
      const e = [
          "#ifdef USE_SPECULARMAP",
          "\tuniform sampler2D specularMap;",
          "#endif",
        ].join("\n"),
        i = [
          "#ifdef USE_GLOSSINESSMAP",
          "\tuniform sampler2D glossinessMap;",
          "#endif",
        ].join("\n"),
        n = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
          "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tspecularFactor *= texelSpecular.rgb;",
          "#endif",
        ].join("\n"),
        r = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tglossinessFactor *= texelGlossiness.a;",
          "#endif",
        ].join("\n"),
        s = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.roughness += geometryRoughness;",
          "material.roughness = min( material.roughness, 1.0 );",
          "material.specularColor = specularFactor;",
        ].join("\n"),
        a = {
          specular: { value: new Vt().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null },
        };
      (this._extraUniforms = a),
        (this.onBeforeCompile = function (t) {
          for (const e in a) t.uniforms[e] = a[e];
          t.fragmentShader = t.fragmentShader
            .replace("uniform float roughness;", "uniform vec3 specular;")
            .replace("uniform float metalness;", "uniform float glossiness;")
            .replace("#include <roughnessmap_pars_fragment>", e)
            .replace("#include <metalnessmap_pars_fragment>", i)
            .replace("#include <roughnessmap_fragment>", n)
            .replace("#include <metalnessmap_fragment>", r)
            .replace("#include <lights_physical_fragment>", s);
        }),
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return a.specular.value;
            },
            set: function (t) {
              a.specular.value = t;
            },
          },
          specularMap: {
            get: function () {
              return a.specularMap.value;
            },
            set: function (t) {
              (a.specularMap.value = t),
                t
                  ? (this.defines.USE_SPECULARMAP = "")
                  : delete this.defines.USE_SPECULARMAP;
            },
          },
          glossiness: {
            get: function () {
              return a.glossiness.value;
            },
            set: function (t) {
              a.glossiness.value = t;
            },
          },
          glossinessMap: {
            get: function () {
              return a.glossinessMap.value;
            },
            set: function (t) {
              (a.glossinessMap.value = t),
                t
                  ? ((this.defines.USE_GLOSSINESSMAP = ""),
                    (this.defines.USE_UV = ""))
                  : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV);
            },
          },
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.specularMap = t.specularMap),
        this.specular.copy(t.specular),
        (this.glossinessMap = t.glossinessMap),
        (this.glossiness = t.glossiness),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
      );
    }
  }
  class Xn {
    constructor() {
      (this.name = Rn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
        (this.specularGlossinessParams = [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
          "refractionRatio",
        ]);
    }
    getMaterialType() {
      return qn;
    }
    extendParams(t, e, i) {
      const n = e.extensions[this.name];
      (t.color = new Vt(1, 1, 1)), (t.opacity = 1);
      const r = [];
      if (Array.isArray(n.diffuseFactor)) {
        const e = n.diffuseFactor;
        t.color.fromArray(e), (t.opacity = e[3]);
      }
      if (
        (void 0 !== n.diffuseTexture &&
          r.push(i.assignTexture(t, "map", n.diffuseTexture)),
        (t.emissive = new Vt(0, 0, 0)),
        (t.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1),
        (t.specular = new Vt(1, 1, 1)),
        Array.isArray(n.specularFactor) &&
          t.specular.fromArray(n.specularFactor),
        void 0 !== n.specularGlossinessTexture)
      ) {
        const e = n.specularGlossinessTexture;
        r.push(i.assignTexture(t, "glossinessMap", e)),
          r.push(i.assignTexture(t, "specularMap", e));
      }
      return Promise.all(r);
    }
    createMaterial(t) {
      const e = new qn(t);
      return (
        (e.fog = !0),
        (e.color = t.color),
        (e.map = void 0 === t.map ? null : t.map),
        (e.lightMap = null),
        (e.lightMapIntensity = 1),
        (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
        (e.aoMapIntensity = 1),
        (e.emissive = t.emissive),
        (e.emissiveIntensity = 1),
        (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
        (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
        (e.bumpScale = 1),
        (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
        (e.normalMapType = 0),
        t.normalScale && (e.normalScale = t.normalScale),
        (e.displacementMap = null),
        (e.displacementScale = 1),
        (e.displacementBias = 0),
        (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
        (e.specular = t.specular),
        (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
        (e.glossiness = t.glossiness),
        (e.alphaMap = null),
        (e.envMap = void 0 === t.envMap ? null : t.envMap),
        (e.envMapIntensity = 1),
        (e.refractionRatio = 0.98),
        e
      );
    }
  }
  class Yn {
    constructor() {
      this.name = Rn.KHR_MESH_QUANTIZATION;
    }
  }
  class Jn extends R {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        i = this.sampleValues,
        n = this.valueSize,
        r = t * n * 3 + n;
      for (let t = 0; t !== n; t++) e[t] = i[r + t];
      return e;
    }
  }
  (Jn.prototype.beforeStart_ = Jn.prototype.copySampleValue_),
    (Jn.prototype.afterEnd_ = Jn.prototype.copySampleValue_),
    (Jn.prototype.interpolate_ = function (t, e, i, n) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = 2 * a,
        l = 3 * a,
        h = n - e,
        c = (i - e) / h,
        u = c * c,
        d = u * c,
        p = t * l,
        m = p - l,
        f = -2 * d + 3 * u,
        g = d - u,
        y = 1 - f,
        x = g - u + c;
      for (let t = 0; t !== a; t++) {
        const e = s[m + t + a],
          i = s[m + t + o] * h,
          n = s[p + t + a],
          l = s[p + t] * h;
        r[t] = y * e + x * i + f * n + g * l;
      }
      return r;
    });
  const Zn = new m();
  class Kn extends Jn {
    interpolate_(t, e, i, n) {
      const r = super.interpolate_(t, e, i, n);
      return Zn.fromArray(r).normalize().toArray(r), r;
    }
  }
  const Qn = 0,
    $n = 1,
    tr = 2,
    er = 3,
    ir = 4,
    nr = 5,
    rr = 6,
    sr = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    ar = { 9728: x, 9729: v, 9984: 1004, 9985: 1007, 9986: 1005, 9987: _ },
    or = { 33071: g, 33648: y, 10497: f },
    lr = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    hr = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    cr = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    ur = { CUBICSPLINE: void 0, LINEAR: M, STEP: b },
    dr = "OPAQUE",
    pr = "MASK",
    mr = "BLEND";
  function fr(t, e, i) {
    for (const n in i.extensions)
      void 0 === t[n] &&
        ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
        (e.userData.gltfExtensions[n] = i.extensions[n]));
  }
  function gr(t, e) {
    void 0 !== e.extras &&
      ("object" == typeof e.extras
        ? Object.assign(t.userData, e.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
          ));
  }
  function yr(t, e) {
    if ((t.updateMorphTargets(), void 0 !== e.weights))
      for (let i = 0, n = e.weights.length; i < n; i++)
        t.morphTargetInfluences[i] = e.weights[i];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const i = e.extras.targetNames;
      if (t.morphTargetInfluences.length === i.length) {
        t.morphTargetDictionary = {};
        for (let e = 0, n = i.length; e < n; e++)
          t.morphTargetDictionary[i[e]] = e;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function xr(t) {
    const e = t.extensions && t.extensions[Rn.KHR_DRACO_MESH_COMPRESSION];
    let i;
    return (
      (i = e
        ? "draco:" + e.bufferView + ":" + e.indices + ":" + vr(e.attributes)
        : t.indices + ":" + vr(t.attributes) + ":" + t.mode),
      i
    );
  }
  function vr(t) {
    let e = "";
    const i = Object.keys(t).sort();
    for (let n = 0, r = i.length; n < r; n++) e += i[n] + ":" + t[i[n]] + ";";
    return e;
  }
  function _r(t) {
    switch (t) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  class br {
    constructor(t = {}, e = {}) {
      (this.json = t),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = e),
        (this.cache = new An()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.textureCache = {}),
        (this.nodeNamesUsed = {}),
        "undefined" != typeof createImageBitmap &&
        !1 ===
          /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          ? (this.textureLoader = new Ie(this.options.manager))
          : (this.textureLoader = new li(this.options.manager)),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        (this.fileLoader = new Ce(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(t) {
      this.extensions = t;
    }
    setPlugins(t) {
      this.plugins = t;
    }
    parse(t, e) {
      const i = this,
        n = this.json,
        r = this.extensions;
      this.cache.removeAll(),
        this._invokeAll(function (t) {
          return t._markDefs && t._markDefs();
        }),
        Promise.all(
          this._invokeAll(function (t) {
            return t.beforeRoot && t.beforeRoot();
          })
        )
          .then(function () {
            return Promise.all([
              i.getDependencies("scene"),
              i.getDependencies("animation"),
              i.getDependencies("camera"),
            ]);
          })
          .then(function (e) {
            const s = {
              scene: e[0][n.scene || 0],
              scenes: e[0],
              animations: e[1],
              cameras: e[2],
              asset: n.asset,
              parser: i,
              userData: {},
            };
            fr(r, s, n),
              gr(s, n),
              Promise.all(
                i._invokeAll(function (t) {
                  return t.afterRoot && t.afterRoot(s);
                })
              ).then(function () {
                t(s);
              });
          })
          .catch(e);
    }
    _markDefs() {
      const t = this.json.nodes || [],
        e = this.json.skins || [],
        i = this.json.meshes || [];
      for (let i = 0, n = e.length; i < n; i++) {
        const n = e[i].joints;
        for (let e = 0, i = n.length; e < i; e++) t[n[e]].isBone = !0;
      }
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e];
        void 0 !== n.mesh &&
          (this._addNodeRef(this.meshCache, n.mesh),
          void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)),
          void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
      }
    }
    _addNodeRef(t, e) {
      void 0 !== e &&
        (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
    }
    _getNodeRef(t, e, i) {
      if (t.refs[e] <= 1) return i;
      const n = i.clone(),
        r = (t, e) => {
          const i = this.associations.get(t);
          null != i && this.associations.set(e, i);
          for (const [i, n] of t.children.entries()) r(n, e.children[i]);
        };
      return r(i, n), (n.name += "_instance_" + t.uses[e]++), n;
    }
    _invokeOne(t) {
      const e = Object.values(this.plugins);
      e.push(this);
      for (let i = 0; i < e.length; i++) {
        const n = t(e[i]);
        if (n) return n;
      }
      return null;
    }
    _invokeAll(t) {
      const e = Object.values(this.plugins);
      e.unshift(this);
      const i = [];
      for (let n = 0; n < e.length; n++) {
        const r = t(e[n]);
        r && i.push(r);
      }
      return i;
    }
    getDependency(t, e) {
      const i = t + ":" + e;
      let n = this.cache.get(i);
      if (!n) {
        switch (t) {
          case "scene":
            n = this.loadScene(e);
            break;
          case "node":
            n = this.loadNode(e);
            break;
          case "mesh":
            n = this._invokeOne(function (t) {
              return t.loadMesh && t.loadMesh(e);
            });
            break;
          case "accessor":
            n = this.loadAccessor(e);
            break;
          case "bufferView":
            n = this._invokeOne(function (t) {
              return t.loadBufferView && t.loadBufferView(e);
            });
            break;
          case "buffer":
            n = this.loadBuffer(e);
            break;
          case "material":
            n = this._invokeOne(function (t) {
              return t.loadMaterial && t.loadMaterial(e);
            });
            break;
          case "texture":
            n = this._invokeOne(function (t) {
              return t.loadTexture && t.loadTexture(e);
            });
            break;
          case "skin":
            n = this.loadSkin(e);
            break;
          case "animation":
            n = this.loadAnimation(e);
            break;
          case "camera":
            n = this.loadCamera(e);
            break;
          default:
            throw new Error("Unknown type: " + t);
        }
        this.cache.add(i, n);
      }
      return n;
    }
    getDependencies(t) {
      let e = this.cache.get(t);
      if (!e) {
        const i = this,
          n = this.json[t + ("mesh" === t ? "es" : "s")] || [];
        (e = Promise.all(
          n.map(function (e, n) {
            return i.getDependency(t, n);
          })
        )),
          this.cache.add(t, e);
      }
      return e;
    }
    loadBuffer(t) {
      const e = this.json.buffers[t],
        i = this.fileLoader;
      if (e.type && "arraybuffer" !== e.type)
        throw new Error(
          "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
        );
      if (void 0 === e.uri && 0 === t)
        return Promise.resolve(this.extensions[Rn.KHR_BINARY_GLTF].body);
      const n = this.options;
      return new Promise(function (t, r) {
        i.load(ii.resolveURL(e.uri, n.path), t, void 0, function () {
          r(
            new Error(
              'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
            )
          );
        });
      });
    }
    loadBufferView(t) {
      const e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then(function (t) {
        const i = e.byteLength || 0,
          n = e.byteOffset || 0;
        return t.slice(n, n + i);
      });
    }
    loadAccessor(t) {
      const e = this,
        i = this.json,
        n = this.json.accessors[t];
      if (void 0 === n.bufferView && void 0 === n.sparse)
        return Promise.resolve(null);
      const r = [];
      return (
        void 0 !== n.bufferView
          ? r.push(this.getDependency("bufferView", n.bufferView))
          : r.push(null),
        void 0 !== n.sparse &&
          (r.push(
            this.getDependency("bufferView", n.sparse.indices.bufferView)
          ),
          r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
        Promise.all(r).then(function (t) {
          const r = t[0],
            s = lr[n.type],
            a = sr[n.componentType],
            o = a.BYTES_PER_ELEMENT,
            l = o * s,
            h = n.byteOffset || 0,
            c =
              void 0 !== n.bufferView
                ? i.bufferViews[n.bufferView].byteStride
                : void 0,
            u = !0 === n.normalized;
          let d, p;
          if (c && c !== l) {
            const t = Math.floor(h / c),
              i =
                "InterleavedBuffer:" +
                n.bufferView +
                ":" +
                n.componentType +
                ":" +
                t +
                ":" +
                n.count;
            let l = e.cache.get(i);
            l ||
              ((d = new a(r, t * c, (n.count * c) / o)),
              (l = new wn(d, c / o)),
              e.cache.add(i, l)),
              (p = new De(l, s, (h % c) / o, u));
          } else (d = null === r ? new a(n.count * s) : new a(r, h, n.count * s)), (p = new qt(d, s, u));
          if (void 0 !== n.sparse) {
            const e = lr.SCALAR,
              i = sr[n.sparse.indices.componentType],
              o = n.sparse.indices.byteOffset || 0,
              l = n.sparse.values.byteOffset || 0,
              h = new i(t[1], o, n.sparse.count * e),
              c = new a(t[2], l, n.sparse.count * s);
            null !== r &&
              (p = new qt(p.array.slice(), p.itemSize, p.normalized));
            for (let t = 0, e = h.length; t < e; t++) {
              const e = h[t];
              if (
                (p.setX(e, c[t * s]),
                s >= 2 && p.setY(e, c[t * s + 1]),
                s >= 3 && p.setZ(e, c[t * s + 2]),
                s >= 4 && p.setW(e, c[t * s + 3]),
                s >= 5)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                );
            }
          }
          return p;
        })
      );
    }
    loadTexture(t) {
      const e = this.json,
        i = this.options,
        n = e.textures[t],
        r = e.images[n.source];
      let s = this.textureLoader;
      if (r.uri) {
        const t = i.manager.getHandler(r.uri);
        null !== t && (s = t);
      }
      return this.loadTextureImage(t, r, s);
    }
    loadTextureImage(t, e, i) {
      const n = this,
        r = this.json,
        s = this.options,
        a = r.textures[t],
        o = (e.uri || e.bufferView) + ":" + a.sampler;
      if (this.textureCache[o]) return this.textureCache[o];
      const l = self.URL || self.webkitURL;
      let h = e.uri || "",
        c = !1;
      if (void 0 !== e.bufferView)
        h = n.getDependency("bufferView", e.bufferView).then(function (t) {
          c = !0;
          const i = new Blob([t], { type: e.mimeType });
          return (h = l.createObjectURL(i)), h;
        });
      else if (void 0 === e.uri)
        throw new Error(
          "THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"
        );
      const u = Promise.resolve(h)
        .then(function (t) {
          return new Promise(function (e, n) {
            let r = e;
            !0 === i.isImageBitmapLoader &&
              (r = function (t) {
                const i = new si(t);
                (i.needsUpdate = !0), e(i);
              }),
              i.load(ii.resolveURL(t, s.path), r, void 0, n);
          });
        })
        .then(function (e) {
          !0 === c && l.revokeObjectURL(h),
            (e.flipY = !1),
            a.name && (e.name = a.name);
          const i = (r.samplers || {})[a.sampler] || {};
          return (
            (e.magFilter = ar[i.magFilter] || v),
            (e.minFilter = ar[i.minFilter] || _),
            (e.wrapS = or[i.wrapS] || f),
            (e.wrapT = or[i.wrapT] || f),
            n.associations.set(e, { textures: t }),
            e
          );
        })
        .catch(function () {
          return (
            console.error("THREE.GLTFLoader: Couldn't load texture", h), null
          );
        });
      return (this.textureCache[o] = u), u;
    }
    assignTexture(t, e, i) {
      const n = this;
      return this.getDependency("texture", i.index).then(function (r) {
        if (
          (void 0 === i.texCoord ||
            0 == i.texCoord ||
            ("aoMap" === e && 1 == i.texCoord) ||
            console.warn(
              "THREE.GLTFLoader: Custom UV set " +
                i.texCoord +
                " for texture " +
                e +
                " not yet supported."
            ),
          n.extensions[Rn.KHR_TEXTURE_TRANSFORM])
        ) {
          const t =
            void 0 !== i.extensions
              ? i.extensions[Rn.KHR_TEXTURE_TRANSFORM]
              : void 0;
          if (t) {
            const e = n.associations.get(r);
            (r = n.extensions[Rn.KHR_TEXTURE_TRANSFORM].extendTexture(r, t)),
              n.associations.set(r, e);
          }
        }
        return (t[e] = r), r;
      });
    }
    assignFinalMaterial(t) {
      const e = t.geometry;
      let i = t.material;
      const n = void 0 === e.attributes.tangent,
        r = void 0 !== e.attributes.color,
        s = void 0 === e.attributes.normal;
      if (t.isPoints) {
        const t = "PointsMaterial:" + i.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new un()),
          We.prototype.copy.call(e, i),
          e.color.copy(i.color),
          (e.map = i.map),
          (e.sizeAttenuation = !1),
          this.cache.add(t, e)),
          (i = e);
      } else if (t.isLine) {
        const t = "LineBasicMaterial:" + i.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new je()),
          We.prototype.copy.call(e, i),
          e.color.copy(i.color),
          this.cache.add(t, e)),
          (i = e);
      }
      if (n || r || s) {
        let t = "ClonedMaterial:" + i.uuid + ":";
        i.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
          n && (t += "derivative-tangents:"),
          r && (t += "vertex-colors:"),
          s && (t += "flat-shading:");
        let e = this.cache.get(t);
        e ||
          ((e = i.clone()),
          r && (e.vertexColors = !0),
          s && (e.flatShading = !0),
          n &&
            (e.normalScale && (e.normalScale.y *= -1),
            e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
          this.cache.add(t, e),
          this.associations.set(e, this.associations.get(i))),
          (i = e);
      }
      i.aoMap &&
        void 0 === e.attributes.uv2 &&
        void 0 !== e.attributes.uv &&
        e.setAttribute("uv2", e.attributes.uv),
        (t.material = i);
    }
    getMaterialType() {
      return Sn;
    }
    loadMaterial(t) {
      const e = this,
        i = this.json,
        n = this.extensions,
        r = i.materials[t];
      let s;
      const a = {},
        o = r.extensions || {},
        l = [];
      if (o[Rn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const t = n[Rn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        (s = t.getMaterialType()), l.push(t.extendParams(a, r, e));
      } else if (o[Rn.KHR_MATERIALS_UNLIT]) {
        const t = n[Rn.KHR_MATERIALS_UNLIT];
        (s = t.getMaterialType()), l.push(t.extendParams(a, r, e));
      } else {
        const i = r.pbrMetallicRoughness || {};
        if (
          ((a.color = new Vt(1, 1, 1)),
          (a.opacity = 1),
          Array.isArray(i.baseColorFactor))
        ) {
          const t = i.baseColorFactor;
          a.color.fromArray(t), (a.opacity = t[3]);
        }
        void 0 !== i.baseColorTexture &&
          l.push(e.assignTexture(a, "map", i.baseColorTexture)),
          (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
          (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
          void 0 !== i.metallicRoughnessTexture &&
            (l.push(
              e.assignTexture(a, "metalnessMap", i.metallicRoughnessTexture)
            ),
            l.push(
              e.assignTexture(a, "roughnessMap", i.metallicRoughnessTexture)
            )),
          (s = this._invokeOne(function (e) {
            return e.getMaterialType && e.getMaterialType(t);
          })),
          l.push(
            Promise.all(
              this._invokeAll(function (e) {
                return e.extendMaterialParams && e.extendMaterialParams(t, a);
              })
            )
          );
      }
      !0 === r.doubleSided && (a.side = 2);
      const h = r.alphaMode || dr;
      if (
        (h === mr
          ? ((a.transparent = !0), (a.depthWrite = !1))
          : ((a.transparent = !1),
            h === pr &&
              (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
        void 0 !== r.normalTexture &&
          s !== wi &&
          (l.push(e.assignTexture(a, "normalMap", r.normalTexture)),
          (a.normalScale = new Ot(1, 1)),
          void 0 !== r.normalTexture.scale))
      ) {
        const t = r.normalTexture.scale;
        a.normalScale.set(t, t);
      }
      return (
        void 0 !== r.occlusionTexture &&
          s !== wi &&
          (l.push(e.assignTexture(a, "aoMap", r.occlusionTexture)),
          void 0 !== r.occlusionTexture.strength &&
            (a.aoMapIntensity = r.occlusionTexture.strength)),
        void 0 !== r.emissiveFactor &&
          s !== wi &&
          (a.emissive = new Vt().fromArray(r.emissiveFactor)),
        void 0 !== r.emissiveTexture &&
          s !== wi &&
          l.push(e.assignTexture(a, "emissiveMap", r.emissiveTexture)),
        Promise.all(l).then(function () {
          let i;
          return (
            (i =
              s === qn
                ? n[Rn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a)
                : new s(a)),
            r.name && (i.name = r.name),
            i.map && (i.map.encoding = S),
            i.emissiveMap && (i.emissiveMap.encoding = S),
            gr(i, r),
            e.associations.set(i, { materials: t }),
            r.extensions && fr(n, i, r),
            i
          );
        })
      );
    }
    createUniqueName(t) {
      const e = cn.sanitizeNodeName(t || "");
      let i = e;
      for (let t = 1; this.nodeNamesUsed[i]; ++t) i = e + "_" + t;
      return (this.nodeNamesUsed[i] = !0), i;
    }
    loadGeometries(t) {
      const e = this,
        i = this.extensions,
        n = this.primitiveCache;
      function r(t) {
        return i[Rn.KHR_DRACO_MESH_COMPRESSION]
          .decodePrimitive(t, e)
          .then(function (i) {
            return wr(i, t, e);
          });
      }
      const s = [];
      for (let i = 0, a = t.length; i < a; i++) {
        const a = t[i],
          o = xr(a),
          l = n[o];
        if (l) s.push(l.promise);
        else {
          let t;
          (t =
            a.extensions && a.extensions[Rn.KHR_DRACO_MESH_COMPRESSION]
              ? r(a)
              : wr(new he(), a, e)),
            (n[o] = { primitive: a, promise: t }),
            s.push(t);
        }
      }
      return Promise.all(s);
    }
    loadMesh(t) {
      const e = this,
        i = this.json,
        n = this.extensions,
        r = i.meshes[t],
        s = r.primitives,
        a = [];
      for (let t = 0, e = s.length; t < e; t++) {
        const e =
          void 0 === s[t].material
            ? (void 0 === (o = this.cache).DefaultMaterial &&
                (o.DefaultMaterial = new Sn({
                  color: 16777215,
                  emissive: 0,
                  metalness: 1,
                  roughness: 1,
                  transparent: !1,
                  depthTest: !0,
                  side: 0,
                })),
              o.DefaultMaterial)
            : this.getDependency("material", s[t].material);
        a.push(e);
      }
      var o;
      return (
        a.push(e.loadGeometries(s)),
        Promise.all(a).then(function (i) {
          const a = i.slice(0, i.length - 1),
            o = i[i.length - 1],
            l = [];
          for (let i = 0, h = o.length; i < h; i++) {
            const h = o[i],
              c = s[i];
            let u;
            const d = a[i];
            if (
              c.mode === ir ||
              c.mode === nr ||
              c.mode === rr ||
              void 0 === c.mode
            )
              (u = !0 === r.isSkinnedMesh ? new Yi(h, d) : new ki(h, d)),
                !0 !== u.isSkinnedMesh ||
                  u.geometry.attributes.skinWeight.normalized ||
                  u.normalizeSkinWeights(),
                c.mode === nr
                  ? (u.geometry = Sr(u.geometry, 1))
                  : c.mode === rr && (u.geometry = Sr(u.geometry, 2));
            else if (c.mode === $n) u = new ei(h, d);
            else if (c.mode === er) u = new Ke(h, d);
            else if (c.mode === tr) u = new Qe(h, d);
            else {
              if (c.mode !== Qn)
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + c.mode
                );
              u = new gn(h, d);
            }
            Object.keys(u.geometry.morphAttributes).length > 0 && yr(u, r),
              (u.name = e.createUniqueName(r.name || "mesh_" + t)),
              gr(u, r),
              c.extensions && fr(n, u, c),
              e.assignFinalMaterial(u),
              l.push(u);
          }
          for (let i = 0, n = l.length; i < n; i++)
            e.associations.set(l[i], { meshes: t, primitives: i });
          if (1 === l.length) return l[0];
          const h = new Pe();
          e.associations.set(h, { meshes: t });
          for (let t = 0, e = l.length; t < e; t++) h.add(l[t]);
          return h;
        })
      );
    }
    loadCamera(t) {
      let e;
      const i = this.json.cameras[t],
        n = i[i.type];
      if (n)
        return (
          "perspective" === i.type
            ? (e = new hi(
                n.yfov * h,
                n.aspectRatio || 1,
                n.znear || 1,
                n.zfar || 2e6
              ))
            : "orthographic" === i.type &&
              (e = new we(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
          i.name && (e.name = this.createUniqueName(i.name)),
          gr(e, i),
          Promise.resolve(e)
        );
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(t) {
      const e = this.json.skins[t],
        i = { joints: e.joints };
      return void 0 === e.inverseBindMatrices
        ? Promise.resolve(i)
        : this.getDependency("accessor", e.inverseBindMatrices).then(function (
            t
          ) {
            return (i.inverseBindMatrices = t), i;
          });
    }
    loadAnimation(t) {
      const e = this.json.animations[t],
        i = [],
        n = [],
        r = [],
        s = [],
        a = [];
      for (let t = 0, o = e.channels.length; t < o; t++) {
        const o = e.channels[t],
          l = e.samplers[o.sampler],
          h = o.target,
          c = void 0 !== h.node ? h.node : h.id,
          u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
          d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
        i.push(this.getDependency("node", c)),
          n.push(this.getDependency("accessor", u)),
          r.push(this.getDependency("accessor", d)),
          s.push(l),
          a.push(h);
      }
      return Promise.all([
        Promise.all(i),
        Promise.all(n),
        Promise.all(r),
        Promise.all(s),
        Promise.all(a),
      ]).then(function (i) {
        const n = i[0],
          r = i[1],
          s = i[2],
          a = i[3],
          o = i[4],
          l = [];
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t],
            i = r[t],
            h = s[t],
            c = a[t],
            u = o[t];
          if (void 0 === e) continue;
          let d;
          switch ((e.updateMatrix(), (e.matrixAutoUpdate = !0), cr[u.path])) {
            case cr.weights:
              d = N;
              break;
            case cr.rotation:
              d = B;
              break;
            default:
              d = H;
          }
          const p = e.name ? e.name : e.uuid,
            m = void 0 !== c.interpolation ? ur[c.interpolation] : M,
            f = [];
          cr[u.path] === cr.weights
            ? e.traverse(function (t) {
                t.morphTargetInfluences && f.push(t.name ? t.name : t.uuid);
              })
            : f.push(p);
          let g = h.array;
          if (h.normalized) {
            const t = _r(g.constructor),
              e = new Float32Array(g.length);
            for (let i = 0, n = g.length; i < n; i++) e[i] = g[i] * t;
            g = e;
          }
          for (let t = 0, e = f.length; t < e; t++) {
            const e = new d(f[t] + "." + cr[u.path], i.array, g, m);
            "CUBICSPLINE" === c.interpolation &&
              ((e.createInterpolant = function (t) {
                return new (this instanceof B ? Kn : Jn)(
                  this.times,
                  this.values,
                  this.getValueSize() / 3,
                  t
                );
              }),
              (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                !0)),
              l.push(e);
          }
        }
        const h = e.name ? e.name : "animation_" + t;
        return new U(h, void 0, l);
      });
    }
    createNodeMesh(t) {
      const e = this.json,
        i = this,
        n = e.nodes[t];
      return void 0 === n.mesh
        ? null
        : i.getDependency("mesh", n.mesh).then(function (t) {
            const e = i._getNodeRef(i.meshCache, n.mesh, t);
            return (
              void 0 !== n.weights &&
                e.traverse(function (t) {
                  if (t.isMesh)
                    for (let e = 0, i = n.weights.length; e < i; e++)
                      t.morphTargetInfluences[e] = n.weights[e];
                }),
              e
            );
          });
    }
    loadNode(t) {
      const e = this.json,
        i = this.extensions,
        n = this,
        r = e.nodes[t],
        s = r.name ? n.createUniqueName(r.name) : "";
      return (function () {
        const e = [],
          i = n._invokeOne(function (e) {
            return e.createNodeMesh && e.createNodeMesh(t);
          });
        return (
          i && e.push(i),
          void 0 !== r.camera &&
            e.push(
              n.getDependency("camera", r.camera).then(function (t) {
                return n._getNodeRef(n.cameraCache, r.camera, t);
              })
            ),
          n
            ._invokeAll(function (e) {
              return e.createNodeAttachment && e.createNodeAttachment(t);
            })
            .forEach(function (t) {
              e.push(t);
            }),
          Promise.all(e)
        );
      })().then(function (e) {
        let a;
        if (
          ((a =
            !0 === r.isBone
              ? new vt()
              : e.length > 1
              ? new Pe()
              : 1 === e.length
              ? e[0]
              : new xt()),
          a !== e[0])
        )
          for (let t = 0, i = e.length; t < i; t++) a.add(e[t]);
        if (
          (r.name && ((a.userData.name = r.name), (a.name = s)),
          gr(a, r),
          r.extensions && fr(i, a, r),
          void 0 !== r.matrix)
        ) {
          const t = new j();
          t.fromArray(r.matrix), a.applyMatrix4(t);
        } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
        return (
          n.associations.has(a) || n.associations.set(a, {}),
          (n.associations.get(a).nodes = t),
          a
        );
      });
    }
    loadScene(t) {
      const e = this.json,
        i = this.extensions,
        n = this.json.scenes[t],
        r = this,
        s = new Pe();
      n.name && (s.name = r.createUniqueName(n.name)),
        gr(s, n),
        n.extensions && fr(i, s, n);
      const a = n.nodes || [],
        o = [];
      for (let t = 0, i = a.length; t < i; t++) o.push(Mr(a[t], s, e, r));
      return Promise.all(o).then(function () {
        return (
          (r.associations = ((t) => {
            const e = new Map();
            for (const [t, i] of r.associations)
              (t instanceof We || t instanceof si) && e.set(t, i);
            return (
              t.traverse((t) => {
                const i = r.associations.get(t);
                null != i && e.set(t, i);
              }),
              e
            );
          })(s)),
          s
        );
      });
    }
  }
  function Mr(t, e, i, n) {
    const r = i.nodes[t];
    return n
      .getDependency("node", t)
      .then(function (t) {
        if (void 0 === r.skin) return t;
        let e;
        return n
          .getDependency("skin", r.skin)
          .then(function (t) {
            e = t;
            const i = [];
            for (let t = 0, r = e.joints.length; t < r; t++)
              i.push(n.getDependency("node", e.joints[t]));
            return Promise.all(i);
          })
          .then(function (i) {
            return (
              t.traverse(function (t) {
                if (!t.isMesh) return;
                const n = [],
                  r = [];
                for (let t = 0, s = i.length; t < s; t++) {
                  const s = i[t];
                  if (s) {
                    n.push(s);
                    const i = new j();
                    void 0 !== e.inverseBindMatrices &&
                      i.fromArray(e.inverseBindMatrices.array, 16 * t),
                      r.push(i);
                  } else
                    console.warn(
                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                      e.joints[t]
                    );
                }
                t.bind(new Qi(n, r), t.matrixWorld);
              }),
              t
            );
          });
      })
      .then(function (t) {
        e.add(t);
        const s = [];
        if (r.children) {
          const e = r.children;
          for (let r = 0, a = e.length; r < a; r++) {
            const a = e[r];
            s.push(Mr(a, t, i, n));
          }
        }
        return Promise.all(s);
      });
  }
  function wr(t, e, i) {
    const n = e.attributes,
      r = [];
    function s(e, n) {
      return i.getDependency("accessor", e).then(function (e) {
        t.setAttribute(n, e);
      });
    }
    for (const e in n) {
      const i = hr[e] || e.toLowerCase();
      i in t.attributes || r.push(s(n[e], i));
    }
    if (void 0 !== e.indices && !t.index) {
      const n = i.getDependency("accessor", e.indices).then(function (e) {
        t.setIndex(e);
      });
      r.push(n);
    }
    return (
      gr(t, e),
      (function (t, e, i) {
        const n = e.attributes,
          r = new _t();
        if (void 0 === n.POSITION) return;
        {
          const t = i.json.accessors[n.POSITION],
            e = t.min,
            s = t.max;
          if (void 0 === e || void 0 === s)
            return void console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
          if (
            (r.set(new G(e[0], e[1], e[2]), new G(s[0], s[1], s[2])),
            t.normalized)
          ) {
            const e = _r(sr[t.componentType]);
            r.min.multiplyScalar(e), r.max.multiplyScalar(e);
          }
        }
        const s = e.targets;
        if (void 0 !== s) {
          const t = new G(),
            e = new G();
          for (let n = 0, r = s.length; n < r; n++) {
            const r = s[n];
            if (void 0 !== r.POSITION) {
              const n = i.json.accessors[r.POSITION],
                s = n.min,
                a = n.max;
              if (void 0 !== s && void 0 !== a) {
                if (
                  (e.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                  e.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                  e.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                  n.normalized)
                ) {
                  const t = _r(sr[n.componentType]);
                  e.multiplyScalar(t);
                }
                t.max(e);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          r.expandByVector(t);
        }
        t.boundingBox = r;
        const a = new te();
        r.getCenter(a.center),
          (a.radius = r.min.distanceTo(r.max) / 2),
          (t.boundingSphere = a);
      })(t, e, i),
      Promise.all(r).then(function () {
        return void 0 !== e.targets
          ? (function (t, e, i) {
              let n = !1,
                r = !1;
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                if (
                  (void 0 !== i.POSITION && (n = !0),
                  void 0 !== i.NORMAL && (r = !0),
                  n && r)
                )
                  break;
              }
              if (!n && !r) return Promise.resolve(t);
              const s = [],
                a = [];
              for (let o = 0, l = e.length; o < l; o++) {
                const l = e[o];
                if (n) {
                  const e =
                    void 0 !== l.POSITION
                      ? i.getDependency("accessor", l.POSITION)
                      : t.attributes.position;
                  s.push(e);
                }
                if (r) {
                  const e =
                    void 0 !== l.NORMAL
                      ? i.getDependency("accessor", l.NORMAL)
                      : t.attributes.normal;
                  a.push(e);
                }
              }
              return Promise.all([Promise.all(s), Promise.all(a)]).then(
                function (e) {
                  const i = e[0],
                    s = e[1];
                  return (
                    n && (t.morphAttributes.position = i),
                    r && (t.morphAttributes.normal = s),
                    (t.morphTargetsRelative = !0),
                    t
                  );
                }
              );
            })(t, e.targets, i)
          : t;
      })
    );
  }
  function Sr(t, e) {
    let i = t.getIndex();
    if (null === i) {
      const e = [],
        n = t.getAttribute("position");
      if (void 0 === n)
        return (
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          t
        );
      for (let t = 0; t < n.count; t++) e.push(t);
      t.setIndex(e), (i = t.getIndex());
    }
    const n = i.count - 2,
      r = [];
    if (2 === e)
      for (let t = 1; t <= n; t++)
        r.push(i.getX(0)), r.push(i.getX(t)), r.push(i.getX(t + 1));
    else
      for (let t = 0; t < n; t++)
        t % 2 == 0
          ? (r.push(i.getX(t)), r.push(i.getX(t + 1)), r.push(i.getX(t + 2)))
          : (r.push(i.getX(t + 2)), r.push(i.getX(t + 1)), r.push(i.getX(t)));
    r.length / 3 !== n &&
      console.error(
        "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = t.clone();
    return s.setIndex(r), s;
  }
  class Tr {
    constructor(t = 1, e = 0, i = 0) {
      return (this.radius = t), (this.phi = e), (this.theta = i), this;
    }
    set(t, e, i) {
      return (this.radius = t), (this.phi = e), (this.theta = i), this;
    }
    copy(t) {
      return (
        (this.radius = t.radius),
        (this.phi = t.phi),
        (this.theta = t.theta),
        this
      );
    }
    makeSafe() {
      const t = 1e-6;
      return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e, i) {
      return (
        (this.radius = Math.sqrt(t * t + e * e + i * i)),
        0 === this.radius
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(t, i)),
            (this.phi = Math.acos(u(e / this.radius, -1, 1)))),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Er = 0,
    Ar = 1,
    Rr = 2,
    Lr = 0,
    Cr = 1,
    Pr = 2,
    Ir = 3,
    zr = { type: "change" },
    Dr = { type: "start" },
    Nr = { type: "end" };
  class Or extends $ {
    constructor(t, e) {
      super(),
        void 0 === e &&
          console.warn(
            'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
          ),
        e === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
        (this.object = t),
        (this.domElement = e),
        (this.domElement.style.touchAction = "none"),
        (this.enabled = !0),
        (this.target = new G()),
        (this.minDistance = 0),
        (this.maxDistance = 1 / 0),
        (this.minZoom = 0),
        (this.maxZoom = 1 / 0),
        (this.minPolarAngle = 0),
        (this.maxPolarAngle = Math.PI),
        (this.minAzimuthAngle = -1 / 0),
        (this.maxAzimuthAngle = 1 / 0),
        (this.enableDamping = !1),
        (this.dampingFactor = 0.05),
        (this.enableZoom = !0),
        (this.zoomSpeed = 1),
        (this.enableRotate = !0),
        (this.rotateSpeed = 1),
        (this.enablePan = !0),
        (this.panSpeed = 1),
        (this.screenSpacePanning = !0),
        (this.keyPanSpeed = 7),
        (this.autoRotate = !1),
        (this.autoRotateSpeed = 2),
        (this.keys = {
          LEFT: "ArrowLeft",
          UP: "ArrowUp",
          RIGHT: "ArrowRight",
          BOTTOM: "ArrowDown",
        }),
        (this.mouseButtons = { LEFT: Er, MIDDLE: Ar, RIGHT: Rr }),
        (this.touches = { ONE: Lr, TWO: Pr }),
        (this.target0 = this.target.clone()),
        (this.position0 = this.object.position.clone()),
        (this.zoom0 = this.object.zoom),
        (this._domElementKeyEvents = null),
        (this.getPolarAngle = function () {
          return a.phi;
        }),
        (this.getAzimuthalAngle = function () {
          return a.theta;
        }),
        (this.getDistance = function () {
          return this.object.position.distanceTo(this.target);
        }),
        (this.listenToKeyEvents = function (t) {
          t.addEventListener("keydown", j), (this._domElementKeyEvents = t);
        }),
        (this.saveState = function () {
          i.target0.copy(i.target),
            i.position0.copy(i.object.position),
            (i.zoom0 = i.object.zoom);
        }),
        (this.reset = function () {
          i.target.copy(i.target0),
            i.object.position.copy(i.position0),
            (i.object.zoom = i.zoom0),
            i.object.updateProjectionMatrix(),
            i.dispatchEvent(zr),
            i.update(),
            (r = n.NONE);
        }),
        (this.update = (function () {
          const e = new G(),
            u = new m().setFromUnitVectors(t.up, new G(0, 1, 0)),
            d = u.clone().invert(),
            p = new G(),
            f = new m(),
            g = 2 * Math.PI;
          return function () {
            const t = i.object.position;
            e.copy(t).sub(i.target),
              e.applyQuaternion(u),
              a.setFromVector3(e),
              i.autoRotate &&
                r === n.NONE &&
                S(((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed),
              i.enableDamping
                ? ((a.theta += o.theta * i.dampingFactor),
                  (a.phi += o.phi * i.dampingFactor))
                : ((a.theta += o.theta), (a.phi += o.phi));
            let m = i.minAzimuthAngle,
              y = i.maxAzimuthAngle;
            return (
              isFinite(m) &&
                isFinite(y) &&
                (m < -Math.PI ? (m += g) : m > Math.PI && (m -= g),
                y < -Math.PI ? (y += g) : y > Math.PI && (y -= g),
                (a.theta =
                  m <= y
                    ? Math.max(m, Math.min(y, a.theta))
                    : a.theta > (m + y) / 2
                    ? Math.max(m, a.theta)
                    : Math.min(y, a.theta))),
              (a.phi = Math.max(
                i.minPolarAngle,
                Math.min(i.maxPolarAngle, a.phi)
              )),
              a.makeSafe(),
              (a.radius *= l),
              (a.radius = Math.max(
                i.minDistance,
                Math.min(i.maxDistance, a.radius)
              )),
              !0 === i.enableDamping
                ? i.target.addScaledVector(h, i.dampingFactor)
                : i.target.add(h),
              e.setFromSpherical(a),
              e.applyQuaternion(d),
              t.copy(i.target).add(e),
              i.object.lookAt(i.target),
              !0 === i.enableDamping
                ? ((o.theta *= 1 - i.dampingFactor),
                  (o.phi *= 1 - i.dampingFactor),
                  h.multiplyScalar(1 - i.dampingFactor))
                : (o.set(0, 0, 0), h.set(0, 0, 0)),
              (l = 1),
              !!(
                c ||
                p.distanceToSquared(i.object.position) > s ||
                8 * (1 - f.dot(i.object.quaternion)) > s
              ) &&
                (i.dispatchEvent(zr),
                p.copy(i.object.position),
                f.copy(i.object.quaternion),
                (c = !1),
                !0)
            );
          };
        })()),
        (this.dispose = function () {
          i.domElement.removeEventListener("contextmenu", q),
            i.domElement.removeEventListener("pointerdown", H),
            i.domElement.removeEventListener("pointercancel", V),
            i.domElement.removeEventListener("wheel", W),
            i.domElement.removeEventListener("pointermove", U),
            i.domElement.removeEventListener("pointerup", k),
            null !== i._domElementKeyEvents &&
              i._domElementKeyEvents.removeEventListener("keydown", j);
        });
      const i = this,
        n = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6,
        };
      let r = n.NONE;
      const s = 1e-6,
        a = new Tr(),
        o = new Tr();
      let l = 1;
      const h = new G();
      let c = !1;
      const u = new Ot(),
        d = new Ot(),
        p = new Ot(),
        f = new Ot(),
        g = new Ot(),
        y = new Ot(),
        x = new Ot(),
        v = new Ot(),
        _ = new Ot(),
        b = [],
        M = {};
      function w() {
        return Math.pow(0.95, i.zoomSpeed);
      }
      function S(t) {
        o.theta -= t;
      }
      function T(t) {
        o.phi -= t;
      }
      const E = (function () {
          const t = new G();
          return function (e, i) {
            t.setFromMatrixColumn(i, 0), t.multiplyScalar(-e), h.add(t);
          };
        })(),
        A = (function () {
          const t = new G();
          return function (e, n) {
            !0 === i.screenSpacePanning
              ? t.setFromMatrixColumn(n, 1)
              : (t.setFromMatrixColumn(n, 0), t.crossVectors(i.object.up, t)),
              t.multiplyScalar(e),
              h.add(t);
          };
        })(),
        R = (function () {
          const t = new G();
          return function (e, n) {
            const r = i.domElement;
            if (i.object.isPerspectiveCamera) {
              const s = i.object.position;
              t.copy(s).sub(i.target);
              let a = t.length();
              (a *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
                E((2 * e * a) / r.clientHeight, i.object.matrix),
                A((2 * n * a) / r.clientHeight, i.object.matrix);
            } else
              i.object.isOrthographicCamera
                ? (E(
                    (e * (i.object.right - i.object.left)) /
                      i.object.zoom /
                      r.clientWidth,
                    i.object.matrix
                  ),
                  A(
                    (n * (i.object.top - i.object.bottom)) /
                      i.object.zoom /
                      r.clientHeight,
                    i.object.matrix
                  ))
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                  ),
                  (i.enablePan = !1));
          };
        })();
      function L(t) {
        i.object.isPerspectiveCamera
          ? (l /= t)
          : i.object.isOrthographicCamera
          ? ((i.object.zoom = Math.max(
              i.minZoom,
              Math.min(i.maxZoom, i.object.zoom * t)
            )),
            i.object.updateProjectionMatrix(),
            (c = !0))
          : (console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            ),
            (i.enableZoom = !1));
      }
      function C(t) {
        i.object.isPerspectiveCamera
          ? (l *= t)
          : i.object.isOrthographicCamera
          ? ((i.object.zoom = Math.max(
              i.minZoom,
              Math.min(i.maxZoom, i.object.zoom / t)
            )),
            i.object.updateProjectionMatrix(),
            (c = !0))
          : (console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            ),
            (i.enableZoom = !1));
      }
      function P(t) {
        u.set(t.clientX, t.clientY);
      }
      function I(t) {
        f.set(t.clientX, t.clientY);
      }
      function z() {
        if (1 === b.length) u.set(b[0].pageX, b[0].pageY);
        else {
          const t = 0.5 * (b[0].pageX + b[1].pageX),
            e = 0.5 * (b[0].pageY + b[1].pageY);
          u.set(t, e);
        }
      }
      function D() {
        if (1 === b.length) f.set(b[0].pageX, b[0].pageY);
        else {
          const t = 0.5 * (b[0].pageX + b[1].pageX),
            e = 0.5 * (b[0].pageY + b[1].pageY);
          f.set(t, e);
        }
      }
      function N() {
        const t = b[0].pageX - b[1].pageX,
          e = b[0].pageY - b[1].pageY,
          i = Math.sqrt(t * t + e * e);
        x.set(0, i);
      }
      function O(t) {
        if (1 == b.length) d.set(t.pageX, t.pageY);
        else {
          const e = J(t),
            i = 0.5 * (t.pageX + e.x),
            n = 0.5 * (t.pageY + e.y);
          d.set(i, n);
        }
        p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
        const e = i.domElement;
        S((2 * Math.PI * p.x) / e.clientHeight),
          T((2 * Math.PI * p.y) / e.clientHeight),
          u.copy(d);
      }
      function B(t) {
        if (1 === b.length) g.set(t.pageX, t.pageY);
        else {
          const e = J(t),
            i = 0.5 * (t.pageX + e.x),
            n = 0.5 * (t.pageY + e.y);
          g.set(i, n);
        }
        y.subVectors(g, f).multiplyScalar(i.panSpeed), R(y.x, y.y), f.copy(g);
      }
      function F(t) {
        const e = J(t),
          n = t.pageX - e.x,
          r = t.pageY - e.y,
          s = Math.sqrt(n * n + r * r);
        v.set(0, s),
          _.set(0, Math.pow(v.y / x.y, i.zoomSpeed)),
          L(_.y),
          x.copy(v);
      }
      function H(t) {
        !1 !== i.enabled &&
          (0 === b.length &&
            (i.domElement.setPointerCapture(t.pointerId),
            i.domElement.addEventListener("pointermove", U),
            i.domElement.addEventListener("pointerup", k)),
          (function (t) {
            b.push(t);
          })(t),
          "touch" === t.pointerType
            ? (function (t) {
                switch ((Y(t), b.length)) {
                  case 1:
                    switch (i.touches.ONE) {
                      case Lr:
                        if (!1 === i.enableRotate) return;
                        z(), (r = n.TOUCH_ROTATE);
                        break;
                      case Cr:
                        if (!1 === i.enablePan) return;
                        D(), (r = n.TOUCH_PAN);
                        break;
                      default:
                        r = n.NONE;
                    }
                    break;
                  case 2:
                    switch (i.touches.TWO) {
                      case Pr:
                        if (!1 === i.enableZoom && !1 === i.enablePan) return;
                        i.enableZoom && N(),
                          i.enablePan && D(),
                          (r = n.TOUCH_DOLLY_PAN);
                        break;
                      case Ir:
                        if (!1 === i.enableZoom && !1 === i.enableRotate)
                          return;
                        i.enableZoom && N(),
                          i.enableRotate && z(),
                          (r = n.TOUCH_DOLLY_ROTATE);
                        break;
                      default:
                        r = n.NONE;
                    }
                    break;
                  default:
                    r = n.NONE;
                }
                r !== n.NONE && i.dispatchEvent(Dr);
              })(t)
            : (function (t) {
                let e;
                switch (t.button) {
                  case 0:
                    e = i.mouseButtons.LEFT;
                    break;
                  case 1:
                    e = i.mouseButtons.MIDDLE;
                    break;
                  case 2:
                    e = i.mouseButtons.RIGHT;
                    break;
                  default:
                    e = -1;
                }
                switch (e) {
                  case Ar:
                    if (!1 === i.enableZoom) return;
                    !(function (t) {
                      x.set(t.clientX, t.clientY);
                    })(t),
                      (r = n.DOLLY);
                    break;
                  case Er:
                    if (t.ctrlKey || t.metaKey || t.shiftKey) {
                      if (!1 === i.enablePan) return;
                      I(t), (r = n.PAN);
                    } else {
                      if (!1 === i.enableRotate) return;
                      P(t), (r = n.ROTATE);
                    }
                    break;
                  case Rr:
                    if (t.ctrlKey || t.metaKey || t.shiftKey) {
                      if (!1 === i.enableRotate) return;
                      P(t), (r = n.ROTATE);
                    } else {
                      if (!1 === i.enablePan) return;
                      I(t), (r = n.PAN);
                    }
                    break;
                  default:
                    r = n.NONE;
                }
                r !== n.NONE && i.dispatchEvent(Dr);
              })(t));
      }
      function U(t) {
        !1 !== i.enabled &&
          ("touch" === t.pointerType
            ? (function (t) {
                switch ((Y(t), r)) {
                  case n.TOUCH_ROTATE:
                    if (!1 === i.enableRotate) return;
                    O(t), i.update();
                    break;
                  case n.TOUCH_PAN:
                    if (!1 === i.enablePan) return;
                    B(t), i.update();
                    break;
                  case n.TOUCH_DOLLY_PAN:
                    if (!1 === i.enableZoom && !1 === i.enablePan) return;
                    !(function (t) {
                      i.enableZoom && F(t), i.enablePan && B(t);
                    })(t),
                      i.update();
                    break;
                  case n.TOUCH_DOLLY_ROTATE:
                    if (!1 === i.enableZoom && !1 === i.enableRotate) return;
                    !(function (t) {
                      i.enableZoom && F(t), i.enableRotate && O(t);
                    })(t),
                      i.update();
                    break;
                  default:
                    r = n.NONE;
                }
              })(t)
            : (function (t) {
                if (!1 === i.enabled) return;
                switch (r) {
                  case n.ROTATE:
                    if (!1 === i.enableRotate) return;
                    !(function (t) {
                      d.set(t.clientX, t.clientY),
                        p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
                      const e = i.domElement;
                      S((2 * Math.PI * p.x) / e.clientHeight),
                        T((2 * Math.PI * p.y) / e.clientHeight),
                        u.copy(d),
                        i.update();
                    })(t);
                    break;
                  case n.DOLLY:
                    if (!1 === i.enableZoom) return;
                    !(function (t) {
                      v.set(t.clientX, t.clientY),
                        _.subVectors(v, x),
                        _.y > 0 ? L(w()) : _.y < 0 && C(w()),
                        x.copy(v),
                        i.update();
                    })(t);
                    break;
                  case n.PAN:
                    if (!1 === i.enablePan) return;
                    !(function (t) {
                      g.set(t.clientX, t.clientY),
                        y.subVectors(g, f).multiplyScalar(i.panSpeed),
                        R(y.x, y.y),
                        f.copy(g),
                        i.update();
                    })(t);
                }
              })(t));
      }
      function k(t) {
        X(t),
          0 === b.length &&
            (i.domElement.releasePointerCapture(t.pointerId),
            i.domElement.removeEventListener("pointermove", U),
            i.domElement.removeEventListener("pointerup", k)),
          i.dispatchEvent(Nr),
          (r = n.NONE);
      }
      function V(t) {
        X(t);
      }
      function W(t) {
        !1 !== i.enabled &&
          !1 !== i.enableZoom &&
          r === n.NONE &&
          (t.preventDefault(),
          i.dispatchEvent(Dr),
          (function (t) {
            t.deltaY < 0 ? C(w()) : t.deltaY > 0 && L(w()), i.update();
          })(t),
          i.dispatchEvent(Nr));
      }
      function j(t) {
        !1 !== i.enabled &&
          !1 !== i.enablePan &&
          (function (t) {
            let e = !1;
            switch (t.code) {
              case i.keys.UP:
                R(0, i.keyPanSpeed), (e = !0);
                break;
              case i.keys.BOTTOM:
                R(0, -i.keyPanSpeed), (e = !0);
                break;
              case i.keys.LEFT:
                R(i.keyPanSpeed, 0), (e = !0);
                break;
              case i.keys.RIGHT:
                R(-i.keyPanSpeed, 0), (e = !0);
            }
            e && (t.preventDefault(), i.update());
          })(t);
      }
      function q(t) {
        !1 !== i.enabled && t.preventDefault();
      }
      function X(t) {
        delete M[t.pointerId];
        for (let e = 0; e < b.length; e++)
          if (b[e].pointerId == t.pointerId) return void b.splice(e, 1);
      }
      function Y(t) {
        let e = M[t.pointerId];
        void 0 === e && ((e = new Ot()), (M[t.pointerId] = e)),
          e.set(t.pageX, t.pageY);
      }
      function J(t) {
        const e = t.pointerId === b[0].pointerId ? b[1] : b[0];
        return M[e.pointerId];
      }
      i.domElement.addEventListener("contextmenu", q),
        i.domElement.addEventListener("pointerdown", H),
        i.domElement.addEventListener("pointercancel", V),
        i.domElement.addEventListener("wheel", W, { passive: !1 }),
        this.update();
    }
  }
  function Br() {
    const t = document.querySelector("._tab-active"),
      e = document
        .querySelector(`.tabs__body_${t.innerHTML.toLowerCase()}`)
        .querySelector(".other-screen__item._active");
    e.closest(".screen-tab").dataset.pid = `${t.innerHTML.toLowerCase()}-${
      e.dataset.photo
    }`;
  }
  class Fr {
    static isWebGLAvailable() {
      try {
        const t = document.createElement("canvas");
        return !(
          !window.WebGLRenderingContext ||
          (!t.getContext("webgl") && !t.getContext("experimental-webgl"))
        );
      } catch (t) {
        return !1;
      }
    }
    static isWebGL2Available() {
      try {
        const t = document.createElement("canvas");
        return !(!window.WebGL2RenderingContext || !t.getContext("webgl2"));
      } catch (t) {
        return !1;
      }
    }
    static getWebGLErrorMessage() {
      return this.getErrorMessage(1);
    }
    static getWebGL2ErrorMessage() {
      return this.getErrorMessage(2);
    }
    static getErrorMessage(t) {
      const e = {
        1: window.WebGLRenderingContext,
        2: window.WebGL2RenderingContext,
      };
      let i =
        'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';
      const n = document.createElement("div");
      return (
        (n.id = "webglmessage"),
        (n.style.fontFamily = "monospace"),
        (i = e[t]
          ? i.replace("$0", "graphics card")
          : i.replace("$0", "browser")),
        (i = i.replace("$1", { 1: "WebGL", 2: "WebGL 2" }[t])),
        (n.innerHTML = i),
        n
      );
    }
  }
  !(function () {
    const t = document.querySelector("#scene").querySelector(".popup__content"),
      e = new THREE.Scene();
    let i = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1e3
    );
    const n = new THREE.WebGLRenderer({ alpha: !0, antialias: !0 });
    n.setSize(window.innerWidth, window.innerHeight),
      n.setClearColor(0, 0),
      t.appendChild(n.domElement);
    const r = new THREE.AmbientLight(4210752, 1.5);
    e.add(r);
    const s = new THREE.PointLight(16777215, 1.2);
    s.position.set(50, 0, 50), e.add(s);
    const a = new Or(i, n.domElement);
    (i.position.z = 5),
      (i.position.y = 2),
      (a.autoRotate = !0),
      (a.autoRotateSpeed = 4),
      (a.enablePan = !1),
      (a.maxDistance = 10),
      (a.minDistance = 1),
      a.update();
    const o = new En();
    let l = null;
    function h() {
      requestAnimationFrame(h), a.update(), n.render(e, i);
    }
    o.load(
      "../../model/scene.gltf",
      function (t) {
        (l = t), l.scene.position.set(0, -1), e.add(l.scene);
      },
      void 0,
      function (t) {
        alert(t);
      },
      void 0,
      function (t) {
        console.error(t);
      }
    ),
      window.addEventListener("resize", function () {
        n.setSize(window.innerWidth, window.innerHeight),
          (i.aspect = window.innerWidth / window.innerHeight),
          i.updateProjectionMatrix(),
          a.update();
      }),
      (function () {
        if (Fr.isWebGLAvailable()) h();
        else {
          const e = Fr.getWebGLErrorMessage();
          t.appendChild(e);
        }
      })();
  })();
  class Hr {
    constructor(t) {
      let e = {
        logging: !0,
        init: !0,
        attributeOpenButton: "data-popup",
        attributeCloseButton: "data-close",
        fixElementSelector: "[data-lp]",
        youtubeAttribute: "data-youtube",
        youtubePlaceAttribute: "data-youtube-place",
        setAutoplayYoutube: !0,
        classes: {
          popup: "popup",
          popupContent: "popup__content",
          popupActive: "popup_show",
          bodyActive: "popup-show",
        },
        focusCatch: !0,
        closeEsc: !0,
        bodyLock: !0,
        bodyLockDelay: 500,
        hashSettings: { location: !0, goHash: !0 },
        on: {
          beforeOpen: function () {},
          afterOpen: function () {},
          beforeClose: function () {},
          afterClose: function () {},
        },
      };
      (this.isOpen = !1),
        (this.targetOpen = { selector: !1, element: !1 }),
        (this.previousOpen = { selector: !1, element: !1 }),
        (this.lastClosed = { selector: !1, element: !1 }),
        (this._dataValue = !1),
        (this.hash = !1),
        (this._reopen = !1),
        (this._selectorOpen = !1),
        (this.lastFocusEl = !1),
        (this._focusEl = [
          "a[href]",
          'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
          "button:not([disabled]):not([aria-hidden])",
          "select:not([disabled]):not([aria-hidden])",
          "textarea:not([disabled]):not([aria-hidden])",
          "area[href]",
          "iframe",
          "object",
          "embed",
          "[contenteditable]",
          '[tabindex]:not([tabindex^="-"])',
        ]),
        (this.options = {
          ...e,
          ...t,
          classes: { ...e.classes, ...t?.classes },
          hashSettings: { ...e.hashSettings, ...t?.hashSettings },
          on: { ...e.on, ...t?.on },
        }),
        this.options.init && this.initPopups();
    }
    initPopups() {
      this.popupLogging("Проснулся"), this.eventsPopup();
    }
    eventsPopup() {
      document.addEventListener(
        "click",
        function (t) {
          const e = t.target.closest(`[${this.options.attributeOpenButton}]`);
          if (e)
            return (
              t.preventDefault(),
              (this._dataValue = e.getAttribute(
                this.options.attributeOpenButton
              )
                ? e.getAttribute(this.options.attributeOpenButton)
                : "error"),
              "error" !== this._dataValue
                ? (this.isOpen || (this.lastFocusEl = e),
                  (this.targetOpen.selector = `${this._dataValue}`),
                  (this._selectorOpen = !0),
                  void this.open())
                : void this.popupLogging(
                    `Ой ой, не заполнен атрибут у ${e.classList}`
                  )
            );
          return t.target.closest(`[${this.options.attributeCloseButton}]`) ||
            (!t.target.closest(`.${this.options.classes.popupContent}`) &&
              this.isOpen)
            ? (t.preventDefault(), void this.close())
            : void 0;
        }.bind(this)
      ),
        document.addEventListener(
          "keydown",
          function (t) {
            if (
              this.options.closeEsc &&
              27 == t.which &&
              "Escape" === t.code &&
              this.isOpen
            )
              return t.preventDefault(), void this.close();
            this.options.focusCatch &&
              9 == t.which &&
              this.isOpen &&
              this._focusCatch(t);
          }.bind(this)
        ),
        document.querySelector("form[data-ajax],form[data-dev]") &&
          document.addEventListener(
            "formSent",
            function (t) {
              const e = t.detail.form.dataset.popupMessage;
              e && this.open(e);
            }.bind(this)
          ),
        this.options.hashSettings.goHash &&
          (window.addEventListener(
            "hashchange",
            function () {
              window.location.hash
                ? this._openToHash()
                : this.close(this.targetOpen.selector);
            }.bind(this)
          ),
          window.addEventListener(
            "load",
            function () {
              window.location.hash && this._openToHash();
            }.bind(this)
          ));
    }
    open(t) {
      if (
        (t &&
          "string" == typeof t &&
          "" !== t.trim() &&
          ((this.targetOpen.selector = t), (this._selectorOpen = !0)),
        this.isOpen && ((this._reopen = !0), this.close()),
        this._selectorOpen ||
          (this.targetOpen.selector = this.lastClosed.selector),
        this._reopen || (this.previousActiveElement = document.activeElement),
        (this.targetOpen.element = document.querySelector(
          this.targetOpen.selector
        )),
        this.targetOpen.element)
      ) {
        if (
          this.targetOpen.element.hasAttribute(this.options.youtubeAttribute)
        ) {
          const t = `https://www.youtube.com/embed/${this.targetOpen.element.getAttribute(
              this.options.youtubeAttribute
            )}?rel=0&showinfo=0&autoplay=1`,
            e = document.createElement("iframe");
          e.setAttribute("allowfullscreen", "");
          const i = this.options.setAutoplayYoutube ? "autoplay;" : "";
          e.setAttribute("allow", `${i}; encrypted-media`),
            e.setAttribute("src", t),
            this.targetOpen.element.querySelector(
              `[${this.options.youtubePlaceAttribute}]`
            ) &&
              this.targetOpen.element
                .querySelector(`[${this.options.youtubePlaceAttribute}]`)
                .appendChild(e);
        }
        this.options.hashSettings.location &&
          (this._getHash(), this._setHash()),
          this.options.on.beforeOpen(this),
          this.targetOpen.element.classList.add(
            this.options.classes.popupActive
          ),
          document.body.classList.add(this.options.classes.bodyActive),
          this._reopen ? (this._reopen = !1) : Vr(),
          this.targetOpen.element.setAttribute("aria-hidden", "false"),
          (this.previousOpen.selector = this.targetOpen.selector),
          (this.previousOpen.element = this.targetOpen.element),
          (this._selectorOpen = !1),
          (this.isOpen = !0),
          setTimeout(() => {
            this._focusTrap();
          }, 50),
          document.dispatchEvent(
            new CustomEvent("afterPopupOpen", { detail: { popup: this } })
          ),
          this.popupLogging("Открыл попап");
      } else
        this.popupLogging(
          "Ой ой, такого попапа нет. Проверьте корректность ввода. "
        );
    }
    close(t) {
      t &&
        "string" == typeof t &&
        "" !== t.trim() &&
        (this.previousOpen.selector = t),
        this.isOpen &&
          Gr &&
          (this.options.on.beforeClose(this),
          this.targetOpen.element.hasAttribute(this.options.youtubeAttribute) &&
            this.targetOpen.element.querySelector(
              `[${this.options.youtubePlaceAttribute}]`
            ) &&
            (this.targetOpen.element.querySelector(
              `[${this.options.youtubePlaceAttribute}]`
            ).innerHTML = ""),
          this.previousOpen.element.classList.remove(
            this.options.classes.popupActive
          ),
          this.previousOpen.element.setAttribute("aria-hidden", "true"),
          this._reopen ||
            (document.body.classList.remove(this.options.classes.bodyActive),
            Vr(),
            (this.isOpen = !1)),
          this._removeHash(),
          this._selectorOpen &&
            ((this.lastClosed.selector = this.previousOpen.selector),
            (this.lastClosed.element = this.previousOpen.element)),
          this.options.on.afterClose(this),
          setTimeout(() => {
            this._focusTrap();
          }, 50),
          this.popupLogging("Закрыл попап"));
    }
    _getHash() {
      this.options.hashSettings.location &&
        (this.hash = this.targetOpen.selector.includes("#")
          ? this.targetOpen.selector
          : this.targetOpen.selector.replace(".", "#"));
    }
    _openToHash() {
      let t = document.querySelector(
        `.${window.location.hash.replace("#", "")}`
      )
        ? `.${window.location.hash.replace("#", "")}`
        : document.querySelector(`${window.location.hash}`)
        ? `${window.location.hash}`
        : null;
      document.querySelector(`[${this.options.attributeOpenButton}="${t}"]`) &&
        t &&
        this.open(t);
    }
    _setHash() {
      history.pushState("", "", this.hash);
    }
    _removeHash() {
      history.pushState("", "", window.location.href.split("#")[0]);
    }
    _focusCatch(t) {
      const e = this.targetOpen.element.querySelectorAll(this._focusEl),
        i = Array.prototype.slice.call(e),
        n = i.indexOf(document.activeElement);
      t.shiftKey && 0 === n && (i[i.length - 1].focus(), t.preventDefault()),
        t.shiftKey || n !== i.length - 1 || (i[0].focus(), t.preventDefault());
    }
    _focusTrap() {
      const t = this.previousOpen.element.querySelectorAll(this._focusEl);
      !this.isOpen && this.lastFocusEl
        ? this.lastFocusEl.focus()
        : t[0].focus();
    }
    popupLogging(t) {
      this.options.logging && Xr(`[Попапос]: ${t}`);
    }
  }
  let Ur = (t, e = 500, i = 0) => {
      t.classList.contains("_slide") ||
        (t.classList.add("_slide"),
        (t.style.transitionProperty = "height, margin, padding"),
        (t.style.transitionDuration = e + "ms"),
        (t.style.height = `${t.offsetHeight}px`),
        t.offsetHeight,
        (t.style.overflow = "hidden"),
        (t.style.height = i ? `${i}px` : "0px"),
        (t.style.paddingTop = 0),
        (t.style.paddingBottom = 0),
        (t.style.marginTop = 0),
        (t.style.marginBottom = 0),
        window.setTimeout(() => {
          (t.hidden = !i),
            !i && t.style.removeProperty("height"),
            t.style.removeProperty("padding-top"),
            t.style.removeProperty("padding-bottom"),
            t.style.removeProperty("margin-top"),
            t.style.removeProperty("margin-bottom"),
            !i && t.style.removeProperty("overflow"),
            t.style.removeProperty("transition-duration"),
            t.style.removeProperty("transition-property"),
            t.classList.remove("_slide");
        }, e));
    },
    kr = (t, e = 500, i = 0) => {
      if (!t.classList.contains("_slide")) {
        t.classList.add("_slide"),
          (t.hidden = !t.hidden && null),
          i && t.style.removeProperty("height");
        let n = t.offsetHeight;
        (t.style.overflow = "hidden"),
          (t.style.height = i ? `${i}px` : "0px"),
          (t.style.paddingTop = 0),
          (t.style.paddingBottom = 0),
          (t.style.marginTop = 0),
          (t.style.marginBottom = 0),
          t.offsetHeight,
          (t.style.transitionProperty = "height, margin, padding"),
          (t.style.transitionDuration = e + "ms"),
          (t.style.height = n + "px"),
          t.style.removeProperty("padding-top"),
          t.style.removeProperty("padding-bottom"),
          t.style.removeProperty("margin-top"),
          t.style.removeProperty("margin-bottom"),
          window.setTimeout(() => {
            t.style.removeProperty("height"),
              t.style.removeProperty("overflow"),
              t.style.removeProperty("transition-duration"),
              t.style.removeProperty("transition-property"),
              t.classList.remove("_slide");
          }, e);
      }
    },
    Gr = !0,
    Vr = (t = 500) => {
      document.documentElement.classList.contains("lock") ? Wr(t) : jr(t);
    },
    Wr = (t = 500) => {
      let e = document.querySelector("body");
      if (Gr) {
        let i = document.querySelectorAll("[data-lp]");
        setTimeout(() => {
          for (let t = 0; t < i.length; t++) {
            i[t].style.paddingRight = "0px";
          }
          (e.style.paddingRight = "0px"),
            document.documentElement.classList.remove("lock");
        }, t),
          (Gr = !1),
          setTimeout(function () {
            Gr = !0;
          }, t);
      }
    },
    jr = (t = 500) => {
      let e = document.querySelector("body");
      if (Gr) {
        let i = document.querySelectorAll("[data-lp]");
        for (let t = 0; t < i.length; t++) {
          i[t].style.paddingRight =
            window.innerWidth -
            document.querySelector(".wrapper").offsetWidth +
            "px";
        }
        (e.style.paddingRight =
          window.innerWidth -
          document.querySelector(".wrapper").offsetWidth +
          "px"),
          document.documentElement.classList.add("lock"),
          (Gr = !1),
          setTimeout(function () {
            Gr = !0;
          }, t);
      }
    };
  function qr() {
    document.documentElement.classList.remove("menu-open");
  }
  function Xr(t) {
    setTimeout(() => {
      window.FLS && console.log(t);
    }, 0);
  }
  function Yr(t, e) {
    for (var i = 0; i < t.length; i++) t[i].classList.remove(e);
  }
  function Jr(t, e) {
    const i = Array.from(t).filter(function (t, i, n) {
      if (t.dataset[e]) return t.dataset[e].split(",")[0];
    });
    if (i.length) {
      const t = [];
      i.forEach((i) => {
        const n = {},
          r = i.dataset[e].split(",");
        (n.value = r[0]),
          (n.type = r[1] ? r[1].trim() : "max"),
          (n.item = i),
          t.push(n);
      });
      let n = t.map(function (t) {
        return (
          "(" + t.type + "-width: " + t.value + "px)," + t.value + "," + t.type
        );
      });
      n = uniqArray(n);
      const r = [];
      if (n.length)
        return (
          n.forEach((e) => {
            const i = e.split(","),
              n = i[1],
              s = i[2],
              a = window.matchMedia(i[0]),
              o = t.filter(function (t) {
                if (t.value === n && t.type === s) return !0;
              });
            r.push({ itemsArray: o, matchMedia: a });
          }),
          r
        );
    }
  }
  (window.FLS = !1),
    (function (t) {
      let e = new Image();
      (e.onload = e.onerror =
        function () {
          t(2 == e.height);
        }),
        (e.src =
          "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA");
    })(function (t) {
      let e = !0 === t ? "webp" : "no-webp";
      document.documentElement.classList.add(e);
    }),
    (function () {
      function t(t, e, i = !0) {
        const n = document.querySelector(".cart-actions"),
          r = n.querySelector(".cart-actions__icon"),
          s = r.querySelector("span"),
          a = document.querySelector(`[data-cart-pid="${e}"]`),
          o = document.querySelector(".list-cart");
        if (i) {
          if (
            (s
              ? (s.innerHTML = ++s.innerHTML)
              : r.insertAdjacentHTML("beforeend", "<span>1</span>"),
            a)
          ) {
            const t = a.querySelector(".list-cart__quantity span");
            t.innerHTML = ++t.innerHTML;
          } else {
            const t = document.querySelector(`[data-pid="${e}"]`),
              i = ` \n\t\t\t\t<a href="" class="list-cart__image-ibg ">${
                document.querySelector(".tabs__bg").innerHTML
              }</a>\n\t\t\t\t<div class="list-cart__body">\n\t\t\t\t\t<a href="" class="list-cart__title">${
                t.querySelector(".about-screen__title").innerHTML
              }</a>\n\t\t\t\t\t<div class="list-cart__quantity">Quantity: <span>1</span></div>\n\t\t\t\t\t<a  href="" class="list-cart__delete">Delete</a>\n\t\t\t\t</div>\n\t\t\t\t`;
            o.insertAdjacentHTML(
              "beforeend",
              `<li data-cart-pid="${e}" class="list-cart__item">${i}</li>`
            );
          }
          document.documentElement.classList.remove("_hold");
        } else {
          const t = a.querySelector(".list-cart__quantity span");
          (t.innerHTML = --t.innerHTML), parseInt(t.innerHTML) || a.remove();
          const e = --s.innerHTML;
          e ? (s.innerHTML = e) : (s.remove(), n.classList.remove("_active"));
        }
      }
      document.addEventListener("click", function (e) {
        const i = e.target;
        if (
          (i.classList.contains("icon-menu")
            ? (window.innerWidth <= 767.98 && Vr(),
              document.documentElement.classList.toggle("menu-open"))
            : window.innerWidth >= 767.98 &&
              document.documentElement.classList.contains("menu-open") &&
              !i.closest(".page__aside") &&
              ".page__aside" != i &&
              qr(),
          i.classList.contains("search-actions__icon")
            ? document.documentElement.classList.add("search-open")
            : document.documentElement.classList.contains("search-open") &&
              !i.closest(".search-actions") &&
              document.documentElement.classList.remove("search-open"),
          i.classList.contains("about-screen__btn"))
        ) {
          const n = i.closest(".screen-tab").dataset.pid;
          !(function (e, i) {
            if (!document.documentElement.classList.contains("_hold")) {
              document.documentElement.classList.add("_hold"),
                e.classList.add("_fly");
              const n = document.querySelector(".cart-actions__icon"),
                r = document.querySelector(".tabs__bg"),
                s = r.cloneNode(!0),
                a = r.offsetWidth,
                o = r.offsetHeight,
                l = r.getBoundingClientRect().top,
                h = r.getBoundingClientRect().left;
              s.setAttribute("class", "_flyImage-ibg"),
                (s.style.cssText = ` \n\t\t\tleft: ${h}px;\n\t\t\ttop: ${l}px;\n\t\t\twidth: ${a}px;\n\t\t\theight: ${o}px;\n\t\t\t`),
                document.body.append(s);
              const c = n.getBoundingClientRect().left,
                u = n.getBoundingClientRect().top;
              (s.style.cssText = ` \n\t\t\tleft: ${c}px;\n\t\t\ttop: ${u}px;\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\topacity: 0;\n\t\t\t`),
                s.addEventListener("transitionend", function () {
                  e.classList.contains("_fly") &&
                    (s.remove(), t(e, i), e.classList.remove("_fly"));
                });
            }
          })(i, n),
            e.preventDefault();
        }
        if (
          (i.classList.contains("cart-actions__icon") ||
          i.closest(".cart-actions__icon")
            ? (document.querySelector(".list-cart").children.length > 0 &&
                document
                  .querySelector(".cart-actions")
                  .classList.toggle("_cart-open"),
              e.preventDefault())
            : i.closest(".cart-actions") ||
              i.classList.contains("about-screen__btn") ||
              document
                .querySelector(".cart-actions")
                .classList.remove("_cart-open"),
          i.classList.contains("list-cart__delete"))
        ) {
          const n = i.closest(".list-cart__item").dataset.cartPid;
          t(i, n, !1), e.preventDefault();
        }
      });
    })(),
    (function () {
      const t = document.querySelectorAll("[data-spollers]");
      if (t.length > 0) {
        const e = Array.from(t).filter(function (t, e, i) {
          return !t.dataset.spollers.split(",")[0];
        });
        e.length && n(e);
        let i = Jr(t, "spollers");
        function n(t, e = !1) {
          t.forEach((t) => {
            (t = e ? t.item : t),
              e.matches || !e
                ? (t.classList.add("_spoller-init"),
                  r(t),
                  t.addEventListener("click", s))
                : (t.classList.remove("_spoller-init"),
                  r(t, !1),
                  t.removeEventListener("click", s));
          });
        }
        function r(t, e = !0) {
          const i = t.querySelectorAll("[data-spoller]");
          i.length > 0 &&
            i.forEach((t) => {
              e
                ? (t.removeAttribute("tabindex"),
                  t.classList.contains("_spoller-active") ||
                    (t.nextElementSibling.hidden = !0))
                : (t.setAttribute("tabindex", "-1"),
                  (t.nextElementSibling.hidden = !1));
            });
        }
        function s(t) {
          const e = t.target;
          if (e.closest("[data-spoller]")) {
            const i = e.closest("[data-spoller]"),
              n = i.closest("[data-spollers]"),
              r = !!n.hasAttribute("data-one-spoller");
            n.querySelectorAll("._slide").length ||
              (r && !i.classList.contains("_spoller-active") && a(n),
              i.classList.toggle("_spoller-active"),
              ((t, e = 500) => {
                t.hidden ? kr(t, e) : Ur(t, e);
              })(i.nextElementSibling, 500)),
              t.preventDefault();
          }
        }
        function a(t) {
          const e = t.querySelector("[data-spoller]._spoller-active");
          e &&
            (e.classList.remove("_spoller-active"),
            Ur(e.nextElementSibling, 500));
        }
        i &&
          i.length &&
          i.forEach((t) => {
            t.matchMedia.addEventListener("change", function () {
              n(t.itemsArray, t.matchMedia);
            }),
              n(t.itemsArray, t.matchMedia);
          });
      }
    })(),
    (function () {
      const t = document.querySelectorAll("[data-tabs]");
      let e = [];
      if (t.length > 0) {
        const s = location.hash.replace("#", "");
        s.startsWith("tab-") && (e = s.replace("tab-", "").split("-")),
          t.forEach((t, i) => {
            t.classList.add("_tab-init"),
              t.setAttribute("data-tabs-index", i),
              t.addEventListener("click", r),
              (function (t) {
                const i = t.querySelectorAll("[data-tabs-titles]>*"),
                  r = t.querySelectorAll("[data-tabs-body]>*"),
                  s = t.dataset.tabsIndex,
                  o = e[0] == s;
                if (o) {
                  t.querySelector(
                    "[data-tabs-titles]>._tab-active"
                  ).classList.remove("_tab-active");
                }
                r.length > 0 &&
                  r.forEach((t, n) => {
                    i[n].setAttribute("data-tabs-title", ""),
                      t.setAttribute("data-tabs-item", ""),
                      o && n == e[1] && i[n].classList.add("_tab-active"),
                      (t.hidden = !i[n].classList.contains("_tab-active"));
                  });
                (function (t = !1) {
                  const e = document.querySelectorAll(".other-screen__item"),
                    i = document.querySelectorAll(".tabs__title ");
                  if (e.length > 0 && i.length > 0) {
                    let s = document.querySelector(".tabs__bg img");
                    i.forEach((i) => {
                      if (i.classList.contains("_tab-active") && t) {
                        const t = i.innerHTML.toLowerCase();
                        (s.attributes.src.value = `img/${t}/1.png`),
                          (s.attributes.alt.value = `${t} 1`);
                      }
                      i.addEventListener("click", function (t) {
                        if (
                          (t.preventDefault(),
                          !i.classList.contains("_tab-active"))
                        ) {
                          const t = i.innerHTML.toLowerCase();
                          (s.attributes.src.value = `img/${t}/1.png`),
                            (s.attributes.alt.value = `${t} 1`),
                            Yr(e, "_active"),
                            r(
                              document
                                .querySelector(`.tabs__body_${t}`)
                                .querySelector(
                                  ".other-screen__item,[data-photo='1']"
                                )
                            );
                        }
                      });
                    }),
                      e.forEach((t) => {
                        t.addEventListener("click", function (i) {
                          if (
                            (i.preventDefault(),
                            !t.classList.contains("_active"))
                          ) {
                            Yr(e, "_active");
                            const i = document
                              .querySelector("._tab-active")
                              .innerHTML.toLowerCase();
                            (s.attributes.src.value = `img/${i}/${t.dataset.photo}.png`),
                              (s.attributes.alt.value = `${i} ${t.dataset.photo}`),
                              r(t),
                              Br(),
                              n(".aside");
                          }
                        });
                      });
                  }
                  function r(t) {
                    t.classList.add("_active");
                    const e = t.closest(".screen-tab");
                    (e.querySelector(".about-screen__title").innerHTML = t
                      .querySelector(".other-screen__title")
                      .innerHTML.toLowerCase()),
                      (e.querySelector(".about-screen__text").innerHTML =
                        t.querySelector(".other-screen__subtitle").innerHTML),
                      (e.querySelector(".about-screen__btn").innerHTML =
                        t.querySelector(".other-screen__price").innerHTML +
                        " / buy"),
                      (e.querySelector(".about-rating__value").innerHTML =
                        t.dataset.rating),
                      a();
                  }
                })(!0),
                  Br();
              })(t);
          });
        let o = Jr(t, "tabs");
        o &&
          o.length &&
          o.forEach((t) => {
            t.matchMedia.addEventListener("change", function () {
              i(t.itemsArray, t.matchMedia);
            }),
              i(t.itemsArray, t.matchMedia);
          });
      }
      function i(t, e) {
        t.forEach((t) => {
          const i = (t = t.item).querySelector("[data-tabs-titles]"),
            n = t.querySelectorAll("[data-tabs-title]"),
            r = t.querySelector("[data-tabs-body]");
          t.querySelectorAll("[data-tabs-item]").forEach((s, a) => {
            e.matches
              ? (r.append(n[a]), r.append(s), t.classList.add("_tab-spoller"))
              : (i.append(n[a]), t.classList.remove("_tab-spoller"));
          });
        });
      }
      function r(t) {
        const e = t.target;
        if (e.closest("[data-tabs-title]")) {
          const i = e.closest("[data-tabs-title]"),
            n = i.closest("[data-tabs]");
          if (
            !i.classList.contains("_tab-active") &&
            !n.querySelectorAll("._slide").length
          ) {
            const t = n.querySelector("[data-tabs-title]._tab-active");
            t && t.classList.remove("_tab-active"),
              i.classList.add("_tab-active"),
              (function (t) {
                const e = t.querySelectorAll("[data-tabs-title]"),
                  i = t.querySelectorAll("[data-tabs-item]"),
                  n = t.dataset.tabsIndex,
                  r = (function (t) {
                    if (t.hasAttribute("data-tabs-animate"))
                      return t.dataset.tabsAnimate > 0
                        ? t.dataset.tabsAnimate
                        : 500;
                  })(t);
                i.length > 0 &&
                  i.forEach((t, i) => {
                    e[i].classList.contains("_tab-active")
                      ? (r ? kr(t, r) : (t.hidden = !1),
                        t.closest(".popup") ||
                          (location.hash = `tab-${n}-${i}`))
                      : r
                      ? Ur(t, r)
                      : (t.hidden = !0);
                  });
              })(n),
              Br();
          }
          t.preventDefault();
        }
      }
    })(),
    new Hr({}),
    (function () {
      const t = document.querySelectorAll(
        "input[placeholder],textarea[placeholder]"
      );
      t.length &&
        t.forEach((t) => {
          t.dataset.placeholder = t.placeholder;
        }),
        document.body.addEventListener("focusin", function (t) {
          const e = t.target;
          ("INPUT" !== e.tagName && "TEXTAREA" !== e.tagName) ||
            (e.dataset.placeholder && (e.placeholder = ""),
            e.classList.add("_form-focus"),
            e.parentElement.classList.add("_form-focus"),
            s.removeError(e));
        }),
        document.body.addEventListener("focusout", function (t) {
          const e = t.target;
          ("INPUT" !== e.tagName && "TEXTAREA" !== e.tagName) ||
            (e.dataset.placeholder && (e.placeholder = e.dataset.placeholder),
            e.classList.remove("_form-focus"),
            e.parentElement.classList.remove("_form-focus"),
            e.hasAttribute("data-validate") && s.validateInput(e));
        });
    })(),
    (function (t) {
      const e = document.forms;
      if (e.length)
        for (const t of e)
          t.addEventListener("submit", function (t) {
            i(t.target, t);
          }),
            t.addEventListener("reset", function (t) {
              const e = t.target;
              s.formClean(e);
            });
      async function i(e, i) {
        if (0 === (t ? s.getErrors(e) : 0)) {
          if (e.hasAttribute("data-ajax")) {
            i.preventDefault();
            const t = e.getAttribute("action")
                ? e.getAttribute("action").trim()
                : "#",
              n = e.getAttribute("method")
                ? e.getAttribute("method").trim()
                : "GET",
              s = new FormData(e);
            e.classList.add("_sending");
            const a = await fetch(t, { method: n, body: s });
            if (a.ok) {
              await a.json();
              e.classList.remove("_sending"), r(e);
            } else alert("Ошибка"), e.classList.remove("_sending");
          } else e.hasAttribute("data-dev") && (i.preventDefault(), r(e));
        } else {
          i.preventDefault();
          const t = e.querySelector("._form-error");
          t && e.hasAttribute("data-goto-error") && n(t, !0, 1e3);
        }
      }
      function r(t) {
        document.dispatchEvent(
          new CustomEvent("formSent", { detail: { form: t } })
        ),
          s.formClean(t),
          Xr(`[Формы]: ${"Форма отправлена!"}`);
      }
    })(!0),
    a();
})();
